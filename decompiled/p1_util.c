// Decompiled code from stars.exe (Stars! 2.60j RC3)
// Generated by Ghidra
// 

// ======================================================================
// Function: LpplFromId
// Address: 1038:021e
// ======================================================================


PLANET * __stdcall16far UTIL::LpplFromId(short idPlanet)

{
  int iVar1;
  int *piVar2;
  short sVar3;
  undefined2 uVar4;
  short iHi;
  short iGuess;
  PLANET *lppl;
  short iLo;
  short idGuess;
  
  if ((idPlanet < 0) || (_DATA::game.cPlanMax <= idPlanet)) {
    piVar2 = (int *)0x0;
    uVar4 = 0;
  }
  else {
    uVar4 = _DATA::lpPlanets._2_2_;
    if (c_common::cPlanet == _DATA::game.cPlanMax) {
      piVar2 = (int *)((int)_DATA::lpPlanets + idPlanet * 0x38);
    }
    else {
      iLo = -1;
      iHi = c_common::cPlanet;
      sVar3 = iLo;
      do {
        iLo = sVar3;
        if (iHi <= iLo + 1) {
          piVar2 = (int *)0x0;
          uVar4 = 0;
          break;
        }
        sVar3 = iLo + iHi >> 1;
        piVar2 = (int *)((int)_DATA::lpPlanets + sVar3 * 0x38);
        iVar1 = *piVar2;
      } while ((iVar1 < idPlanet) || (iHi = sVar3, sVar3 = iLo, idPlanet < iVar1));
    }
  }
  return (PLANET *)CONCAT22(uVar4,piVar2);
}



// ======================================================================
// Function: LpflFromId
// Address: 1038:2078
// ======================================================================


FLEET * __stdcall16far UTIL::LpflFromId(short idFleet)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int *piVar4;
  int **ppiVar5;
  short iHi;
  short iplrCur;
  FLEET *lpfl;
  short i;
  short iGuess;
  short iLo;
  short idGuess;
  short iplr;
  
  i = 0;
  for (iplrCur = 0; iplrCur < (int)((uint)idFleet >> 9 & 0xf); iplrCur = iplrCur + 1) {
    i = i + (*(uint *)((int)&DAT_1120_59a6 + iplrCur * 0xc0) & 0xfff);
  }
  iHi = c_common::cFleet;
  iVar2 = i + -1;
  do {
    iLo = iVar2;
    if (iHi <= iLo + 1) {
      piVar3 = (int *)0x0;
      piVar4 = (int *)0x0;
      break;
    }
    iVar2 = iLo + iHi >> 1;
    ppiVar5 = (int **)((int)_DATA::rglpfl + iVar2 * 4);
    piVar3 = *ppiVar5;
    piVar4 = ppiVar5[1];
    iVar1 = *piVar3;
  } while ((iVar1 < (int)(idFleet & 0x1fffU)) ||
          (iHi = iVar2, iVar2 = iLo, (int)(idFleet & 0x1fffU) < iVar1));
  return (FLEET *)CONCAT22(piVar4,piVar3);
}



// ======================================================================
// Function: LpthFromId
// Address: 1038:01b2
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: LpAlloc
// Address: 1060:03b2
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void * __stdcall16far MEMORY::LpAlloc(ushort cb,short ht)

{
  int *piVar1;
  uint uVar2;
  byte *pbVar3;
  uint cb_00;
  uint uVar4;
  uint uVar5;
  int iVar6;
  undefined2 uVar7;
  byte *lpb;
  HB *lphb;
  byte *lpbTop;
  byte *lpbPrev;
  ushort cbItem;
  short fFree;
  
  lphb = (HB *)CONCAT22(*(undefined2 *)(ht * 4 + 0xd36),*(undefined2 *)(ht * 4 + 0xd34));
  cb_00 = cb + 3 & 0xfffe;
  do {
    if ((((int)lphb == 0) && (lphb._2_2_ == 0)) || (cb_00 <= (uint)lphb->cbFree)) {
      if (((int)lphb == 0) && (lphb._2_2_ == 0)) {
        lphb = LphbAlloc(cb_00,ht);
      }
      uVar7 = (undefined2)((ulong)lphb >> 0x10);
      iVar6 = (int)lphb;
      uVar4 = iVar6 + *(int *)(iVar6 + 6);
      lpbTop = (byte *)CONCAT22(uVar7,uVar4);
      if (cb_00 <= *(uint *)(iVar6 + 4)) {
        *(uint *)lpbTop = cb_00 - 2;
        piVar1 = (int *)(iVar6 + 6);
        *piVar1 = *piVar1 + cb_00;
        lphb->cbFree = lphb->cbFree - cb_00;
        piVar1 = (int *)(iVar6 + 4);
        *piVar1 = *piVar1 - cb_00;
LAB_1060_0586:
        return (void *)CONCAT22(uVar7,uVar4 + 2);
      }
      lpb = (byte *)CONCAT22(uVar7,iVar6 + 0x10);
      while (pbVar3 = lpb, uVar2 = (uint)lpb, (uint)lpb < uVar4) {
        uVar7 = lpb._2_2_;
        uVar5 = *(uint *)lpb;
        lpb = (byte *)CONCAT22(lpb._2_2_,(uint)lpb + (*(uint *)lpb & 0xfffe) + 2);
        if ((uVar5 & 1) != 0) {
          for (; (((uint)lpb < uVar4 && ((*(uint *)lpb & 1) != 0)) && ((uint)lpb - uVar2 < cb_00));
              lpb = (byte *)CONCAT22(lpb._2_2_,(uint)lpb + (*(uint *)lpb & 0xfffe) + 2)) {
          }
          uVar5 = (uint)lpb - uVar2;
          *(uint *)pbVar3 = uVar5 - 2 | 1;
          if (cb_00 <= uVar5) {
            *(uint *)pbVar3 = *(uint *)pbVar3 & 0xfffe;
            lphb->cbFree = lphb->cbFree - uVar5;
            uVar4 = uVar2;
            goto LAB_1060_0586;
          }
        }
      }
    }
    uVar7 = (undefined2)((ulong)lphb >> 0x10);
    lphb = (HB *)CONCAT22(*(undefined2 *)((int)lphb + 10),*(undefined2 *)((int)lphb + 8));
  } while( true );
}



// ======================================================================
// Function: LpReAlloc
// Address: 1060:0660
// ======================================================================


void * __stdcall16far MEMORY::LpReAlloc(void *lp,ushort cb,short ht)

{
  int *piVar1;
  uint uVar2;
  uint cb_00;
  uint uVar3;
  int iVar4;
  int iVar5;
  HB *lphb_00;
  void *pvVar6;
  ushort cbGrow;
  ushort cbCur;
  HB *lphb;
  void *lpNew;
  
  uVar2 = *(uint *)((int)lp + -2);
  cb_00 = cb + 1 & 0xfffe;
  uVar3 = cb_00 - uVar2;
  pvVar6 = lp;
  if (uVar2 < cb_00) {
    lphb_00 = LphbFromLpHt(lp,ht);
    while( true ) {
      iVar5 = (int)((ulong)lphb_00 >> 0x10);
      iVar4 = (int)lphb_00;
      if (((iVar4 + *(int *)(iVar4 + 6) == (int)lp + uVar2) && (iVar5 == lp._2_2_)) &&
         (uVar3 <= *(uint *)(iVar4 + 4))) {
        piVar1 = (int *)(iVar4 + 4);
        *piVar1 = *piVar1 - uVar3;
        lphb_00->cbFree = lphb_00->cbFree - uVar3;
        piVar1 = (int *)(iVar4 + 6);
        *piVar1 = *piVar1 + uVar3;
        *(uint *)((int)lp + -2) = cb_00;
        return lp;
      }
      if ((ht != 3) && (ht != 10)) break;
      lphb_00 = LphbReAlloc(lphb_00);
      lp = (void *)CONCAT22((int)((ulong)lphb_00 >> 0x10),(int)lphb_00 + 0x12);
    }
    pvVar6 = LpAlloc(cb_00,ht);
    PUBLIC::__fmemcpy(pvVar6,(int)lp,lp._2_2_,uVar2);
    FreeLp(lp,ht);
  }
  return pvVar6;
}



// ======================================================================
// Function: LphbAlloc
// Address: 1060:0000
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

HB * __stdcall16far MEMORY::LphbAlloc(ushort cb,short ht)

{
  undefined2 uVar1;
  int iVar2;
  char *sz;
  int iVar3;
  undefined2 uVar4;
  undefined2 unaff_CS;
  HB *pHVar5;
  short mbType;
  HB *lphb;
  ushort hmem;
  
                    /* Segment:    13
                       Offset:     00062900
                       Length:     0959
                       Min Alloc:  0959
                       Flags:      1d50
                           Code
                           Discardable
                           Moveable
                           Preload
                           Impure (Non-shareable)
                        */
  cb = cb + 0x10;
  if (cb < *(uint *)(ht * 2 + 0xd64)) {
    cb = *(ushort *)(ht * 2 + 0xd64);
  }
  iVar2 = GLOBALALLOC(unaff_CS,cb,0);
  if (iVar2 == 0) {
    mbType = 0x10;
    sz = MSG::PszFormatIds(0x1a,(short *)0x0);
    UTILGEN::AlertSz(sz,mbType);
    PUBLIC::_longjmp();
  }
  pHVar5 = (HB *)GLOBALLOCK();
  uVar4 = (undefined2)((ulong)pHVar5 >> 0x10);
  iVar3 = (int)pHVar5;
  *(int *)(iVar3 + 0xc) = iVar2;
  *(ushort *)(iVar3 + 2) = cb;
  *(int *)(iVar3 + 4) = cb - 0x10;
  pHVar5->cbFree = cb - 0x10;
  *(undefined2 *)(iVar3 + 6) = 0x10;
  *(undefined *)(iVar3 + 0xe) = (char)ht;
  uVar1 = *(undefined2 *)(ht * 4 + 0xd36);
  *(undefined2 *)(iVar3 + 8) = *(undefined2 *)(ht * 4 + 0xd34);
  *(undefined2 *)(iVar3 + 10) = uVar1;
  *(int *)(ht * 4 + 0xd34) = iVar3;
  *(undefined2 *)(ht * 4 + 0xd36) = uVar4;
  return pHVar5;
}



// ======================================================================
// Function: LphbReAlloc
// Address: 1060:0108
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

HB * __stdcall16far MEMORY::LphbReAlloc(HB *lphb)

{
  int *piVar1;
  uint uVar2;
  char *sz;
  int iVar3;
  undefined2 uVar4;
  int iVar5;
  HB *pHVar6;
  short mbType;
  ushort cbGrow;
  ushort cbCur;
  HB *lphbNew;
  HB *lphbT;
  ushort hmem;
  
  if (lphb == (HB *)0x0) {
    return (HB *)0x0;
  }
  hmem = *(ushort *)((int)lphb + 0xc);
  uVar2 = *(uint *)((int)lphb + 2);
  cbGrow = *(ushort *)((uint)*(byte *)((int)lphb + 0xe) * 2 + 0xd64);
  if (uVar2 < 0xffdc) {
    if (-cbGrow - 0x24 < uVar2) {
      cbGrow = -uVar2 - 0x24;
    }
    GLOBALUNLOCK();
    hmem = GLOBALREALLOC(0x14f8,0x22,*(int *)((int)lphb + 2) + cbGrow,0);
    if (hmem != 0) goto LAB_1060_01db;
  }
  mbType = 0x10;
  sz = MSG::PszFormatIds(0x1a,(short *)0x0);
  UTILGEN::AlertSz(sz,mbType);
  PUBLIC::_longjmp();
LAB_1060_01db:
  pHVar6 = (HB *)GLOBALLOCK();
  uVar4 = (undefined2)((ulong)pHVar6 >> 0x10);
  iVar3 = (int)pHVar6;
  *(ushort *)(iVar3 + 0xc) = hmem;
  iVar5 = (uint)*(byte *)(iVar3 + 0xe) * 4;
  if ((*(int *)(iVar5 + 0xd34) == (int)lphb) && (*(int *)(iVar5 + 0xd36) == lphb._2_2_)) {
    iVar5 = (uint)*(byte *)(iVar3 + 0xe) * 4;
    *(int *)(iVar5 + 0xd34) = iVar3;
    *(undefined2 *)(iVar5 + 0xd36) = uVar4;
  }
  else {
    iVar5 = (uint)*(byte *)(iVar3 + 0xe) * 4;
    lphbT = (HB *)CONCAT22(*(undefined2 *)(iVar5 + 0xd36),*(undefined2 *)(iVar5 + 0xd34));
    while( true ) {
      if ((((int)lphbT == 0) && (lphbT._2_2_ == 0)) ||
         ((*(int *)((int)lphbT + 8) == (int)lphb && (*(int *)((int)lphbT + 10) == lphb._2_2_))))
      break;
      lphbT = (HB *)CONCAT22(*(undefined2 *)((int)lphbT + 10),*(undefined2 *)((int)lphbT + 8));
    }
    *(int *)((int)lphbT + 8) = iVar3;
    *(undefined2 *)((int)lphbT + 10) = uVar4;
  }
  piVar1 = (int *)(iVar3 + 2);
  *piVar1 = *piVar1 + cbGrow;
  pHVar6->cbFree = pHVar6->cbFree + cbGrow;
  piVar1 = (int *)(iVar3 + 4);
  *piVar1 = *piVar1 + cbGrow;
  return pHVar6;
}



// ======================================================================
// Function: Random
// Address: 1040:16d2
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10401832) */

short __cdecl16far UTILGEN::Random(short c)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  short sVar5;
  undefined4 uVar6;
  long lVar7;
  long lVar8;
  long lVar9;
  undefined2 uVar10;
  undefined2 uVar11;
  long s2;
  long k;
  long s1;
  long z;
  
  iVar4 = _DATA::lRandSeed2._2_2_;
  uVar3 = (uint)_DATA::lRandSeed2;
  iVar2 = _DATA::lRandSeed1._2_2_;
  uVar1 = (uint)_DATA::lRandSeed1;
  uVar6 = PUBLIC::__aFldiv((uint)_DATA::lRandSeed1,_DATA::lRandSeed1._2_2_,0xd1a4,0);
  lVar7 = PUBLIC::__aFulmul(uVar6,0x2fb3,0);
  uVar11 = 0;
  uVar10 = 0x9c4e;
  uVar6 = PUBLIC::__aFulmul(uVar6,0xd1a4,0);
  lVar8 = PUBLIC::__aFulmul(uVar1 - (uint)uVar6,
                            (iVar2 - (int)((ulong)uVar6 >> 0x10)) - (uint)(uVar1 < (uint)uVar6),
                            uVar10,uVar11);
  lVar8 = lVar8 - lVar7;
  if ((lVar8 < 0x10000) && (lVar8 < 0)) {
    lVar8 = lVar8 + 0x7fffffab;
  }
  uVar6 = PUBLIC::__aFldiv(uVar3,iVar4,0xce26,0);
  lVar9 = PUBLIC::__aFulmul(uVar6,0xecf,0);
  uVar11 = 0;
  uVar10 = 0x9ef4;
  uVar6 = PUBLIC::__aFulmul(uVar6,0xce26,0);
  lVar7 = PUBLIC::__aFulmul(uVar3 - (uint)uVar6,
                            (iVar4 - (int)((ulong)uVar6 >> 0x10)) - (uint)(uVar3 < (uint)uVar6),
                            uVar10,uVar11);
  lVar7 = lVar7 - lVar9;
  if ((lVar7 < 0x10000) && (lVar7 < 0)) {
    lVar7 = lVar7 + 0x7fffff07;
  }
  lVar9 = lVar8 - lVar7;
  if (lVar9 < 1) {
    lVar9 = lVar9 + 0x7fffffaa;
  }
  if (c < 1) {
    sVar5 = 0;
  }
  else {
    _DATA::lRandSeed2 = lVar7;
    _DATA::lRandSeed1 = lVar8;
    sVar5 = PUBLIC::__aFulrem(lVar9,c,c >> 0xf);
    lVar7 = _DATA::lRandSeed2;
    lVar8 = _DATA::lRandSeed1;
  }
  _DATA::lRandSeed1._2_2_ = (int)((ulong)lVar8 >> 0x10);
  _DATA::lRandSeed1._0_2_ = (uint)lVar8;
  _DATA::lRandSeed2._2_2_ = (int)((ulong)lVar7 >> 0x10);
  _DATA::lRandSeed2._0_2_ = (uint)lVar7;
  return sVar5;
}



// ======================================================================
// Function: Randomize
// Address: 1040:15ea
// ======================================================================


void __cdecl16far UTILGEN::Randomize(ulong dw)

{
  uint uVar1;
  short b;
  short a;
  
  uVar1 = PUBLIC::__aFulshr();
  b = uVar1 & 0x3f;
  if (((uint)dw & 0x3f) == b) {
    b = b + 1U & 0x3f;
  }
  _DATA::lRandSeed1._0_2_ = *(int *)((int)_DATA::vrptFleet.rgbdx + 6 + ((uint)dw & 0x3f) * 2);
  _DATA::lRandSeed1._2_2_ = (int)_DATA::lRandSeed1 >> 0xf;
  _DATA::lRandSeed2._0_2_ = *(int *)((int)_DATA::vrptFleet.rgbdx + 6 + b * 2);
  _DATA::lRandSeed2._2_2_ = (int)_DATA::lRandSeed2 >> 0xf;
  return;
}



