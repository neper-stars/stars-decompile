// Call tree decompilation from stars.exe (Stars! 2.60j RC3)
// Root function: FWriteDataFile
// Max depth: 2
// Total functions: 66
// Generated by Ghidra
//

// ======================================================================
// Function: AlertSz
// Address: 1040:2160
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: FAppendFile
// Address: 1070:704e
// ======================================================================


short __cdecl16far IO::FAppendFile(short iPlayer)

{
  short sVar1;
  
  sVar1 = FMarkFile((int)s_M6101__MATH___floating_point_err_1120_1ff1 + 0x12,iPlayer,4,1);
  if (sVar1 != 0) {
    WriteBOF(iPlayer,3,1);
  }
  return (uint)(sVar1 != 0);
}



// ======================================================================
// Function: FAttackPlayer
// Address: 10f0:ae06
// ======================================================================


short __cdecl16far BATTLE::FAttackPlayer(FLEET *lpfl,short iplr)

{
  int iVar1;
  uint uVar2;
  undefined2 uVar3;
  short iplrT;
  short iplrCur;
  
  uVar3 = (undefined2)((ulong)lpfl >> 0x10);
  iVar1 = *(int *)((int)lpfl + 2);
  uVar2 = *(uint *)(*(int *)((int)&c_common::rglpbtlplan + iVar1 * 4) +
                    (uint)*(byte *)((int)lpfl + 0x60) * 0x24 + 2) >> 8 & 0x1f;
  if (uVar2 == 0) {
    uVar2 = 0;
  }
  else if (uVar2 == 1) {
    uVar2 = (uint)(*(char *)(iVar1 * 0xc0 + 0x5a12 + iplr) == '\x02');
  }
  else if (uVar2 == 2) {
    uVar2 = (uint)(*(char *)(iVar1 * 0xc0 + 0x5a12 + iplr) != '\x01');
  }
  else if (uVar2 == 3) {
    uVar2 = 1;
  }
  else {
    uVar2 = (uint)(iplr == uVar2 - 4);
  }
  return uVar2;
}



// ======================================================================
// Function: FCompressUserString
// Address: 1040:45a0
// ======================================================================


short __cdecl16far UTILGEN::FCompressUserString(char *szIn,char *szOut,short *pcOut)

{
  byte *pbVar1;
  bool bVar2;
  short cNyb;
  char *pchOut;
  short iNyb;
  char szWork;
  short fHalf;
  
  fHalf = 0;
  pchOut = &szWork;
  do {
    if (*szIn == '\0') {
      if (fHalf != 0) {
        pbVar1 = (byte *)pchOut;
        *pbVar1 = *pbVar1 | 0xf;
        pchOut = pchOut + 1;
      }
      bVar2 = (int)pchOut - (int)&szWork <= *pcOut;
      if (bVar2) {
        *pcOut = (int)pchOut - (int)&szWork;
        PUBLIC::__fmemcpy(szOut,&szWork);
      }
      return (uint)bVar2;
    }
    iNyb = NybbleFromCh(*szIn);
    if (iNyb < 0xb) {
      cNyb = 1;
    }
    else if ((iNyb & 0xfU) == 0xf) {
      cNyb = 3;
    }
    else {
      cNyb = 2;
    }
    while (cNyb != 0) {
      if (fHalf == 0) {
        *pchOut = (char)((iNyb & 0xfU) << 4);
        fHalf = 1;
      }
      else {
        pbVar1 = (byte *)pchOut;
        *pbVar1 = *pbVar1 | (byte)iNyb & 0xf;
        pchOut = pchOut + 1;
        fHalf = 0;
        if (0x3ff < (int)pchOut - (int)&szWork) {
          return 0;
        }
      }
      iNyb = iNyb >> 4;
      cNyb = cNyb + -1;
    }
    szIn = (char *)CONCAT22(szIn._2_2_,(int)szIn + 1);
  } while( true );
}



// ======================================================================
// Function: FCreateFile
// Address: 1070:8e16
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

short __cdecl16far IO::FCreateFile(ushort dt,short iPlayer,char *szForceName)

{
  int iVar1;
  char *psz;
  short env;
  short *penvMemSav;
  
  if (szForceName == (char *)0x0) {
    SetSzWorkFromDt(dt,iPlayer);
    psz = (char *)&c_common::szWork;
  }
  else {
    psz = szForceName;
  }
  penvMemSav = _penvMem;
  _penvMem = &env;
  iVar1 = PUBLIC::__setjmp(&env);
  if (iVar1 != 0) {
    _penvMem = penvMemSav;
  }
  else {
    StreamOpen(psz,0x1012);
    WriteBOF(iPlayer,dt,0);
    _penvMem = penvMemSav;
  }
  return (uint)(iVar1 == 0);
}



// ======================================================================
// Function: FFindNearestObject
// Address: 1038:4070
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: FMarkFile
// Address: 1070:904a
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x107090a4) */
/* WARNING: Could not reconcile some variable overlaps */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

short __cdecl16far IO::FMarkFile(ushort dt,short iPlayer,short mdMark,short f)

{
  undefined2 *puVar1;
  RTBOF *pRVar2;
  int iVar3;
  undefined2 *puVar4;
  RTBOF *pRVar5;
  undefined2 unaff_SS;
  bool bVar6;
  long lSeedSav1;
  long lSeedSav2;
  short fSilentSav;
  short fSuccess;
  short fChange;
  short env;
  short *penvMemSav;
  RTBOF rtbof;
  short ids;
  
  fSilentSav = _DATA::fFileErrSilent;
  fSuccess = 0;
  SetSzWorkFromDt(dt & 0xff,iPlayer);
  penvMemSav = _penvMem;
  _penvMem = &env;
  iVar3 = PUBLIC::__setjmp(&env);
  if (iVar3 != 0) {
    _DATA::fFileErrSilent = fSilentSav;
    StreamClose();
    _penvMem = penvMemSav;
    return 0;
  }
  _DATA::fFileErrSilent = 1;
  StreamOpen((char *)&c_common::szWork,0x12);
  _DATA::fFileErrSilent = fSilentSav;
  ReadRt();
  if (c_common::hdrCur >> 10 == 8) {
    if ((DAT_1120_4ba0 >> 0xc < 2) ||
       ((DAT_1120_4ba0 >> 0xc == 2 && ((DAT_1120_4ba0 >> 5 & 0x7f) < 0x31)))) {
      FileError(0x4d3);
    }
    else if ((DAT_1120_4ba0 >> 0xc < 3) &&
            ((DAT_1120_4ba0 >> 0xc != 2 || ((DAT_1120_4ba0 >> 5 & 0x7f) < 0x54)))) {
      puVar4 = (undefined2 *)&c_common::rgbCur;
      pRVar5 = &rtbof;
      for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {
        pRVar2 = pRVar5;
        pRVar5 = (RTBOF *)(pRVar5->rgid + 2);
        puVar1 = puVar4;
        puVar4 = puVar4 + 1;
        *(undefined2 *)pRVar2->rgid = *puVar1;
      }
      if (((int)_DATA::game.lid != 0) || (_DATA::game.lid._2_2_ != 0)) {
        if (((int)rtbof.lidGame == (int)_DATA::game.lid) &&
           (rtbof.lidGame._2_2_ == _DATA::game.lid._2_2_)) {
          fChange = 0;
          if (mdMark == 1) {
            bVar6 = ((uint)rtbof.flags8 >> 9 & 1) != f;
            if (bVar6) {
              lSeedSav2._2_2_ = f;
              rtbof.flags8 = rtbof.flags8 & 0xfdffU | (f & 1U) << 9;
            }
            fChange = (short)bVar6;
          }
          else if (mdMark == 2) {
            bVar6 = ((uint)rtbof.flags8 >> 8 & 1) != f;
            if (bVar6) {
              lSeedSav2._2_2_ = f;
              rtbof.flags8 = rtbof.flags8 & 0xfeffU | (f & 1U) << 8;
            }
            fChange = (short)bVar6;
          }
          else if (mdMark == 4) {
            bVar6 = ((uint)rtbof.flags8 >> 10 & 1) != f;
            if (bVar6) {
              lSeedSav2._2_2_ = f;
              rtbof.flags8 = rtbof.flags8 & 0xfbffU | (f & 1U) << 10;
            }
            fChange = (short)bVar6;
          }
          else if (mdMark == 8) {
            do {
              do {
                UTILGEN::GetFileSeeds(&lSeedSav1,&lSeedSav2);
                ReadRt();
              } while (c_common::hdrCur >> 10 != 6);
            } while ((char)c_common::rgbCur != iPlayer);
            if ((DAT_1120_4b9e >> 9 & 1) != f) {
              if ((DAT_1120_4b9e >> 9 & 1) == 0) {
                DAT_1120_4b9e = DAT_1120_4b9e & 0x1dff | 0xe200;
              }
              else {
                if (DAT_1120_4b9e >> 0xd != 7) goto IO_LBadFile_3;
                DAT_1120_4b9e = DAT_1120_4b9e & 0xfdff;
              }
              DAT_1120_4ba4 = ~DAT_1120_4ba4;
              DAT_1120_4ba6 = ~DAT_1120_4ba6;
              iVar3 = -((c_common::hdrCur & 0x3ff) + 2);
              PUBLIC::__lseek(0x1070,_DATA::hf,(char)iVar3,(char)(iVar3 >> 0xf),1);
              UTILGEN::SetFileSeeds
                        (CONCAT22(lSeedSav1._2_2_,(undefined2)lSeedSav1),
                         CONCAT13((char)((uint)lSeedSav2._2_2_ >> 8),
                                  CONCAT12((char)lSeedSav2._2_2_,(undefined2)lSeedSav2)));
              WriteRt(6,c_common::hdrCur & 0x3ff,&c_common::rgbCur);
              fChange = (short)(dt == 3);
              rtbof.flags8 = rtbof.flags8 & 0xfeff;
            }
          }
          if (fChange != 0) {
            PUBLIC::__lseek(0x1070,_DATA::hf,0,0,0);
            WriteRt(8,0x10,(void *)CONCAT13((char)((uint)unaff_SS >> 8),
                                            CONCAT12((char)unaff_SS,&rtbof)));
          }
          fSuccess = 1;
        }
        else {
          FileError(0x1d);
        }
      }
    }
    else {
      FileError(0x2ca);
    }
  }
  else {
    FileError(0xd);
  }
IO_LBadFile_3:
  if (((dt & 0x2000) == 0) || (fSuccess == 0)) {
    StreamClose();
  }
  else {
    PUBLIC::__lseek(0x1070,_DATA::hf,0,0,2);
  }
  _penvMem = penvMemSav;
  return fSuccess;
}



// ======================================================================
// Function: FMatchTarget
// Address: 1038:6612
// ======================================================================


short __cdecl16far UTIL::FMatchTarget(FLEET *lpflTarget,short mdTarget,short fExact)

{
  uint uVar1;
  int iVar2;
  HULDEF *pHVar3;
  short ish;
  short imd;
  
  if (mdTarget != 3) {
    if (mdTarget == 4) {
      for (ish = 0; ish < 0x10; ish = ish + 1) {
        if (*(int *)((int)lpflTarget + 0xc + ish * 2) != 0) {
          iVar2 = *(int *)((int)lpflTarget + 2) * 4;
          pHVar3 = PARTS::LphuldefFromId(*(short *)(*(int *)(iVar2 + 0xfe) + ish * 0x93));
          uVar1 = *(uint *)((int)pHVar3 + 0x7b) >> 10 & 0xf;
          if ((uVar1 == 1) || (uVar1 == 5)) break;
        }
      }
      if (ish != 0x10) {
        return 1;
      }
      return 0;
    }
    if (mdTarget != 5) {
      if (mdTarget == 6) {
        ish = 0;
        while ((ish < 0x10 &&
               ((*(int *)((int)lpflTarget + 0xc + ish * 2) == 0 ||
                (iVar2 = *(int *)((int)lpflTarget + 2) * 4,
                pHVar3 = PARTS::LphuldefFromId(*(short *)(*(int *)(iVar2 + 0xfe) + ish * 0x93)),
                (*(uint *)((int)pHVar3 + 0x7b) >> 10 & 0xf) != 7))))) {
          ish = ish + 1;
        }
        if (ish != 0x10) {
          return 1;
        }
        return 0;
      }
      if (mdTarget != 7) {
        if (fExact == 0) {
          return 1;
        }
        return 0;
      }
      ish = 0;
      while ((ish < 0x10 &&
             ((*(int *)((int)lpflTarget + 0xc + ish * 2) == 0 ||
              (iVar2 = *(int *)((int)lpflTarget + 2) * 4,
              pHVar3 = PARTS::LphuldefFromId(*(short *)(*(int *)(iVar2 + 0xfe) + ish * 0x93)),
              (*(uint *)((int)pHVar3 + 0x7b) >> 10 & 0xf) != 1))))) {
        ish = ish + 1;
      }
      if (ish != 0x10) {
        return 1;
      }
      return 0;
    }
  }
  for (ish = 0; ish < 0x10; ish = ish + 1) {
    if (*(int *)((int)lpflTarget + 0xc + ish * 2) != 0) {
      iVar2 = *(int *)((int)lpflTarget + 2) * 4;
      pHVar3 = PARTS::LphuldefFromId(*(short *)(*(int *)(iVar2 + 0xfe) + ish * 0x93));
      uVar1 = *(uint *)((int)pHVar3 + 0x7b) >> 10 & 0xf;
      if ((1 < uVar1) && (uVar1 < 5)) break;
    }
  }
  if (mdTarget == 3) {
    if (ish == 0x10) {
      return 0;
    }
  }
  else if (ish != 0x10) {
    return 0;
  }
  return 1;
}



// ======================================================================
// Function: FSendPlrMsg
// Address: 1030:7ee8
// ======================================================================


short __cdecl16far
MSG::FSendPlrMsg(short iPlr,short iMsg,short iObj,short p1,short p2,short p3,short p4,short p5,
                short p6,short p7)

{
  short sVar1;
  uint uVar2;
  byte *lpb;
  short cbMsg;
  byte rgbWork;
  
  sVar1 = PackageUpMsg(&rgbWork,iPlr,iMsg,iObj,p1,p2,p3,p4,p5,p6,p7);
  if (sVar1 < 1) {
    uVar2 = (uint)(sVar1 == 0);
  }
  else {
    PUBLIC::__fmemmove((int)_DATA::lpMsg + _DATA::imemMsgCur,_DATA::lpMsg._2_2_,&rgbWork);
    _DATA::imemMsgCur = _DATA::imemMsgCur + sVar1;
    _DATA::cMsg = _DATA::cMsg + 1;
    uVar2 = 1;
  }
  return uVar2;
}



// ======================================================================
// Function: FSendPlrMsg2
// Address: 1030:7eaa
// ======================================================================


short __cdecl16far MSG::FSendPlrMsg2(short iPlr,short iMsg,short iObj,short p1,short p2)

{
  short sVar1;
  
  sVar1 = FSendPlrMsg(iPlr,iMsg,iObj,p1,p2,0,0,0,0,0);
  return sVar1;
}



// ======================================================================
// Function: FWriteDataFile
// Address: 1070:5964
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: GetRaceStat
// Address: 10e0:30d2
// ======================================================================


short __cdecl16far RACE::GetRaceStat(PLAYER *pplr,short iStat)

{
  return (int)pplr->rgAttr[iStat];
}



// ======================================================================
// Function: IFindIdealWarp
// Address: 1050:a76e
// ======================================================================


short __cdecl16far SHIP::IFindIdealWarp(FLEET *lpfl,short fIgnoreScoops)

{
  uint id;
  undefined2 uVar1;
  int iVar2;
  ENGINE *pEVar3;
  ENGINE *lpengine;
  short iWorst;
  short j;
  short i;
  
  iWorst = 10;
  if (((int)lpfl == 0) && (lpfl._2_2_ == 0)) {
    lpfl = (FLEET *)&DAT_1120_4972;
  }
  i = 0;
  do {
    if (0xf < i) {
      return iWorst;
    }
    if (0 < *(int *)((int)lpfl + 0xc + i * 2)) {
      j = 0;
      while ((iVar2 = *(int *)((int)lpfl + 2) * 4,
             j < (int)(uint)*(byte *)(*(int *)(iVar2 + 0xfe) + i * 0x93 + 0x7a) &&
             (iVar2 = *(int *)((int)lpfl + 2) * 4,
             *(int *)(*(int *)(iVar2 + 0xfe) + i * 0x93 + 0x3a + j * 4) != 1))) {
        j = j + 1;
      }
      iVar2 = *(int *)((int)lpfl + 2) * 4;
      if (j == (uint)*(byte *)(*(int *)(iVar2 + 0xfe) + i * 0x93 + 0x7a)) {
        return 0;
      }
      iVar2 = *(int *)((int)lpfl + 2) * 4;
      id = *(uint *)(*(int *)(iVar2 + 0xfe) + i * 0x93 + j * 4 + 0x3c) & 0xff;
      pEVar3 = PARTS::LpengineFromId(id);
      uVar1 = (undefined2)((ulong)pEVar3 >> 0x10);
      iVar2 = (int)pEVar3;
      for (; 0 < iWorst; iWorst = iWorst + -1) {
        if (*(int *)(iVar2 + 0x36 + iWorst * 2) < 0x79) {
          if ((((0 < *(int *)(iVar2 + 0x36 + iWorst * 2)) && (fIgnoreScoops == 0)) && (id != 0xe))
             && (id != 0xf)) {
            if ((iWorst < 5) || (*(int *)(iVar2 + 0x36 + (iWorst + -1) * 2) != 0)) {
              if ((iWorst < 6) || (*(int *)(iVar2 + 0x36 + (iWorst + -2) * 2) != 0)) {
                if ((6 < iWorst) && (*(int *)(iVar2 + 0x36 + (iWorst + -3) * 2) == 0)) {
                  iWorst = iWorst + -3;
                }
              }
              else {
                iWorst = iWorst + -2;
              }
            }
            else {
              iWorst = iWorst + -1;
            }
          }
          if (((((iWorst == 10) && (id != 7)) && (id != 8)) && ((id != 9 && (id != 0xe)))) &&
             (id != 0xf)) {
            iWorst = 9;
          }
          break;
        }
      }
    }
    i = i + 1;
  } while( true );
}



// ======================================================================
// Function: LpReAlloc
// Address: 1060:0660
// ======================================================================


void * __stdcall16far MEMORY::LpReAlloc(void *lp,ushort cb,short ht)

{
  int *piVar1;
  uint uVar2;
  uint cb_00;
  uint uVar3;
  int iVar4;
  int iVar5;
  HB *lphb_00;
  void *pvVar6;
  ushort cbGrow;
  ushort cbCur;
  HB *lphb;
  void *lpNew;
  
  uVar2 = *(uint *)((int)lp + -2);
  cb_00 = cb + 1 & 0xfffe;
  uVar3 = cb_00 - uVar2;
  pvVar6 = lp;
  if (uVar2 < cb_00) {
    lphb_00 = LphbFromLpHt(lp,ht);
    while( true ) {
      iVar5 = (int)((ulong)lphb_00 >> 0x10);
      iVar4 = (int)lphb_00;
      if (((iVar4 + *(int *)(iVar4 + 6) == (int)lp + uVar2) && (iVar5 == lp._2_2_)) &&
         (uVar3 <= *(uint *)(iVar4 + 4))) {
        piVar1 = (int *)(iVar4 + 4);
        *piVar1 = *piVar1 - uVar3;
        lphb_00->cbFree = lphb_00->cbFree - uVar3;
        piVar1 = (int *)(iVar4 + 6);
        *piVar1 = *piVar1 + uVar3;
        *(uint *)((int)lp + -2) = cb_00;
        return lp;
      }
      if ((ht != 3) && (ht != 10)) break;
      lphb_00 = LphbReAlloc(lphb_00);
      lp = (void *)CONCAT22((int)((ulong)lphb_00 >> 0x10),(int)lphb_00 + 0x12);
    }
    pvVar6 = LpAlloc(cb_00,ht);
    PUBLIC::__fmemcpy(pvVar6,(int)lp,lp._2_2_,uVar2);
    FreeLp(lp,ht);
  }
  return pvVar6;
}



// ======================================================================
// Function: LpengineFromId
// Address: 1008:5168
// ======================================================================


ENGINE * __stdcall16far PARTS::LpengineFromId(short id)

{
  undefined2 unaff_CS;
  
  return (ENGINE *)CONCAT22(unaff_CS,id * 0x4e);
}



// ======================================================================
// Function: LpflFromId
// Address: 1038:2078
// ======================================================================


FLEET * __stdcall16far UTIL::LpflFromId(short idFleet)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int *piVar4;
  int **ppiVar5;
  short iHi;
  short iplrCur;
  FLEET *lpfl;
  short i;
  short iGuess;
  short iLo;
  short idGuess;
  short iplr;
  
  i = 0;
  for (iplrCur = 0; iplrCur < (int)((uint)idFleet >> 9 & 0xf); iplrCur = iplrCur + 1) {
    i = i + (*(uint *)((int)&DAT_1120_59a6 + iplrCur * 0xc0) & 0xfff);
  }
  iHi = c_common::cFleet;
  iVar2 = i + -1;
  do {
    iLo = iVar2;
    if (iHi <= iLo + 1) {
      piVar3 = (int *)0x0;
      piVar4 = (int *)0x0;
      break;
    }
    iVar2 = iLo + iHi >> 1;
    ppiVar5 = (int **)((int)_DATA::rglpfl + iVar2 * 4);
    piVar3 = *ppiVar5;
    piVar4 = ppiVar5[1];
    iVar1 = *piVar3;
  } while ((iVar1 < (int)(idFleet & 0x1fffU)) ||
          (iHi = iVar2, iVar2 = iLo, (int)(idFleet & 0x1fffU) < iVar1));
  return (FLEET *)CONCAT22(piVar4,piVar3);
}



// ======================================================================
// Function: LphuldefFromId
// Address: 1008:512c
// ======================================================================


HULDEF * __stdcall16far PARTS::LphuldefFromId(short id)

{
  undefined2 unaff_CS;
  HULDEF *pHVar1;
  
  if (id < 0x20) {
    pHVar1 = (HULDEF *)CONCAT22(unaff_CS,id * 0x8f + 0x29f0);
  }
  else {
    pHVar1 = LphuldefSBFromId(id + -0x20);
  }
  return pHVar1;
}



// ======================================================================
// Function: LpplFromId
// Address: 1038:021e
// ======================================================================


PLANET * __stdcall16far UTIL::LpplFromId(short idPlanet)

{
  int iVar1;
  int *piVar2;
  short sVar3;
  undefined2 uVar4;
  short iHi;
  short iGuess;
  PLANET *lppl;
  short iLo;
  short idGuess;
  
  if ((idPlanet < 0) || (_DATA::game.cPlanMax <= idPlanet)) {
    piVar2 = (int *)0x0;
    uVar4 = 0;
  }
  else {
    uVar4 = _DATA::lpPlanets._2_2_;
    if (c_common::cPlanet == _DATA::game.cPlanMax) {
      piVar2 = (int *)((int)_DATA::lpPlanets + idPlanet * 0x38);
    }
    else {
      iLo = -1;
      iHi = c_common::cPlanet;
      sVar3 = iLo;
      do {
        iLo = sVar3;
        if (iHi <= iLo + 1) {
          piVar2 = (int *)0x0;
          uVar4 = 0;
          break;
        }
        sVar3 = iLo + iHi >> 1;
        piVar2 = (int *)((int)_DATA::lpPlanets + sVar3 * 0x38);
        iVar1 = *piVar2;
      } while ((iVar1 < idPlanet) || (iHi = sVar3, sVar3 = iLo, idPlanet < iVar1));
    }
  }
  return (PLANET *)CONCAT22(uVar4,piVar2);
}



// ======================================================================
// Function: LpplReAlloc
// Address: 1060:0836
// ======================================================================


PL * __stdcall16far MEMORY::LpplReAlloc(PL *lppl,ushort cAlloc)

{
  PL *pPVar1;
  
  pPVar1 = (PL *)LpReAlloc(lppl,(lppl->flags1 & 0xffU) * cAlloc + 4,(uint)lppl->flags1 >> 9 & 7);
  *(undefined *)((int)pPVar1 + 2) = (char)cAlloc;
  return pPVar1;
}



// ======================================================================
// Function: LpthFromId
// Address: 1038:01b2
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: MarkPlanet
// Address: 1070:8adc
// ======================================================================


void __cdecl16far IO::MarkPlanet(PLANET *lppl,short iPlr,ushort det)

{
  int *piVar1;
  uint *puVar2;
  undefined2 uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  undefined2 uVar7;
  SHDEF *lpshdef;
  
  uVar7 = (undefined2)((ulong)lppl >> 0x10);
  iVar5 = (int)lppl;
  if ((*(uint *)(iVar5 + 4) >> 8 & 1) == 0) {
    *(uint *)(iVar5 + 4) = *(uint *)(iVar5 + 4) & 0xfeff | 0x100;
    *(uint *)(iVar5 + 4) = *(uint *)(iVar5 + 4) & 0xff00;
    piVar1 = (int *)((int)&DAT_1120_59a4 + iPlr * 0xc0);
    *piVar1 = *piVar1 + 1;
  }
  if ((*(uint *)(iVar5 + 4) & 0xff) < det) {
    *(uint *)(iVar5 + 4) = *(uint *)(iVar5 + 4) & 0xff00 | det & 0xff;
  }
  if ((*(int *)(iVar5 + 2) != -1) &&
     ((*(uint *)(*(int *)(iVar5 + 2) * 0xc0 + 0x59a8) >> 8 & 1) == 0)) {
    *(uint *)(*(int *)(iVar5 + 2) * 0xc0 + 0x59a8) =
         *(uint *)(*(int *)(iVar5 + 2) * 0xc0 + 0x59a8) & 0xfeff | 0x100;
    *(uint *)(*(int *)(iVar5 + 2) * 0xc0 + 0x59a8) =
         *(uint *)(*(int *)(iVar5 + 2) * 0xc0 + 0x59a8) & 0xfff8 | 3;
  }
  if (((det != 2) && (*(int *)(iVar5 + 2) != -1)) && ((*(uint *)(iVar5 + 4) >> 9 & 1) != 0)) {
    iVar6 = *(int *)(iVar5 + 2) * 4;
    uVar3 = *(undefined2 *)(iVar6 + 0x14e);
    iVar6 = *(int *)(iVar6 + 0x14c) + (*(uint *)(iVar5 + 0x2c) & 0xf) * 0x93;
    if ((*(uint *)(iVar6 + 0x7b) >> 8 & 1) == 0) {
      *(uint *)(iVar6 + 0x7b) = *(uint *)(iVar6 + 0x7b) & 0xfeff | 0x100;
      *(uint *)(iVar6 + 0x7b) = *(uint *)(iVar6 + 0x7b) & 0xff00;
      iVar4 = *(int *)((int)&DAT_1120_59a6 + *(int *)(iVar5 + 2) * 0xc0);
      puVar2 = (uint *)((int)&DAT_1120_59a6 + *(int *)(iVar5 + 2) * 0xc0);
      *puVar2 = *puVar2 & 0xfff;
      puVar2 = (uint *)((int)&DAT_1120_59a6 + *(int *)(iVar5 + 2) * 0xc0);
      *puVar2 = *puVar2 | iVar4 + 0x1000U & 0xf000;
    }
    if ((*(uint *)(iVar6 + 0x7b) & 0xff) < 3) {
      *(uint *)(iVar6 + 0x7b) = *(uint *)(iVar6 + 0x7b) & 0xff00 | 3;
    }
  }
  return;
}



// ======================================================================
// Function: MarkPlanetsPlayerLost
// Address: 1030:93c6
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far MSG::MarkPlanetsPlayerLost(short iPlayer)

{
  uint uVar1;
  uint uVar2;
  undefined2 uVar3;
  PLANET *lppl_00;
  byte *lpb;
  ushort w;
  byte *lpbT;
  PLANET *lppl;
  byte *lpbMax;
  
  lpb = (byte *)CONCAT22(_DATA::lpMsg._2_2_,(int)_DATA::lpMsg);
  uVar2 = (int)_DATA::lpMsg + _DATA::imemMsgCur;
  do {
    if (uVar2 <= (uint)lpb) {
      return;
    }
    uVar3 = (undefined2)((ulong)lpb >> 0x10);
    if ((*lpb & 0xf) == iPlayer) {
      uVar1 = *(uint *)((uint)lpb + 1) & 0x1ff;
      if (((uVar1 == 7) || (uVar1 == 0x23)) || (uVar1 == 0x40)) {
        w = *(ushort *)((uint)lpb + 3);
      }
      else {
        if (uVar1 != 0x8f) goto LAB_1030_95d5;
        uVar1 = *(uint *)((uint)lpb + 1) >> 9;
        lpbT = (byte *)CONCAT22(uVar3,(uint)lpb + 6 + (uint)((uVar1 & 1) == 1));
        if ((uVar1 & 2) == 0) {
          w = (ushort)*lpbT;
        }
        else {
          w = *(ushort *)lpbT;
        }
      }
      lppl_00 = UTIL::LpplFromId(w);
      if (lppl_00 != (PLANET *)0x0) {
        IO::MarkPlanet(lppl_00,iPlayer,3);
      }
    }
LAB_1030_95d5:
    lpb = (byte *)CONCAT22(uVar3,(uint)lpb + ((int)(uint)*lpb >> 4) + 5);
  } while( true );
}



// ======================================================================
// Function: MarkPlayersThatSentMsgs
// Address: 1030:9604
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far MSG::MarkPlayersThatSentMsgs(short iPlayer)

{
  MSGPLR *lpmp;
  
  if (iPlayer != -1) {
    lpmp = (MSGPLR *)CONCAT22(_DATA::vlpmsgplrOut._2_2_,_DATA::vlpmsgplrOut._0_2_);
    while( true ) {
      if (((int)lpmp == 0) && (lpmp._2_2_ == 0)) break;
      if (((*(int *)((int)lpmp + 6) == 0) && (*(int *)((int)lpmp + 4) != iPlayer)) ||
         ((*(int *)((int)lpmp + 6) + -1 == iPlayer &&
          ((*(uint *)(*(int *)((int)lpmp + 4) * 0xc0 + 0x59a8) >> 8 & 1) == 0)))) {
        *(uint *)(*(int *)((int)lpmp + 4) * 0xc0 + 0x59a8) =
             *(uint *)(*(int *)((int)lpmp + 4) * 0xc0 + 0x59a8) & 0xfeff | 0x100;
        *(uint *)(*(int *)((int)lpmp + 4) * 0xc0 + 0x59a8) =
             *(uint *)(*(int *)((int)lpmp + 4) * 0xc0 + 0x59a8) & 0xfff8 | 3;
      }
      lpmp = (MSGPLR *)CONCAT22(*(undefined2 *)((int)lpmp + 2),*(undefined2 *)&lpmp->lpmsgplrNext);
    }
  }
  return;
}



// ======================================================================
// Function: OutputSz
// Address: 1038:7fe6
// ======================================================================


void __cdecl16far UTIL::OutputSz(short dt,char *sz)

{
  int iVar1;
  char *pcVar2;
  undefined2 uVar3;
  char szTemp;
  char szDate;
  char szFile;
  char szTime;
  
  uVar3 = 0x1120;
  _WSPRINTF();
  pcVar2 = &szFile;
  iVar1 = PUBLIC::__access(0x14f8,pcVar2,0,uVar3);
  if (iVar1 == -1) {
    MAIN::SzVersion();
    pcVar2 = (char *)0x1120;
    _WSPRINTF(0x1018,&szTemp);
    UTILGEN::OutputFileString(&szFile,&szTemp);
  }
  PUBLIC::__strdate(&szDate,pcVar2);
  PUBLIC::__strtime(&szTime);
  _WSPRINTF(0x1118,&szTemp);
  UTILGEN::OutputFileString(&szFile,&szTemp);
  return;
}



// ======================================================================
// Function: PackageUpMsg
// Address: 1030:802a
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

short __cdecl16far
MSG::PackageUpMsg(byte *pb,short iPlr,short iMsg,short iObj,short p1,short p2,short p3,short p4,
                 short p5,short p6,short p7)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  short sVar4;
  byte *lpbBase;
  byte *lpb;
  MSGTURN *lpmt;
  ushort grbit;
  short i;
  short *pi;
  
  if (iPlr == -1) {
    sVar4 = 0;
  }
  else if (((((*(uint *)(iPlr * 0xc0 + 0x59a8) >> 9 & 1) == 0) ||
            (*(uint *)(iPlr * 0xc0 + 0x59a8) >> 0xd == 7)) || (iMsg == 0x8f)) ||
          (((iMsg == 7 || (iMsg == 0x23)) || (iMsg == 0x40)))) {
    if (_DATA::imemMsgCur + 0x14U < 0xffc9) {
      lpmt = (MSGTURN *)CONCAT22(0x1120,pb);
      lpmt->flags1 = lpmt->flags1 & 0xf0 | (byte)iPlr & 0xf;
      *(uint *)(pb + 1) = *(uint *)(pb + 1) & 0xfe00 | iMsg & 0x1ffU;
      *(uint *)(pb + 1) = *(uint *)(pb + 1) & 0x1ff;
      *(short *)(pb + 3) = iObj;
      lpb = (byte *)CONCAT22(0x1120,pb + 5);
      grbit = 1;
      pi = &p1;
      for (i = 0; i < *(char *)(iMsg + 0x5b0e); i = i + 1) {
        if ((*pi & 0xff00U) == 0) {
          *lpb = (byte)*pi;
          iVar3 = (int)lpb + 1;
        }
        else {
          uVar2 = *(uint *)(pb + 1);
          puVar1 = (uint *)(pb + 1);
          *puVar1 = *puVar1 & 0x1ff;
          puVar1 = (uint *)(pb + 1);
          *puVar1 = *puVar1 | grbit << 9 | uVar2 & 0xfe00;
          *(short *)lpb = *pi;
          iVar3 = (int)lpb + 2;
        }
        lpb = (byte *)CONCAT22(lpb._2_2_,iVar3);
        pi = pi + 1;
        grbit = grbit << 1;
      }
      lpmt->flags1 = lpmt->flags1 & 0xf | (byte)(((byte)((char)lpb - (char)(pb + 5)) & 0xf) << 4);
      sVar4 = (int)lpb - (int)pb;
    }
    else {
      sVar4 = -1;
    }
  }
  else {
    sVar4 = 0;
  }
  return sVar4;
}



// ======================================================================
// Function: PszFormatIds
// Address: 1030:924c
// ======================================================================


char * __cdecl16far MSG::PszFormatIds(short ids,short *pParams)

{
  char *pcVar1;
  
  pcVar1 = STRINGS::PszGetCompressedString(ids);
  pcVar1 = PszFormatString(pcVar1,pParams);
  return pcVar1;
}



// ======================================================================
// Function: PszFormatString
// Address: 1030:85cc
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: PszGetCompressedString
// Address: 1010:743a
// ======================================================================


/* WARNING: Variable defined which should be unmapped: pch */
/* WARNING: Could not reconcile some variable overlaps */

char * __cdecl16far STRINGS::PszGetCompressedString(short ids)

{
  int iVar1;
  byte *pbVar2;
  undefined2 unaff_CS;
  bool bVar3;
  short fHigh;
  short iOffset;
  char *pszOut;
  byte *pch;
  short iLen;
  short i;
  short iNibble;
  short iBuild;
  byte *pchLen;
  short iChunk;
  
  iNibble = 0;
  if (ids != _DATA::iLastStrGet) {
    pchLen = (byte *)CONCAT22(0x1010,(ids >> 6) * 0x40 + 0x6e32);
    for (i = 0; i < (int)(ids & 0x3fU); i = i + 1) {
      iNibble = iNibble + (uint)*pchLen;
      pchLen = (byte *)CONCAT22(pchLen._2_2_,(int)pchLen + 1);
    }
    pch = (byte *)CONCAT22(unaff_CS,*(int *)((ids >> 6) * 2 + 0x73b8) + (iNibble >> 1));
    bVar3 = (iNibble & 1U) == 0;
    pszOut = (char *)&c_common::szLastStrGet;
    iBuild = 0;
    iLen = (uint)*pchLen;
    while (pbVar2 = pch, iVar1 = iLen + -1, iLen != 0) {
      if (bVar3) {
        i = (int)(uint)*pch >> 4;
      }
      else {
        pch = (byte *)CONCAT22(pch._2_2_,(int)pch + 1);
        i = *pbVar2 & 0xf;
      }
      bVar3 = !bVar3;
      iBuild = iBuild + i;
      iLen = iVar1;
      if (i != 0xf) {
        *pszOut = *(char *)(iBuild + 0x73e6);
        pszOut = pszOut + 1;
        iBuild = 0;
      }
    }
    *pszOut = '\0';
  }
  return (char *)&c_common::szLastStrGet;
}



// ======================================================================
// Function: RgToStream
// Address: 1070:9554
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void __cdecl16far IO::RgToStream(void *rg,ushort cb)

{
  ushort uVar1;
  char *sz;
  undefined2 unaff_CS;
  short mbType;
  
  if ((cb != 0) && (uVar1 = _LWRITE(unaff_CS,cb,rg), uVar1 != cb)) {
    mbType = 0x10;
    sz = MSG::PszFormatIds(0x16,(short *)0x0);
    UTILGEN::AlertSz(sz,mbType);
    PUBLIC::_longjmp();
  }
  return;
}



// ======================================================================
// Function: ScanToPt
// Address: 1058:0fc2
// ======================================================================


short __cdecl16far SCAN::ScanToPt(short d)

{
  if (_DATA::iScanZoom != 0) {
    switch(_DATA::iScanZoom) {
    case 1:
      d = (d << 2) / 5;
      break;
    case 2:
      d = (d << 1) / 3;
      break;
    case 3:
      d = d >> 1;
      break;
    case 4:
      d = d >> 2;
      break;
    case -4:
      d = d << 2;
      break;
    case -3:
      d = (d << 3) / 3;
      break;
    case -2:
      d = d << 1;
      break;
    case -1:
      d = (d << 2) / 3;
    }
  }
  return d;
}



// ======================================================================
// Function: SetFileXorStream
// Address: 1040:1aa6
// ======================================================================


void __cdecl16far
UTILGEN::SetFileXorStream(long lid,short lSalt,short turn,short iPlayer,short fCrippled)

{
  short b;
  short a;
  
  a = lSalt & 0x1f;
  b = lSalt >> 5 & 0x1f;
  if ((lSalt & 0x400U) == 0) {
    b = b + 0x20;
  }
  else {
    a = a + 0x20;
  }
  _BSS::lFileSeed1._0_2_ = *(int *)((int)_DATA::vrptFleet.rgbdx + 6 + a * 2);
  _BSS::lFileSeed1._2_2_ = (int)_BSS::lFileSeed1 >> 0xf;
  _BSS::lFileSeed2._0_2_ = *(int *)((int)_DATA::vrptFleet.rgbdx + 6 + b * 2);
  _BSS::lFileSeed2._2_2_ = (int)_BSS::lFileSeed2 >> 0xf;
  a = (((uint)lid & 3) + 1) * ((turn & 3U) + 1) * ((iPlayer & 3U) + 1) + fCrippled;
  while (0 < a) {
    LGetNextFileXor();
    a = a + -1;
  }
  return;
}



// ======================================================================
// Function: SetSzWorkFromDt
// Address: 1070:8cfe
// ======================================================================


void __cdecl16far IO::SetSzWorkFromDt(ushort dt,short iPlayer)

{
  undefined *puVar1;
  undefined *puVar2;
  int iVar3;
  undefined2 uVar4;
  char *pchDot;
  short c;
  char *pchSlash;
  
  puVar1 = (undefined *)PUBLIC::_strrchr((int)&c_common::szBase,0x2e);
  if ((puVar1 != (undefined *)0x0) &&
     ((puVar2 = (undefined *)PUBLIC::_strrchr((int)&c_common::szBase,0x5c),
      puVar2 == (undefined *)0x0 || (puVar2 < puVar1)))) {
    *puVar1 = 0;
  }
  iVar3 = _WSPRINTF(0x1118,(int)&c_common::szWork,0x1120,0xa0c,0x1120,(int)&c_common::szBase,0x1120)
  ;
  if (dt == 0) {
LAB_1070_8d76:
    PUBLIC::_strcat((int)&c_common::szWork,0xa10);
  }
  else {
    if (dt != 1) {
      if (dt == 2) {
        PUBLIC::_strcat((int)&c_common::szWork,0xa13);
        return;
      }
      if ((dt != 3) && (dt != 4)) goto LAB_1070_8d76;
    }
    if (dt == 1) {
      uVar4 = 0x78;
    }
    else if (dt == 4) {
      uVar4 = 0x68;
    }
    else {
      uVar4 = 0x6d;
    }
    _WSPRINTF(0x14f8,(int)&c_common::szWork + iVar3,0x1120,0xa17,0x1120,uVar4,iPlayer + 1);
  }
  return;
}



// ======================================================================
// Function: SetVisPFFinish
// Address: 1070:c41c
// ======================================================================


void __cdecl16far IO::SetVisPFFinish(short iPlr)

{
  char *pcVar1;
  uint *puVar2;
  int iVar3;
  short sVar4;
  uint uVar5;
  short i;
  short j;
  short detMajor;
  
  sVar4 = RACE::GetRaceStat((PLAYER *)((int)&c_common::rgplr + iPlr * 0xc0),0xe);
  if (sVar4 == 2) {
    uVar5 = 7;
  }
  else {
    uVar5 = 3;
  }
  i = 0;
  do {
    if (_DATA::game.cPlayer <= i) {
      return;
    }
    if (i != iPlr) {
      *(undefined *)((int)&DAT_1120_59a3 + i * 0xc0) = 0;
      for (j = 0; j < 0x10; j = j + 1) {
        if ((1 << ((byte)iPlr & 0x1f) & *(uint *)(*(int *)(i * 4 + 0xfe) + j * 0x93 + 0x8b)) == 0) {
          if ((*(uint *)(*(int *)(i * 4 + 0xfe) + j * 0x93 + 0x7b) >> 8 & 1) != 0) {
            *(uint *)(*(int *)(i * 4 + 0xfe) + j * 0x93 + 0x7b) =
                 *(uint *)(*(int *)(i * 4 + 0xfe) + j * 0x93 + 0x7b) & 0xff00 | uVar5;
            goto IO_LFinShdef;
          }
        }
        else {
          *(uint *)(*(int *)(i * 4 + 0xfe) + j * 0x93 + 0x7b) =
               *(uint *)(*(int *)(i * 4 + 0xfe) + j * 0x93 + 0x7b) & 0xfeff | 0x100;
          *(uint *)(*(int *)(i * 4 + 0xfe) + j * 0x93 + 0x7b) =
               *(uint *)(*(int *)(i * 4 + 0xfe) + j * 0x93 + 0x7b) & 0xff00 | 7;
IO_LFinShdef:
          *(uint *)(i * 0xc0 + 0x59a8) = *(uint *)(i * 0xc0 + 0x59a8) & 0xfff8 | 3;
          *(uint *)(i * 0xc0 + 0x59a8) = *(uint *)(i * 0xc0 + 0x59a8) & 0xfeff | 0x100;
          pcVar1 = (char *)((int)&DAT_1120_59a3 + i * 0xc0);
          *pcVar1 = *pcVar1 + '\x01';
        }
      }
      *(uint *)((int)&DAT_1120_59a6 + i * 0xc0) = *(uint *)((int)&DAT_1120_59a6 + i * 0xc0) & 0xfff;
      for (j = 0; j < 10; j = j + 1) {
        if ((1 << ((byte)iPlr & 0x1f) & *(uint *)(*(int *)(i * 4 + 0x14c) + j * 0x93 + 0x8b)) == 0)
        {
          if ((*(uint *)(*(int *)(i * 4 + 0x14c) + j * 0x93 + 0x7b) >> 8 & 1) != 0) {
            *(uint *)(*(int *)(i * 4 + 0x14c) + j * 0x93 + 0x7b) =
                 *(uint *)(*(int *)(i * 4 + 0x14c) + j * 0x93 + 0x7b) & 0xff00 | uVar5;
            goto IO_LFinShdefSB;
          }
        }
        else {
          *(uint *)(*(int *)(i * 4 + 0x14c) + j * 0x93 + 0x7b) =
               *(uint *)(*(int *)(i * 4 + 0x14c) + j * 0x93 + 0x7b) & 0xfeff | 0x100;
          *(uint *)(*(int *)(i * 4 + 0x14c) + j * 0x93 + 0x7b) =
               *(uint *)(*(int *)(i * 4 + 0x14c) + j * 0x93 + 0x7b) & 0xff00 | 7;
IO_LFinShdefSB:
          *(uint *)(i * 0xc0 + 0x59a8) = *(uint *)(i * 0xc0 + 0x59a8) & 0xfeff | 0x100;
          *(uint *)(i * 0xc0 + 0x59a8) = *(uint *)(i * 0xc0 + 0x59a8) & 0xfff8 | 3;
          iVar3 = *(int *)((int)&DAT_1120_59a6 + i * 0xc0);
          puVar2 = (uint *)((int)&DAT_1120_59a6 + i * 0xc0);
          *puVar2 = *puVar2 & 0xfff;
          puVar2 = (uint *)((int)&DAT_1120_59a6 + i * 0xc0);
          *puVar2 = *puVar2 | iVar3 + 0x1000U & 0xf000;
        }
      }
    }
    i = i + 1;
  } while( true );
}



// ======================================================================
// Function: SetVisPFFleets
// Address: 1070:a100
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: SetVisPFInit
// Address: 1070:9654
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: SetVisPFPlanets
// Address: 1070:abde
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: SetVisPFThings
// Address: 1070:b9ee
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: SetVisiblePlanFleet
// Address: 1070:95bc
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: StreamClose
// Address: 1070:53cc
// ======================================================================


void __cdecl16far IO::StreamClose(void)

{
  if (_DATA::hf != -1) {
    _LCLOSE();
    _DATA::hf = -1;
  }
  return;
}



// ======================================================================
// Function: StreamOpen
// Address: 1070:52ae
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x1070536a) */
/* WARNING: Removing unreachable block (ram,0x10705391) */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void __cdecl16far IO::StreamOpen(char *szFile,short mdOpen)

{
  ulong uVar1;
  undefined2 unaff_CS;
  undefined2 unaff_SS;
  ulong uVar2;
  ulong uVar3;
  undefined2 uVar4;
  ulong dwTickCur;
  short fNoErr;
  OFSTRUCT of;
  ulong dwTick;
  
  uVar1 = 0;
  while( true ) {
    uVar4 = 0x1120;
    _DATA::hf = OPENFILE(unaff_CS,mdOpen & 0xbfff,&of,unaff_SS,szFile);
    if (_DATA::hf != -1) {
      return;
    }
    if ((((uint)_DATA::gd.flags1 >> 9 & 1) == 0) || (of.nErrCode == 2)) break;
    uVar2 = GETTICKCOUNT(0x14f8,uVar4);
    if (uVar1 == 0) {
      uVar1 = uVar2 + 4000;
    }
    if (uVar1 <= uVar2) break;
    do {
      unaff_CS = 0x14f8;
      uVar3 = GETTICKCOUNT(0x14f8,uVar4);
    } while (uVar3 < uVar2 + 500);
  }
  if ((mdOpen & 0x4000U) == 0) {
    FileError(4);
  }
  PUBLIC::_longjmp(_penvMem,0xffff);
  return;
}



// ======================================================================
// Function: UpdateProgressGauge
// Address: 1040:63da
// ======================================================================


void __cdecl16far UTILGEN::UpdateProgressGauge(short pctX10)

{
  short iNum;
  
  if (_DATA::hwndProgressGauge != 0) {
    iNum = 0;
    if (pctX10 == -0x39e) {
      pctX10 = c_common::vpctProgressGauge + 4;
    }
    else if (pctX10 == -0x39f) {
      pctX10 = c_common::vpctProgressGauge + 1;
    }
    else if (pctX10 < 0) {
      pctX10 = 0;
    }
    else if (1000 < pctX10) {
      if (((uint)_DATA::gd.flags2 >> 10 & 1) == 0) {
        return;
      }
      iNum = pctX10;
      pctX10 = c_common::vpctProgressGauge;
    }
    c_common::vpctProgressGauge = pctX10;
    DrawProgressGauge(0,0,iNum);
  }
  return;
}



// ======================================================================
// Function: WriteBOF
// Address: 1070:8ea4
// ======================================================================


void __cdecl16far IO::WriteBOF(short iPlayer,short dt,short fMulti)

{
  short sVar1;
  int iVar2;
  undefined2 unaff_SS;
  RTBOF rtbof;
  
  PUBLIC::_memset(&rtbof,0);
  PUBLIC::_strncpy(&rtbof,0xa1c);
  rtbof.lidGame._0_2_ = (undefined2)_DATA::game.lid;
  rtbof.lidGame._2_2_ = _DATA::game.lid._2_2_;
  rtbof.wVersion = 0x2a60;
  rtbof.turn = _DATA::game.turn;
  rtbof.flags8 = rtbof.flags8 & 0xfffU | ((uint)_DATA::game.wCrap >> 9) << 0xd;
  rtbof.flags7 = rtbof.flags7 & 0xffe0U | iPlayer & 0x1fU;
  sVar1 = UTILGEN::Random(2000);
  iVar2 = GETTICKCOUNT();
  rtbof.flags7 = rtbof.flags7 & 0x1fU | (iVar2 + sVar1) * 0x20;
  if ((dt == 2) && ((_DATA::gd.flags2 & 1U) != 0)) {
    iVar2 = 1;
  }
  else {
    iVar2 = 0;
  }
  rtbof.flags8 = rtbof.flags8 & 0xf400U | dt & 0xffU | ((uint)_DATA::gd.flags1 >> 4 & 1) << 8 |
                 ((uint)_DATA::gd.flags1 >> 3 & 1) << 9 | iVar2 << 0xb;
  WriteRt(8,0x10,(void *)CONCAT22(unaff_SS,&rtbof));
  return;
}



// ======================================================================
// Function: WriteBattlePlan
// Address: 1070:89b8
// ======================================================================


void __cdecl16far IO::WriteBattlePlan(BTLPLAN *lpbtlplan,short fLog)

{
  short sVar1;
  int iVar2;
  undefined2 unaff_SS;
  short cOut;
  char szPlanName;
  byte *pb;
  byte rgb;
  byte local_26 [2];
  byte local_24 [34];
  
  PUBLIC::__fmemmove(&rgb);
  if (((uint)lpbtlplan->flags1 >> 0xe & 1) == 0) {
    pb = local_24;
    PUBLIC::__fstrcpy();
    cOut = 0x1f;
    if ((szPlanName == '\0') ||
       (sVar1 = UTILGEN::FCompressUserString
                          ((char *)CONCAT22(unaff_SS,&szPlanName),(char *)CONCAT22(0x1120,pb + 1),
                           &cOut), sVar1 == 0)) {
      PUBLIC::_strcpy(pb + 1,&szPlanName);
      *pb = 0;
      iVar2 = PUBLIC::_strlen(&szPlanName);
      pb = pb + iVar2 + 2;
    }
    else {
      *pb = (byte)cOut;
      pb = pb + cOut + 1;
    }
  }
  else {
    pb = local_26;
  }
  if (fLog == 0) {
    WriteRt(0x1e,(int)pb - (int)&rgb,(void *)CONCAT22(unaff_SS,&rgb));
  }
  else {
    PLANET::WriteMemRt(0x1e,(int)pb - (int)&rgb,&rgb);
  }
  return;
}



// ======================================================================
// Function: WriteBattles
// Address: 1070:709c
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far IO::WriteBattles(short iPlayer)

{
  char *pcVar1;
  uint *puVar2;
  uint uVar3;
  int iVar4;
  undefined2 uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined2 uVar9;
  FLEET *pFVar10;
  PLANET *lppl_00;
  short iplr;
  short cb;
  BTLDATA *lpbtldata;
  HB *lphb;
  byte *lpbBattle;
  BTLREC *lpbtlrec;
  ushort fPlayerCur;
  short cbT;
  FLEET *lpfl;
  short i;
  PLANET *lppl;
  short cbRec;
  short ctok;
  
  if ((iPlayer != -1) &&
     (((int)_DATA::lpbBattleLog != (int)_DATA::lpbBattleCur ||
      (_DATA::lpbBattleLog._2_2_ != _DATA::lpbBattleCur._2_2_)))) {
    lphb = (HB *)CONCAT22(DAT_1120_0d62,DAT_1120_0d60);
    lpbBattle._0_2_ = DAT_1120_0d60 + 0x12;
    lpbBattle._2_2_ = DAT_1120_0d62;
    while (((int)lphb != 0 || (lphb._2_2_ != 0))) {
      lpbtldata = (BTLDATA *)CONCAT22(lpbBattle._2_2_,(int)lpbBattle);
      while( true ) {
        uVar9 = (undefined2)((ulong)lphb >> 0x10);
        iVar6 = (int)lphb;
        if ((0x10 < *(uint *)(iVar6 + 6)) && (lpbtldata->id != -1)) break;
        iVar4 = *(int *)(iVar6 + 8);
        lpbBattle._2_2_ = *(int *)(iVar6 + 10);
        lphb = (HB *)CONCAT22(lpbBattle._2_2_,iVar4);
        if ((iVar4 == 0) && (lpbBattle._2_2_ == 0)) {
          return;
        }
        lpbBattle._0_2_ = iVar4 + 0x12;
        lpbtldata = (BTLDATA *)CONCAT22(lpbBattle._2_2_,(int)lpbBattle);
      }
      uVar9 = (undefined2)((ulong)lpbtldata >> 0x10);
      iVar6 = (int)lpbtldata;
      if ((*(uint *)(iVar6 + 4) & 1 << ((byte)iPlayer & 0x1f)) == 0) {
        lpbBattle._0_2_ = (int)lpbBattle + *(int *)(iVar6 + 6);
      }
      else {
        for (i = 0; i < _DATA::game.cPlayer; i = i + 1) {
          if (((i != iPlayer) && ((*(uint *)(i * 0xc0 + 0x59a8) >> 8 & 1) == 0)) &&
             ((1 << ((byte)i & 0x1f) & *(uint *)(iVar6 + 4)) != 0)) {
            *(uint *)(i * 0xc0 + 0x59a8) = *(uint *)(i * 0xc0 + 0x59a8) & 0xfeff | 0x100;
            *(uint *)(i * 0xc0 + 0x59a8) = *(uint *)(i * 0xc0 + 0x59a8) & 0xfff8 | 3;
          }
        }
        for (i = 0; i < (int)(uint)*(byte *)(iVar6 + 3); i = i + 1) {
          if ((uint)*(byte *)(iVar6 + i * 0x1d + 0x10) != iPlayer) {
            if (*(char *)(iVar6 + i * 0x1d + 0x11) == '\x01') {
              uVar3 = (uint)*(byte *)(iVar6 + i * 0x1d + 0x10);
              UTIL::LpplFromId(*(short *)(iVar6 + 0xe + i * 0x1d));
              if ((*(uint *)(*(int *)(uVar3 * 4 + 0x14c) +
                             (*(byte *)(iVar6 + i * 0x1d + 0x12) - 0x10) * 0x93 + 0x7b) >> 8 & 1) ==
                  0) {
                *(uint *)(*(int *)(uVar3 * 4 + 0x14c) +
                          (*(byte *)(iVar6 + i * 0x1d + 0x12) - 0x10) * 0x93 + 0x7b) =
                     *(uint *)(*(int *)(uVar3 * 4 + 0x14c) +
                               (*(byte *)(iVar6 + i * 0x1d + 0x12) - 0x10) * 0x93 + 0x7b) & 0xfeff |
                     0x100;
                iVar4 = *(int *)((int)&DAT_1120_59a6 + uVar3 * 0xc0);
                puVar2 = (uint *)((int)&DAT_1120_59a6 + uVar3 * 0xc0);
                *puVar2 = *puVar2 & 0xfff;
                puVar2 = (uint *)((int)&DAT_1120_59a6 + uVar3 * 0xc0);
                *puVar2 = *puVar2 | iVar4 + 0x1000U & 0xf000;
              }
              *(uint *)(*(int *)(uVar3 * 4 + 0x14c) +
                        (*(byte *)(iVar6 + i * 0x1d + 0x12) - 0x10) * 0x93 + 0x7b) =
                   *(uint *)(*(int *)(uVar3 * 4 + 0x14c) +
                             (*(byte *)(iVar6 + i * 0x1d + 0x12) - 0x10) * 0x93 + 0x7b) & 0xff00 | 7
              ;
            }
            else {
              pFVar10 = UTIL::LpflFromId(*(short *)(iVar6 + 0xe + i * 0x1d));
              uVar5 = (undefined2)((ulong)pFVar10 >> 0x10);
              iVar4 = (int)pFVar10;
              if ((*(int *)(iVar4 + 2) != iPlayer) &&
                 ((*(uint *)(*(int *)(iVar4 + 2) * 0xc0 + 0x59a8) >> 8 & 1) == 0)) {
                *(uint *)(*(int *)(iVar4 + 2) * 0xc0 + 0x59a8) =
                     *(uint *)(*(int *)(iVar4 + 2) * 0xc0 + 0x59a8) & 0xfeff | 0x100;
                *(uint *)(*(int *)(iVar4 + 2) * 0xc0 + 0x59a8) =
                     *(uint *)(*(int *)(iVar4 + 2) * 0xc0 + 0x59a8) & 0xfff8 | 3;
              }
              iVar7 = *(int *)(iVar4 + 2) * 4;
              if ((*(uint *)(*(int *)(iVar7 + 0xfe) +
                             (uint)*(byte *)(iVar6 + i * 0x1d + 0x12) * 0x93 + 0x7b) >> 8 & 1) == 0)
              {
                iVar7 = *(int *)(iVar4 + 2) * 4;
                iVar8 = *(int *)(iVar4 + 2) * 4;
                *(uint *)(*(int *)(iVar8 + 0xfe) + (uint)*(byte *)(iVar6 + i * 0x1d + 0x12) * 0x93 +
                         0x7b) =
                     *(uint *)(*(int *)(iVar7 + 0xfe) +
                               (uint)*(byte *)(iVar6 + i * 0x1d + 0x12) * 0x93 + 0x7b) & 0xfeff |
                     0x100;
                pcVar1 = (char *)((int)&DAT_1120_59a3 + *(int *)(iVar4 + 2) * 0xc0);
                *pcVar1 = *pcVar1 + '\x01';
              }
              iVar7 = *(int *)(iVar4 + 2) * 4;
              iVar8 = *(int *)(iVar4 + 2) * 4;
              *(uint *)(*(int *)(iVar8 + 0xfe) + (uint)*(byte *)(iVar6 + i * 0x1d + 0x12) * 0x93 +
                       0x7b) =
                   *(uint *)(*(int *)(iVar7 + 0xfe) +
                             (uint)*(byte *)(iVar6 + i * 0x1d + 0x12) * 0x93 + 0x7b) & 0xff00 | 7;
              if ((*(uint *)(iVar4 + 4) >> 10 & 1) == 0) {
                if ((*(uint *)(iVar4 + 4) >> 8 & 1) == 0) {
                  iVar7 = *(int *)((int)&DAT_1120_59a6 + *(int *)(iVar4 + 2) * 0xc0);
                  puVar2 = (uint *)((int)&DAT_1120_59a6 + *(int *)(iVar4 + 2) * 0xc0);
                  *puVar2 = *puVar2 & 0xf000;
                  puVar2 = (uint *)((int)&DAT_1120_59a6 + *(int *)(iVar4 + 2) * 0xc0);
                  *puVar2 = *puVar2 | iVar7 + 1U & 0xfff;
                  *(uint *)(iVar4 + 4) = *(uint *)(iVar4 + 4) & 0xfeff | 0x100;
                  *(uint *)(iVar4 + 4) = *(uint *)(iVar4 + 4) & 0xff00;
                }
                if ((*(uint *)(iVar4 + 4) & 0xff) < 3) {
                  *(uint *)(iVar4 + 4) = *(uint *)(iVar4 + 4) & 0xff00 | 3;
                }
              }
            }
          }
        }
        if (*(int *)(iVar6 + 8) != -1) {
          lppl_00 = UTIL::LpplFromId(*(short *)(iVar6 + 8));
          MarkPlanet(lppl_00,iPlayer,1);
        }
        if (*(uint *)(iVar6 + 6) < 0x400) {
          WriteRt(0x1f,*(short *)(iVar6 + 6),(void *)CONCAT22(lpbBattle._2_2_,(int)lpbBattle));
          lpbBattle._0_2_ = (int)lpbBattle + *(int *)(iVar6 + 6);
        }
        else {
          uVar3 = (uint)*(byte *)(iVar6 + 3) * 0x1d + 0xe;
          iVar4 = (int)lpbBattle + uVar3;
          lpbtlrec = (BTLREC *)CONCAT22(lpbBattle._2_2_,iVar4);
          if (uVar3 < 0x400) {
            WriteRt(0x1f,uVar3,(void *)CONCAT22(lpbBattle._2_2_,(int)lpbBattle));
            lpbBattle._0_2_ = (int)lpbBattle + uVar3;
          }
          else {
            if (*(byte *)(iVar6 + 3) < 0x23) {
              ctok = (short)*(byte *)(iVar6 + 3);
            }
            else {
              ctok = 0x22;
            }
            if ((uint)*(byte *)(iVar6 + 3) < (uint)ctok) {
              ctok = (short)*(byte *)(iVar6 + 3);
            }
            WriteRt(0x1f,ctok * 0x1d + 0xe,(void *)CONCAT22(lpbBattle._2_2_,(int)lpbBattle));
            lpbBattle._0_2_ = (int)lpbBattle + ctok * 0x1d + 0xe;
            ctok = (uint)*(byte *)(iVar6 + 3) - ctok;
            while (0 < ctok) {
              if ((uint)ctok < 0x24) {
                WriteRt(0x27,ctok * 0x1d,(void *)CONCAT22(lpbBattle._2_2_,(int)lpbBattle));
                lpbBattle._0_2_ = (int)lpbBattle + ctok * 0x1d;
                ctok = 0;
              }
              else {
                WriteRt(0x27,0x3f7,(void *)CONCAT22(lpbBattle._2_2_,(int)lpbBattle));
                lpbBattle._0_2_ = (int)lpbBattle + 0x3f7;
                ctok = ctok + -0x23;
              }
            }
          }
          cb = *(int *)(iVar6 + 6) + -0xe + (uint)*(byte *)(iVar6 + 3) * -0x1d;
          if (cb < 0x400) {
            WriteRt(0x27,cb,(void *)CONCAT22(lpbBattle._2_2_,iVar4));
            lpbBattle._0_2_ = (int)lpbBattle + cb;
          }
          else {
            while (cb != 0) {
              cbRec = *(int *)((int)lpbtlrec + 2) * 8 + 6;
              if (cbRec < 0x400) {
                cbT = 0;
                do {
                  cbT = cbT + cbRec;
                  iVar6 = (int)lpbtlrec + cbRec;
                  lpbtlrec = (BTLREC *)CONCAT22(lpbtlrec._2_2_,iVar6);
                  cb = cb - cbRec;
                  if (cb == 0) break;
                  cbRec = *(int *)(iVar6 + 2) * 8 + 6;
                } while (cbT + cbRec < 0x400);
                WriteRt(0x27,cbT,(void *)CONCAT22(lpbBattle._2_2_,(int)lpbBattle));
              }
              else {
                cb = cb - cbRec;
                while( true ) {
                  if (cbRec < 0x400) break;
                  WriteRt(0x27,0x3ff,lpbtlrec);
                  lpbtlrec = (BTLREC *)CONCAT22(lpbtlrec._2_2_,(int)lpbtlrec + 0x3ff);
                  cbRec = cbRec + -0x3ff;
                }
                if (cbRec != 0) {
                  WriteRt(0x27,cbRec,lpbtlrec);
                  lpbtlrec = (BTLREC *)CONCAT22(lpbtlrec._2_2_,(int)lpbtlrec + cbRec);
                }
              }
              lpbBattle._0_2_ = (int)lpbtlrec;
              lpbBattle._2_2_ = lpbtlrec._2_2_;
            }
          }
        }
      }
    }
  }
  return;
}



// ======================================================================
// Function: WriteFleet
// Address: 1070:81c6
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: WriteMemRt
// Address: 1048:a130
// ======================================================================


void __cdecl16far PLANET::WriteMemRt(short rt,short cb,void *rg)

{
  int iVar1;
  undefined2 uVar2;
  char *sz;
  uint uVar3;
  short mbType;
  byte *lpv;
  HDR hdr;
  
  uVar3 = c_common::hdrPrev;
  if (_DATA::fLogOff == 0) {
    if (32000 < _DATA::imemLogCur + cb + 2) {
      mbType = 0x10;
      sz = MSG::PszFormatIds(0x10,(short *)0x0);
      UTILGEN::AlertSz(sz,mbType);
    }
    DirtyGame(1);
    uVar2 = _DATA::lpLog._2_2_;
    _DATA::imemLogPrev = _DATA::imemLogCur;
    uVar3 = cb & 0x3ffU | rt << 10;
    iVar1 = (int)_DATA::lpLog + _DATA::imemLogCur;
    lpv = (byte *)CONCAT22(_DATA::lpLog._2_2_,iVar1);
    *(uint *)lpv = uVar3;
    if (0 < cb) {
      PUBLIC::__fmemcpy(iVar1 + 2,uVar2,rg,0x1120,cb);
    }
    _DATA::imemLogCur = _DATA::imemLogCur + cb + 2;
    if (rt == 0) {
      uVar3 = c_common::hdrPrev;
    }
  }
  c_common::hdrPrev = uVar3;
  return;
}



// ======================================================================
// Function: WriteOrders
// Address: 1070:547e
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: WritePlanet
// Address: 1070:7a6a
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x107080e7) */
/* WARNING: Removing unreachable block (ram,0x1070809d) */
/* WARNING: Removing unreachable block (ram,0x10708074) */
/* WARNING: Removing unreachable block (ram,0x107080c6) */
/* WARNING: Removing unreachable block (ram,0x10708110) */
/* WARNING: Removing unreachable block (ram,0x1070804b) */

void __cdecl16far IO::WritePlanet(PLANET *lppl,short rt,short fHistory)

{
  byte *pbVar1;
  undefined2 uVar2;
  int iVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  int *piVar8;
  uint *puVar9;
  undefined2 *puVar10;
  undefined2 uVar11;
  undefined2 unaff_SS;
  byte *pb;
  short i;
  byte *pbBase;
  byte rgb;
  uint local_54;
  byte local_52;
  byte abStack_51 [75];
  byte bMask;
  
  PUBLIC::_memset(&rgb,0);
  uVar11 = (undefined2)((ulong)lppl >> 0x10);
  iVar7 = (int)lppl;
  _rgb = lppl->id & 0x7ffU | *(int *)(iVar7 + 2) << 0xb;
  uVar5 = local_54 & 0xff80;
  local_54 = uVar5 | *(uint *)(iVar7 + 4) & 0x7f;
  if ((rt == 0xe) && (3 < (*(uint *)(iVar7 + 4) & 0xff))) {
    if (fHistory == 0) {
      local_54 = 4;
    }
    else {
      local_54 = 3;
    }
    local_54 = uVar5 | local_54;
  }
  uVar6 = local_54 & 0x3c7f | (*(uint *)(iVar7 + 4) >> 8 & 1) << 8 |
          (*(uint *)(iVar7 + 4) >> 9 & 1) << 9 | (*(uint *)(iVar7 + 4) >> 10 & 1) << 7 |
          (*(uint *)(iVar7 + 4) >> 0xb) << 0xf |
          (uint)((*(uint *)(iVar7 + 0x30) & 0x3ff) != 0) << 0xe;
  pb = &local_52;
  uVar5 = local_54 & 0x7f;
  local_54 = uVar6;
  if (1 < uVar5) {
    pb = abStack_51;
    bMask = 3;
    for (i = 0; i < 3; i = i + 1) {
      if (*(char *)(iVar7 + 6 + i) != '\0') {
        local_52 = local_52 | bMask & 0x55;
        *pb = *(byte *)(iVar7 + 6 + i);
        pb = pb + 1;
      }
      bMask = bMask << 2;
    }
    for (i = 0; i < 3; i = i + 1) {
      *pb = *(byte *)(iVar7 + 9 + i);
      pb = pb + 1;
    }
    for (i = 0; i < 3; i = i + 1) {
      *pb = *(byte *)(iVar7 + 0xc + i);
      if (*(char *)(iVar7 + 0xc + i) != *(char *)(iVar7 + 0xf + i)) {
        local_54 = local_54 & 0xfbff | 0x400;
      }
      pb = pb + 1;
    }
    if ((local_54 >> 10 & 1) != 0) {
      for (i = 0; i < 3; i = i + 1) {
        *pb = *(byte *)(iVar7 + 0xf + i);
        pb = pb + 1;
      }
    }
    if (*(int *)(iVar7 + 2) != -1) {
      *(undefined2 *)pb = *(undefined2 *)(iVar7 + 0x12);
      pb = pb + 2;
    }
    pbVar4 = pb;
    if (3 < (local_54 & 0x7f)) {
      pb = pb + 1;
      bMask = 3;
      for (i = 0; i < 4; i = i + 1) {
        if ((i != 3) || (6 < (*(uint *)(iVar7 + 4) & 0xff))) {
          piVar8 = (int *)(iVar7 + 0x1c + i * 4);
          iVar3 = piVar8[1];
          if ((-1 < iVar3) && ((0 < iVar3 || (*piVar8 != 0)))) {
            puVar9 = (uint *)(iVar7 + 0x1c + i * 4);
            uVar5 = puVar9[1];
            if (((int)uVar5 < 0) || (((int)uVar5 < 1 && (*puVar9 < 0x100)))) {
              pbVar1 = pbVar4;
              *pbVar1 = *pbVar1 | bMask & 0x55;
              *pb = (byte)*(undefined2 *)(iVar7 + 0x1c + i * 4);
              pb = pb + 1;
            }
            else {
              iVar3 = *(int *)(iVar7 + i * 4 + 0x1e);
              if ((iVar3 < 0) || (iVar3 < 1)) {
                pbVar1 = pbVar4;
                *pbVar1 = *pbVar1 | bMask & 0xaa;
                *(undefined2 *)pb = *(undefined2 *)(iVar7 + 0x1c + i * 4);
                pb = pb + 2;
              }
              else {
                pbVar1 = pbVar4;
                *pbVar1 = *pbVar1 | bMask;
                puVar10 = (undefined2 *)(iVar7 + 0x1c + i * 4);
                uVar2 = puVar10[1];
                *(undefined2 *)pb = *puVar10;
                *(undefined2 *)(pb + 2) = uVar2;
                pb = pb + 4;
              }
            }
          }
        }
        bMask = bMask << 2;
      }
      if (*pbVar4 != 0) {
        local_54 = local_54 & 0xdfff | 0x2000;
        pbVar4 = pb;
      }
      pb = pbVar4;
      if (rt != 0xe) {
        uVar5 = PUBLIC::__aFulshr();
        local_54 = local_54 & 0xefff | (uVar5 & 1) << 0xc;
        if ((((*(int *)(iVar7 + 2) != -1) &&
             (((*(uint *)(iVar7 + 0x14) & 0xff) != 0 ||
              (uVar5 = PUBLIC::__aFulshr(), (uVar5 & 1) != 0)))) ||
            (uVar5 = PUBLIC::__aFulshr(), (uVar5 & 0xfff) != 0)) ||
           (((uVar5 = PUBLIC::__aFulshr(), (uVar5 & 0xfff) != 0 ||
             ((*(uint *)(iVar7 + 0x18) & 0xfff) != 0)) ||
            (uVar5 = PUBLIC::__aFulshr(), (uVar5 & 0x1f) != 0x1f)))) {
          local_54 = local_54 & 0xf7ff | 0x800;
          PUBLIC::__fmemmove(pb,0x1120,iVar7 + 0x14,uVar11);
          pb = pb + 8;
        }
        if (*(int *)(iVar7 + 2) != -1) {
          if ((*(uint *)(iVar7 + 4) >> 9 & 1) != 0) {
            uVar2 = *(undefined2 *)(iVar7 + 0x2e);
            *(undefined2 *)pb = *(undefined2 *)(iVar7 + 0x2c);
            *(undefined2 *)(pb + 2) = uVar2;
            pb = pb + 4;
          }
          if ((*(uint *)(iVar7 + 0x30) & 0x3ff) != 0) {
            *(undefined2 *)pb = *(undefined2 *)(iVar7 + 0x30);
            pb = pb + 2;
          }
        }
        WriteRt(0xd,(int)pb - (int)&rgb,(void *)CONCAT22(unaff_SS,&rgb));
        return;
      }
    }
  }
  if ((*(uint *)(iVar7 + 4) >> 9 & 1) != 0) {
    *pb = (byte)*(undefined2 *)(iVar7 + 0x2c) & 0xf;
    pb = pb + 1;
  }
  if (fHistory != 0) {
    *(undefined2 *)pb = *(undefined2 *)(iVar7 + 0x32);
    pb = pb + 2;
  }
  WriteRt(0xe,(int)pb - (int)&rgb,(void *)CONCAT22(unaff_SS,&rgb));
  return;
}



// ======================================================================
// Function: WritePlayerMessages
// Address: 1030:9702
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far MSG::WritePlayerMessages(short iPlayer)

{
  int iVar1;
  undefined2 uVar2;
  undefined2 unaff_SS;
  MSGPLR *rg;
  byte *lpb;
  MSGPLR *lpmp;
  short cbMsg;
  byte rgb;
  byte *lpbMax;
  
  cbMsg = 0;
  if (iPlayer != -1) {
    lpbMax._0_2_ = (int)_DATA::lpMsg + _DATA::imemMsgCur;
    lpbMax._2_2_ = _DATA::lpMsg._2_2_;
    for (lpb = (byte *)CONCAT22(_DATA::lpMsg._2_2_,(int)_DATA::lpMsg); (uint)lpb < (uint)lpbMax;
        lpb = (byte *)CONCAT22(uVar2,(uint)lpb + ((int)(uint)*lpb >> 4) + 5)) {
      if (0x3ff < cbMsg + 0x14) {
        IO::WriteRt(0xc,cbMsg,(void *)CONCAT22(unaff_SS,&rgb));
        cbMsg = 0;
      }
      uVar2 = (undefined2)((ulong)lpb >> 0x10);
      if (((*lpb & 0xf) == iPlayer) && ((*(uint *)((uint)lpb + 1) & 0x1ff) != 0x1ff)) {
        PUBLIC::__fmemmove(&rgb + cbMsg);
        cbMsg = cbMsg + ((int)(uint)*lpb >> 4) + 4;
      }
    }
    if (cbMsg != 0) {
      IO::WriteRt(0xc,cbMsg,(void *)CONCAT22(unaff_SS,&rgb));
    }
    lpmp = (MSGPLR *)CONCAT22(_DATA::vlpmsgplrOut._2_2_,_DATA::vlpmsgplrOut._0_2_);
    while( true ) {
      if (((int)lpmp == 0) && (lpmp._2_2_ == 0)) break;
      if (((*(int *)((int)lpmp + 6) == 0) && (*(int *)((int)lpmp + 4) != iPlayer)) ||
         (*(int *)((int)lpmp + 6) + -1 == iPlayer)) {
        rg = lpmp;
        iVar1 = PUBLIC::_abs(*(undefined2 *)((int)lpmp + 10));
        IO::WriteRt(0x28,iVar1 + 0xc,rg);
      }
      lpmp = (MSGPLR *)CONCAT22(*(undefined2 *)((int)lpmp + 2),*(undefined2 *)&lpmp->lpmsgplrNext);
    }
  }
  return;
}



// ======================================================================
// Function: WriteRt
// Address: 1070:947c
// ======================================================================


void __cdecl16far IO::WriteRt(short rt,short cb,void *rg)

{
  undefined2 unaff_SS;
  HDR hdr;
  
  PUBLIC::__fmemmove();
  if (rt == 8) {
    UTILGEN::SetFileXorStream
              (CONCAT22(DAT_1120_4b9e,DAT_1120_4b9c),DAT_1120_4ba4 >> 5,DAT_1120_4ba2,
               (DAT_1120_4ba4 << 0xb) >> 0xb,DAT_1120_4ba6 >> 0xc & 1);
  }
  else if (rt != 0) {
    UTILGEN::XorFileBuf((char *)&c_common::rgbCur,cb);
  }
  hdr.flags1 = cb & 0x3ffU | rt << 10;
  RgToStream((void *)CONCAT22(unaff_SS,&hdr),2);
  RgToStream(&c_common::rgbCur,cb);
  return;
}



// ======================================================================
// Function: WriteRtPlr
// Address: 1070:551c
// ======================================================================


void __cdecl16far IO::WriteRtPlr(PLAYER *pplr,byte *pbStore)

{
  int iVar1;
  short sVar2;
  short cOut;
  byte *pb;
  short i;
  byte rgb;
  
  if (pbStore == (byte *)0x0) {
    pbStore = &rgb;
  }
  if ((pplr->wFlags & 1U) != 0) {
    pplr->wMdPlr = pplr->wMdPlr & 0xfff8U | 7;
  }
  PUBLIC::_memmove((char)pbStore,pplr,0xc0);
  if ((pplr->wMdPlr & 7U) == 7) {
    for (i = 0xf; (-1 < i && (pplr->rgmdRelation[i] == '\0')); i = i + -1) {
    }
    i = i + 1;
    pb = pbStore + 0x71;
    pbStore[0x70] = (byte)i;
    PUBLIC::_memmove((char)pb,pplr->rgmdRelation,i);
    pb = pb + i;
  }
  else {
    pb = pbStore + 8;
  }
  cOut = 0x1f;
  if ((pplr->szName[0] == '\0') ||
     (sVar2 = UTILGEN::FCompressUserString
                        ((char *)CONCAT22(0x1120,pplr->szName),(char *)CONCAT22(0x1120,pb + 1),&cOut
                        ), sVar2 == 0)) {
    PUBLIC::_strcpy(pb + 1,pplr->szName);
    *pb = 0;
    iVar1 = PUBLIC::_strlen(pplr->szName);
    pb = pb + iVar1 + 2;
  }
  else {
    *pb = (byte)cOut;
    pb = pb + cOut + 1;
  }
  cOut = 0x1f;
  if ((pplr->szNames[0] == '\0') ||
     (sVar2 = UTILGEN::FCompressUserString
                        ((char *)CONCAT22(0x1120,pplr->szNames),(char *)CONCAT22(0x1120,pb + 1),
                         &cOut), sVar2 == 0)) {
    PUBLIC::_strcpy(pb + 1,pplr->szNames);
    *pb = 0;
    iVar1 = PUBLIC::_strlen(pplr->szNames);
    pb = pb + iVar1 + 2;
  }
  else {
    *pb = (byte)cOut;
    pb = pb + cOut + 1;
  }
  WriteRt(6,(int)pb - (int)pbStore,(void *)CONCAT22(0x1120,pbStore));
  return;
}



// ======================================================================
// Function: WriteRtShDef
// Address: 1070:574e
// ======================================================================


void __cdecl16far IO::WriteRtShDef(SHDEF *lpshdef,byte **ppbStore)

{
  byte **ppbVar1;
  short sVar2;
  int iVar3;
  undefined2 uVar4;
  undefined2 unaff_SS;
  short cOut;
  byte *pb;
  char szHulName;
  byte rgb;
  undefined local_96;
  undefined local_95;
  undefined2 local_94;
  byte local_92;
  undefined2 local_91;
  undefined2 local_8f;
  undefined2 local_8d;
  undefined2 local_8b;
  undefined2 local_89;
  byte local_87 [133];
  
  local_96 = (undefined)(lpshdef->hul).ihuldef;
  uVar4 = (undefined2)((ulong)lpshdef >> 0x10);
  iVar3 = (int)lpshdef;
  _rgb = *(undefined2 *)(iVar3 + 0x7b);
  local_92 = *(byte *)(iVar3 + 0x7a);
  local_95 = (undefined)*(undefined2 *)(iVar3 + 0x32);
  if ((*(uint *)(iVar3 + 0x7b) & 0xff) == 7) {
    local_94 = *(undefined2 *)(iVar3 + 0x38);
    local_91 = *(undefined2 *)(iVar3 + 0x7d);
    local_8f = *(undefined2 *)(iVar3 + 0x7f);
    local_8d = *(undefined2 *)(iVar3 + 0x81);
    local_8b = *(undefined2 *)(iVar3 + 0x83);
    local_89 = *(undefined2 *)(iVar3 + 0x85);
    pb = local_87;
    PUBLIC::__fmemmove(pb,0x1120,(char)(iVar3 + 0x3a),uVar4,(uint)local_92 << 2);
    pb = pb + (uint)local_92 * 4;
  }
  else {
    local_94 = *(undefined2 *)(iVar3 + 0x28);
    pb = &local_92;
  }
  if ((*(uint *)(iVar3 + 0x7b) & 0xff) == 7) {
    PUBLIC::__fstrcpy();
  }
  else {
    PARTS::LphuldefFromId((lpshdef->hul).ihuldef);
    PUBLIC::__fstrcpy();
  }
  cOut = 0x1f;
  if ((szHulName == '\0') ||
     (sVar2 = UTILGEN::FCompressUserString
                        ((char *)CONCAT22(unaff_SS,&szHulName),(char *)CONCAT22(0x1120,pb + 1),&cOut
                        ), sVar2 == 0)) {
    PUBLIC::_strcpy(pb + 1,&szHulName);
    *pb = 0;
    iVar3 = PUBLIC::_strlen(&szHulName);
    pb = pb + iVar3 + 2;
  }
  else {
    *pb = (byte)cOut;
    pb = pb + cOut + 1;
  }
  if (ppbStore == (byte **)0x0) {
    WriteRt(0x1a,(int)pb - (int)&rgb,(void *)CONCAT22(unaff_SS,&rgb));
  }
  else {
    PUBLIC::_memmove((char)*ppbStore,&rgb,(int)pb - (int)&rgb);
    ppbVar1 = ppbStore;
    *ppbVar1 = *ppbVar1 + ((int)pb - (int)&rgb);
  }
  return;
}



// ======================================================================
// Function: WriteRtString
// Address: 1070:87b4
// ======================================================================


void __cdecl16far IO::WriteRtString(char *lpsz)

{
  short sVar1;
  int iVar2;
  undefined2 unaff_SS;
  short cOut;
  byte rgb;
  undefined local_25 [35];
  
  if ((lpsz != (char *)0x0) && (*lpsz != '\0')) {
    cOut = 0x1f;
    sVar1 = UTILGEN::FCompressUserString(lpsz,(char *)CONCAT22(unaff_SS,local_25),&cOut);
    if (sVar1 == 0) {
      PUBLIC::__fstrcpy();
      rgb = 0;
      iVar2 = PUBLIC::__fstrlen(lpsz);
      cOut = iVar2 + 1;
    }
    else {
      rgb = (byte)cOut;
    }
    WriteRt(0x15,cOut + 1,(void *)CONCAT22(unaff_SS,&rgb));
  }
  return;
}



// ======================================================================
// Function: XorFileBuf
// Address: 1040:1cc4
// ======================================================================


void __cdecl16far UTILGEN::XorFileBuf(char *rgb,short cb)

{
  long *plVar1;
  uint *puVar2;
  byte *pbVar3;
  byte bVar4;
  uint uVar5;
  uint in_DX;
  char *pch;
  long lPrev;
  long *pl;
  long *plMac;
  
  for (pl = (long *)rgb; pl < rgb + (cb >> 2) * 4; pl = pl + 1) {
    uVar5 = LGetNextFileXor();
    plVar1 = pl;
    *(uint *)plVar1 = *(uint *)plVar1 ^ uVar5;
    puVar2 = (uint *)((int)pl + 2);
    *puVar2 = *puVar2 ^ in_DX;
  }
  if ((cb & 3U) != 0) {
    pch = (char *)pl;
    bVar4 = LGetNextFileXor();
    cb = cb & 3U;
    while (cb != 0) {
      pbVar3 = (byte *)pch;
      *pbVar3 = *pbVar3 ^ bVar4;
      bVar4 = PUBLIC::__aFlshr();
      pch = pch + 1;
      cb = cb + -1;
    }
  }
  return;
}



// ======================================================================
// Function: __aFahdiff
// Address: 1118:1618
// ======================================================================


undefined4 __pascal16far PUBLIC::__aFahdiff(uint param_1_00,undefined2 param_1,uint param_2)

{
  return CONCAT22(-(uint)(param_1_00 < param_2),param_1_00 - param_2);
}



// ======================================================================
// Function: __aFulmul
// Address: 1118:0c7e
// ======================================================================


long __pascal16far PUBLIC::__aFulmul(uint param_1,uint param_2,uint param_3,uint param_4)

{
  if ((param_4 | param_2) == 0) {
    return (ulong)param_1 * (ulong)param_3;
  }
  return CONCAT22((int)((ulong)param_1 * (ulong)param_3 >> 0x10) +
                  param_2 * param_3 + param_1 * param_4,(int)((ulong)param_1 * (ulong)param_3));
}



// ======================================================================
// Function: __aFulshr
// Address: 1118:0e32
// ======================================================================


void __cdecl16far PUBLIC::__aFulshr(void)

{
  uint in_CX;
  uint uVar1;
  
  for (uVar1 = in_CX & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {
  }
  return;
}



// ======================================================================
// Function: __fmemmove
// Address: 1118:105a
// ======================================================================


undefined2 * __cdecl16far PUBLIC::__fmemmove(undefined4 param_1,undefined4 param_2,uint param_3)

{
  undefined *puVar1;
  undefined2 *puVar2;
  undefined *puVar3;
  undefined2 *puVar4;
  undefined *puVar5;
  uint uVar6;
  uint uVar7;
  undefined2 *puVar8;
  undefined *puVar9;
  undefined2 *puVar10;
  undefined *puVar11;
  undefined2 *puVar12;
  int iVar13;
  int iVar14;
  long lVar15;
  
  puVar10 = (undefined2 *)param_1;
  if (param_3 != 0) {
    iVar14 = (int)((ulong)param_2 >> 0x10);
    puVar8 = (undefined2 *)param_2;
    iVar13 = (int)((ulong)param_1 >> 0x10);
    lVar15 = __aFahdiff(puVar10,iVar13,puVar8,iVar14);
    puVar12 = puVar10;
    if ((lVar15 < 0) || ((uint)((uint)lVar15 < param_3) <= (uint)((ulong)lVar15 >> 0x10))) {
      while( true ) {
        uVar6 = ~(uint)puVar12;
        uVar6 = ((param_3 - 1) - uVar6 & -(uint)(param_3 - 1 < uVar6)) + uVar6;
        uVar7 = ~(uint)puVar8;
        uVar6 = (uVar6 - uVar7 & -(uint)(uVar6 < uVar7)) + uVar7 + 1;
        param_3 = param_3 - uVar6;
        for (uVar7 = uVar6 >> 1; uVar7 != 0; uVar7 = uVar7 - 1) {
          puVar4 = puVar12;
          puVar12 = puVar12 + 1;
          puVar2 = puVar8;
          puVar8 = puVar8 + 1;
          *puVar4 = *puVar2;
        }
        for (uVar6 = (uint)((uVar6 & 1) != 0); uVar6 != 0; uVar6 = uVar6 - 1) {
          puVar4 = puVar12;
          puVar12 = (undefined2 *)((int)puVar12 + 1);
          puVar2 = puVar8;
          puVar8 = (undefined2 *)((int)puVar8 + 1);
          *(undefined *)puVar4 = *(undefined *)puVar2;
        }
        if (param_3 == 0) break;
        if (puVar8 == (undefined2 *)0x0) {
          iVar14 = iVar14 + 0x94;
        }
        if (puVar12 == (undefined2 *)0x0) {
          iVar13 = iVar13 + 0x94;
        }
      }
    }
    else {
      uVar6 = param_3 - 1;
      puVar9 = (undefined *)((int)puVar8 + uVar6);
      if (CARRY2((uint)puVar8,uVar6)) {
        iVar14 = iVar14 + 0x94;
      }
      puVar11 = (undefined *)((int)puVar10 + uVar6);
      if (CARRY2((uint)puVar10,uVar6)) {
        iVar13 = iVar13 + 0x94;
      }
      while( true ) {
        puVar5 = puVar9 + ((int)(puVar11 +
                                ((int)(undefined *)(param_3 - 1) - (int)puVar11 &
                                -(uint)((undefined *)(param_3 - 1) < puVar11))) - (int)puVar9 &
                          -(uint)(puVar11 + ((int)(undefined *)(param_3 - 1) - (int)puVar11 &
                                            -(uint)((undefined *)(param_3 - 1) < puVar11)) < puVar9)
                          ) + 1;
        param_3 = param_3 - (int)puVar5;
        for (; puVar5 != (undefined *)0x0; puVar5 = puVar5 + -1) {
          puVar3 = puVar11;
          puVar11 = puVar11 + -1;
          puVar1 = puVar9;
          puVar9 = puVar9 + -1;
          *puVar3 = *puVar1;
        }
        if (param_3 == 0) break;
        if (puVar9 == (undefined *)0xffff) {
          iVar14 = iVar14 + -0x94;
        }
        if (puVar11 == (undefined *)0xffff) {
          iVar13 = iVar13 + -0x94;
        }
      }
    }
  }
  return puVar10;
}



// ======================================================================
// Function: __fmemset
// Address: 1118:1012
// ======================================================================


undefined2 * __cdecl16far PUBLIC::__fmemset(undefined4 param_1,undefined param_2,uint param_3)

{
  undefined2 *puVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined2 *puVar5;
  int iVar6;
  
  if (param_3 != 0) {
    iVar6 = (int)((ulong)param_1 >> 0x10);
    uVar3 = -(int)(undefined2 *)param_1;
    uVar4 = param_3;
    if (uVar3 != 0) {
      uVar4 = (uVar3 - param_3 & -(uint)(uVar3 < param_3)) + param_3;
      uVar3 = param_3 - uVar4;
    }
    puVar5 = (undefined2 *)param_1;
    for (uVar2 = uVar4 >> 1; uVar2 != 0; uVar2 = uVar2 - 1) {
      puVar1 = puVar5;
      puVar5 = puVar5 + 1;
      *puVar1 = CONCAT11(param_2,param_2);
    }
    for (uVar4 = (uint)((uVar4 & 1) != 0); uVar4 != 0; uVar4 = uVar4 - 1) {
      puVar1 = puVar5;
      puVar5 = (undefined2 *)((int)puVar5 + 1);
      *(undefined *)puVar1 = param_2;
    }
    if (uVar3 != 0) {
      for (uVar4 = uVar3 >> 1; uVar4 != 0; uVar4 = uVar4 - 1) {
        puVar1 = puVar5;
        puVar5 = puVar5 + 1;
        *puVar1 = CONCAT11(param_2,param_2);
      }
      for (uVar4 = (uint)((uVar3 & 1) != 0); uVar4 != 0; uVar4 = uVar4 - 1) {
        puVar1 = puVar5;
        puVar5 = (undefined2 *)((int)puVar5 + 1);
        *(undefined *)puVar1 = param_2;
      }
    }
  }
  return (undefined2 *)param_1;
}



// ======================================================================
// Function: __fstrcpy
// Address: 1118:0f82
// ======================================================================


void __cdecl16far PUBLIC::__fstrcpy(undefined2 *param_1,undefined2 *param_2)

{
  undefined2 *puVar1;
  undefined2 *puVar2;
  uint uVar3;
  uint uVar4;
  undefined2 *puVar5;
  undefined2 *puVar6;
  undefined2 uVar7;
  undefined2 uVar8;
  bool bVar9;
  
  uVar8 = (undefined2)((ulong)param_2 >> 0x10);
  puVar5 = (undefined2 *)param_2;
  bVar9 = true;
  uVar3 = 0xffff;
  puVar6 = puVar5;
  do {
    if (uVar3 == 0) break;
    uVar3 = uVar3 - 1;
    puVar1 = puVar6;
    puVar6 = (undefined2 *)((int)puVar6 + 1);
    bVar9 = *(char *)puVar1 == '\0';
  } while (!bVar9);
  uVar3 = ~uVar3;
  uVar7 = (undefined2)((ulong)param_1 >> 0x10);
  puVar6 = (undefined2 *)param_1;
  if (bVar9) {
    if (((ulong)param_1 & 1) != 0) {
      puVar6 = (undefined2 *)((int)puVar6 + 1);
      puVar5 = (undefined2 *)((int)puVar5 + 1);
      *(undefined *)param_1 = *(undefined *)param_2;
      uVar3 = uVar3 - 1;
    }
  }
  else {
    puVar6 = puVar6 + 1;
    puVar5 = puVar5 + 1;
    *param_1 = *param_2;
    uVar3 = uVar3 - 1;
  }
  for (uVar4 = uVar3 >> 1; uVar4 != 0; uVar4 = uVar4 - 1) {
    puVar2 = puVar6;
    puVar6 = puVar6 + 1;
    puVar1 = puVar5;
    puVar5 = puVar5 + 1;
    *puVar2 = *puVar1;
  }
  for (uVar3 = (uint)((uVar3 & 1) != 0); uVar3 != 0; uVar3 = uVar3 - 1) {
    puVar2 = puVar6;
    puVar6 = (undefined2 *)((int)puVar6 + 1);
    puVar1 = puVar5;
    puVar5 = (undefined2 *)((int)puVar5 + 1);
    *(undefined *)puVar2 = *(undefined *)puVar1;
  }
  return;
}



// ======================================================================
// Function: __setjmp
// Address: 1118:09c8
// ======================================================================


undefined2 __cdecl16far PUBLIC::__setjmp(int *param_1)

{
  int unaff_BP;
  int unaff_SI;
  int unaff_DI;
  int in_stack_00000000;
  int in_stack_00000002;
  
  *param_1 = unaff_BP + 1;
  param_1[1] = unaff_DI;
  param_1[2] = unaff_SI;
  param_1[3] = (int)register0x00000010;
  param_1[4] = in_stack_00000000;
  param_1[5] = in_stack_00000002;
  return 0;
}



// ======================================================================
// Function: _abs
// Address: 1118:079c
// ======================================================================


int __cdecl16far PUBLIC::_abs(uint param_1)

{
  return (param_1 ^ (int)param_1 >> 0xf) - ((int)param_1 >> 0xf);
}



// ======================================================================
// Function: _memmove
// Address: 1118:06d2
// ======================================================================


undefined2 * __cdecl16far PUBLIC::_memmove(undefined2 *param_1,undefined2 *param_2,uint param_3)

{
  undefined2 *puVar1;
  undefined2 *puVar2;
  uint uVar3;
  undefined *puVar4;
  undefined *puVar5;
  undefined2 *puVar6;
  
  if (param_3 != 0) {
    if ((param_2 < param_1) && (param_1 < (undefined2 *)((int)param_2 + param_3))) {
      puVar4 = (undefined *)((int)param_2 + param_3);
      puVar5 = (undefined *)((int)param_1 + param_3);
      while( true ) {
        puVar5 = puVar5 + -1;
        puVar4 = puVar4 + -1;
        if (param_3 == 0) break;
        param_3 = param_3 - 1;
        *puVar5 = *puVar4;
      }
    }
    else {
      puVar6 = param_1;
      if (((uint)param_1 & 1) != 0) {
        puVar6 = (undefined2 *)((int)param_1 + 1);
        puVar1 = param_2;
        param_2 = (undefined2 *)((int)param_2 + 1);
        *(undefined *)param_1 = *(undefined *)puVar1;
        param_3 = param_3 - 1;
      }
      for (uVar3 = param_3 >> 1; uVar3 != 0; uVar3 = uVar3 - 1) {
        puVar2 = puVar6;
        puVar6 = puVar6 + 1;
        puVar1 = param_2;
        param_2 = param_2 + 1;
        *puVar2 = *puVar1;
      }
      for (uVar3 = (uint)((param_3 & 1) != 0); uVar3 != 0; uVar3 = uVar3 - 1) {
        puVar2 = puVar6;
        puVar6 = (undefined2 *)((int)puVar6 + 1);
        puVar1 = param_2;
        param_2 = (undefined2 *)((int)param_2 + 1);
        *(undefined *)puVar2 = *(undefined *)puVar1;
      }
    }
  }
  return param_1;
}



// ======================================================================
// Function: _memset
// Address: 1118:076e
// ======================================================================


undefined2 * __cdecl16far PUBLIC::_memset(undefined2 *param_1,undefined param_2,uint param_3)

{
  undefined2 *puVar1;
  uint uVar2;
  undefined2 *puVar3;
  
  if (param_3 != 0) {
    puVar3 = param_1;
    if (((uint)param_1 & 1) != 0) {
      puVar3 = (undefined2 *)((int)param_1 + 1);
      *(undefined *)param_1 = param_2;
      param_3 = param_3 - 1;
    }
    for (uVar2 = param_3 >> 1; uVar2 != 0; uVar2 = uVar2 - 1) {
      puVar1 = puVar3;
      puVar3 = puVar3 + 1;
      *puVar1 = CONCAT11(param_2,param_2);
    }
    for (uVar2 = (uint)((param_3 & 1) != 0); uVar2 != 0; uVar2 = uVar2 - 1) {
      puVar1 = puVar3;
      puVar3 = (undefined2 *)((int)puVar3 + 1);
      *(undefined *)puVar1 = param_2;
    }
  }
  return param_1;
}



// ======================================================================
// Function: _strcpy
// Address: 1118:0392
// ======================================================================


void __cdecl16far PUBLIC::_strcpy(undefined2 *param_1,undefined2 *param_2)

{
  undefined2 *puVar1;
  undefined2 *puVar2;
  uint uVar3;
  uint uVar4;
  undefined2 *puVar5;
  
  uVar3 = 0xffff;
  puVar5 = param_2;
  do {
    if (uVar3 == 0) break;
    uVar3 = uVar3 - 1;
    puVar1 = puVar5;
    puVar5 = (undefined2 *)((int)puVar5 + 1);
  } while (*(char *)puVar1 != '\0');
  uVar3 = ~uVar3;
  if (((uint)param_1 & 1) != 0) {
    puVar2 = param_1;
    param_1 = (undefined2 *)((int)param_1 + 1);
    puVar1 = param_2;
    param_2 = (undefined2 *)((int)param_2 + 1);
    *(undefined *)puVar2 = *(undefined *)puVar1;
    uVar3 = uVar3 - 1;
  }
  for (uVar4 = uVar3 >> 1; uVar4 != 0; uVar4 = uVar4 - 1) {
    puVar2 = param_1;
    param_1 = param_1 + 1;
    puVar1 = param_2;
    param_2 = param_2 + 1;
    *puVar2 = *puVar1;
  }
  for (uVar3 = (uint)((uVar3 & 1) != 0); uVar3 != 0; uVar3 = uVar3 - 1) {
    puVar2 = param_1;
    param_1 = (undefined2 *)((int)param_1 + 1);
    puVar1 = param_2;
    param_2 = (undefined2 *)((int)param_2 + 1);
    *(undefined *)puVar2 = *(undefined *)puVar1;
  }
  return;
}



// ======================================================================
// Function: _strlen
// Address: 1118:03f0
// ======================================================================


int __cdecl16far PUBLIC::_strlen(char *param_1)

{
  char *pcVar1;
  uint uVar2;
  
  uVar2 = 0xffff;
  do {
    if (uVar2 == 0) break;
    uVar2 = uVar2 - 1;
    pcVar1 = param_1;
    param_1 = param_1 + 1;
  } while (*pcVar1 != '\0');
  return ~uVar2 - 1;
}



// ======================================================================
// Summary: 54 succeeded, 12 failed
// ======================================================================
