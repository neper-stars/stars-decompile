// Call tree decompilation from stars.exe (Stars! 2.60j RC3)
// Root function: FLoadGame
// Max depth: 2
// Total functions: 86
// Generated by Ghidra
//

// ======================================================================
// Function: AlertSz
// Address: 1040:2160
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: CBattles
// Address: 10e8:028c
// ======================================================================


short __cdecl16far VCR::CBattles(void)

{
  int iVar1;
  int iVar2;
  undefined2 uVar3;
  short cBattles;
  HB *lphb;
  BTLDATA *lpbd;
  
  cBattles = 0;
  lphb = (HB *)CONCAT22(DAT_1120_0d62,DAT_1120_0d60);
  if ((DAT_1120_0d60 == 0) && (DAT_1120_0d62 == 0)) {
    cBattles = 0;
  }
  else {
    lpbd = (BTLDATA *)CONCAT22(DAT_1120_0d62,DAT_1120_0d60 + 0x12);
    while( true ) {
      while (lpbd->id != -1) {
        uVar3 = (undefined2)((ulong)lpbd >> 0x10);
        iVar2 = (int)lpbd;
        if (*(int *)(iVar2 + 6) == 0) {
          return cBattles;
        }
        cBattles = cBattles + 1;
        lpbd = (BTLDATA *)CONCAT22(uVar3,iVar2 + *(int *)(iVar2 + 6));
      }
      uVar3 = (undefined2)((ulong)lphb >> 0x10);
      iVar2 = *(int *)((int)lphb + 8);
      iVar1 = *(int *)((int)lphb + 10);
      lphb = (HB *)CONCAT22(iVar1,iVar2);
      if (((iVar2 == 0) && (iVar1 == 0)) || (*(uint *)(iVar2 + 6) < 0x11)) break;
      lpbd = (BTLDATA *)CONCAT22(iVar1,iVar2 + 0x12);
    }
  }
  return cBattles;
}



// ======================================================================
// Function: CBuildProdItem
// Address: 10b8:0c92
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10b81941) */
/* WARNING: Removing unreachable block (ram,0x10b818bd) */
/* WARNING: Removing unreachable block (ram,0x10b8173c) */
/* WARNING: Removing unreachable block (ram,0x10b810a5) */
/* WARNING: Removing unreachable block (ram,0x10b80e9c) */
/* WARNING: Removing unreachable block (ram,0x10b80ec3) */
/* WARNING: Removing unreachable block (ram,0x10b80d33) */
/* WARNING: Removing unreachable block (ram,0x10b80d38) */
/* WARNING: Removing unreachable block (ram,0x10b80d17) */
/* WARNING: Removing unreachable block (ram,0x10b80ffd) */
/* WARNING: Removing unreachable block (ram,0x10b810a0) */
/* WARNING: Removing unreachable block (ram,0x10b81784) */
/* WARNING: Removing unreachable block (ram,0x10b81849) */
/* WARNING: Removing unreachable block (ram,0x10b8193c) */
/* WARNING: Removing unreachable block (ram,0x10b81920) */
/* WARNING: Removing unreachable block (ram,0x10b80fcd) */
/* WARNING: Removing unreachable block (ram,0x10b81283) */
/* WARNING: Removing unreachable block (ram,0x10b8124d) */
/* WARNING: Removing unreachable block (ram,0x10b81443) */
/* WARNING: Removing unreachable block (ram,0x10b815db) */
/* WARNING: Removing unreachable block (ram,0x10b81465) */
/* WARNING: Could not reconcile some variable overlaps */

short __cdecl16far
TURN2::CBuildProdItem
          (PLANET *lppl,PROD *lpprod,PROD *pprodPartial,long *rgRes,short fAlchemy,short *pmdStatus,
          short fCalcOnly)

{
  long *plVar1;
  int *piVar2;
  long *plVar3;
  uint *puVar4;
  int iVar5;
  bool bVar6;
  undefined uVar7;
  undefined uVar8;
  undefined uVar9;
  uint uVar10;
  uint uVar11;
  short sVar12;
  uint uVar13;
  undefined2 extraout_DX;
  int iVar14;
  undefined2 extraout_DX_00;
  undefined2 extraout_DX_01;
  undefined2 extraout_DX_02;
  undefined2 extraout_DX_03;
  undefined2 extraout_DX_04;
  undefined2 extraout_DX_05;
  uint uVar15;
  int iVar16;
  undefined2 uVar17;
  undefined2 uVar18;
  undefined4 uVar19;
  long lVar20;
  long lVar21;
  undefined2 uVar22;
  long AddCost;
  short fMineralBlocked;
  long rgCost;
  long pct;
  long pctTooBig;
  long pctInitial;
  short fResourceBlocked;
  short i;
  long rgCostPaid;
  short cAlchemy;
  short cBuilt;
  short fAutoBuild;
  PROD prod;
  long lAlchCost;
  long lMinNeeded;
  long cCanBuild;
  ulong iobjOther;
  short cMax;
  long pctT;
  
  cAlchemy = 0;
  uVar10 = PUBLIC::__aFulshr();
  pctInitial._0_2_ = uVar10 & 0x7f;
  pctInitial._2_2_ = 0;
  uVar17 = (undefined2)((ulong)lpprod >> 0x10);
  prod.flags1 = lpprod->flags1;
  prod._2_2_ = *(uint *)((int)lpprod + 2);
  uVar18 = (undefined2)((ulong)lppl >> 0x10);
  iVar16 = (int)lppl;
  PRODUCE::GetProductionCosts(lppl,lpprod,(ulong *)&rgCost,*(short *)(iVar16 + 2),1);
  cBuilt = 0;
  uVar10 = PUBLIC::__aFulshr();
  if (((uVar10 & 7) == 1) && (uVar10 = PUBLIC::__aFulshr(), (uVar10 & 0x7f) < 7)) {
    fAutoBuild = 1;
  }
  else {
    fAutoBuild = 0;
  }
  if (fAutoBuild != 0) {
    cMax = 1000;
    uVar10 = PUBLIC::__aFulshr();
    uVar10 = uVar10 & 0x7f;
    if (uVar10 == 0) {
      uVar10 = PUBLIC::__aFulshr();
      sVar12 = PLANET::CMaxOperableMines(lppl,*(short *)(iVar16 + 2),1);
      cMax = sVar12 - (uVar10 & 0xfff);
    }
    else if (uVar10 == 1) {
      uVar10 = PUBLIC::__aFulshr();
      sVar12 = PLANET::CMaxOperableFactories(lppl,*(short *)(iVar16 + 2),1);
      cMax = sVar12 - (uVar10 & 0xfff);
    }
    else if (uVar10 == 2) {
      uVar10 = *(uint *)(iVar16 + 0x18);
      sVar12 = PLANET::CMaxOperableDefenses(lppl,*(short *)(iVar16 + 2),1);
      cMax = sVar12 - (uVar10 & 0xfff);
    }
    else if (uVar10 != 3) {
      if ((uVar10 == 4) || (uVar10 == 5)) {
        cMax = PLANET::IpctCanTerraformLppl(lppl);
        if (0 < cMax) {
          uVar10 = PUBLIC::__aFulshr();
          iVar14 = 0;
          if ((((uVar10 & 0x7f) == 4) &&
              (UTIL::ChgPopFromPlanet(iVar16,(char)((ulong)lppl >> 0x10),0), -1 < iVar14)) &&
             (sVar12 = PLANET::PctPlanetDesirability(lppl,*(short *)(iVar16 + 2)), 0 < sVar12)) {
            cMax = 0;
          }
        }
      }
      else if ((uVar10 == 6) &&
              ((sVar12 = PLANET::IWarpMAFromLppl(lppl,(short *)0x0), sVar12 == 0 ||
               ((*(uint *)(iVar16 + 0x2e) & 0x3ff) == 0)))) {
        cMax = 0;
      }
    }
    if (cMax < 0) {
      cMax = 0;
    }
    if (((-1 < cMax) && ((uint)cMax < (prod.flags1 & 0x3ffU))) ||
       (uVar10 = PUBLIC::__aFulshr(), (uVar10 & 0x7f) == 3)) {
      uVar13 = 0;
      uVar10 = PUBLIC::__aFlshl();
      prod.flags1 = prod.flags1 & 0xfc00U | uVar10;
      prod._2_2_ = prod._2_2_ | uVar13;
    }
  }
  i = 0;
  while( true ) {
    lVar21 = CONCAT22(pctTooBig._2_2_,(undefined2)pctTooBig);
    if (3 < i) break;
    uVar22 = 0;
    uVar9 = 100;
    PUBLIC::__aFulshr(100,0);
    uVar7 = PUBLIC::__aFulmul();
    uVar19 = PUBLIC::__aFuldiv(uVar7,extraout_DX,uVar9,uVar22);
    *(int *)(&rgCostPaid + i) = (int)uVar19;
    *(undefined2 *)((int)&rgCostPaid + i * 4 + 2) = (int)((ulong)uVar19 >> 0x10);
    i = i + 1;
  }
LAB_10b8_108f:
  do {
    if ((prod.flags1 & 0x3ffU) == 0) goto LAB_10b8_1712;
    for (i = 0; i < 4; i = i + 1) {
      uVar10 = *(uint *)(&rgCost + i);
      plVar3 = &rgCostPaid + i;
      uVar13 = uVar10 - *(uint *)plVar3;
      iVar14 = (*(int *)((int)&rgCost + i * 4 + 2) - *(int *)((int)&rgCostPaid + i * 4 + 2)) -
               (uint)(uVar10 < *(uint *)plVar3);
      uVar10 = *(uint *)((int)(rgRes + i) + 2);
      if (((int)uVar10 <= iVar14) &&
         (((int)uVar10 < iVar14 ||
          (plVar3 = rgRes + i, *(uint *)plVar3 <= uVar13 && uVar13 != *(uint *)plVar3)))) break;
    }
    if (3 < i) {
      cBuilt = cBuilt + 1;
      prod.flags1 = prod.flags1 & 0xfc00U | prod.flags1 - 1U & 0x3ff;
      prod._2_2_ = prod._2_2_ & 0xf80f;
      for (i = 0; i < 4; i = i + 1) {
        uVar10 = *(uint *)(&rgCost + i);
        iVar14 = *(int *)((int)&rgCost + i * 4 + 2);
        plVar3 = &rgCostPaid + i;
        uVar13 = *(uint *)plVar3;
        uVar11 = uVar10 - *(uint *)plVar3;
        iVar5 = *(int *)((int)&rgCostPaid + i * 4 + 2);
        plVar3 = rgRes + i;
        uVar15 = *(uint *)plVar3;
        *(uint *)plVar3 = *(uint *)plVar3 - uVar11;
        puVar4 = (uint *)((int)(rgRes + i) + 2);
        *puVar4 = (*puVar4 - ((iVar14 - iVar5) - (uint)(uVar10 < uVar13))) - (uint)(uVar15 < uVar11)
        ;
        *(undefined2 *)(&rgCostPaid + i) = 0;
        *(undefined2 *)((int)&rgCostPaid + i * 4 + 2) = 0;
      }
      goto LAB_10b8_108f;
    }
    bVar6 = false;
    fResourceBlocked = 0;
    pct._0_2_ = 100;
    pct._2_2_ = 0;
    pct = 100;
    for (i = 0; pctTooBig = lVar21, i < 4; i = i + 1) {
      iVar14 = *(int *)((int)&rgCost + i * 4 + 2);
      if ((-1 < iVar14) && ((0 < iVar14 || (*(int *)(&rgCost + i) != 0)))) {
        uVar10 = *(uint *)((int)&rgCost + i * 4 + 2);
        puVar4 = (uint *)((int)(rgRes + i) + 2);
        uVar13 = *puVar4;
        if (((int)uVar13 < (int)uVar10) ||
           ((*puVar4 == uVar10 || (int)uVar13 < (int)uVar10 &&
            (*(uint *)(rgRes + i) < *(uint *)(&rgCost + i))))) {
          uVar22 = *(undefined2 *)((int)&rgCost + i * 4 + 2);
          uVar9 = (undefined)*(undefined2 *)(&rgCost + i);
          uVar7 = PUBLIC::__aFulmul();
          lVar20 = PUBLIC::__aFldiv(uVar7,extraout_DX_00,uVar9,uVar22);
          uVar22 = *(undefined2 *)((int)&rgCost + i * 4 + 2);
          uVar9 = (undefined)*(undefined2 *)(&rgCost + i);
          uVar7 = PUBLIC::__aFulmul();
          lVar21 = PUBLIC::__aFldiv(uVar7,extraout_DX_01,uVar9,uVar22);
          pctTooBig._0_2_ = (int)lVar21;
          pctTooBig._2_2_ = (int)((ulong)lVar21 >> 0x10);
          if (lVar20 <= lVar21 + -1) {
            lVar20 = lVar21 + -1;
          }
        }
        else {
          lVar20 = 100;
        }
        pctT._2_2_ = (undefined2)((ulong)lVar20 >> 0x10);
        pctT._0_2_ = (undefined2)lVar20;
        if (lVar20 < pct) {
          uVar10 = *(uint *)(&rgCost + i);
          plVar3 = &rgCostPaid + i;
          uVar13 = uVar10 - *(uint *)plVar3;
          plVar1 = rgRes + i;
          lMinNeeded._0_2_ = uVar13 - *(uint *)plVar1;
          lMinNeeded._2_2_ =
               (((*(int *)((int)&rgCost + i * 4 + 2) - *(int *)((int)&rgCostPaid + i * 4 + 2)) -
                (uint)(uVar10 < *(uint *)plVar3)) - *(uint *)((int)(rgRes + i) + 2)) -
               (uint)(uVar13 < *(uint *)plVar1);
          pct._0_2_ = (undefined2)pctT;
          pct._2_2_ = pctT._2_2_;
          pct = lVar20;
          if (i == 3) {
            fResourceBlocked = 1;
          }
          else {
            bVar6 = true;
          }
        }
      }
    }
    if ((bVar6) && (fAutoBuild != 0)) {
      if (fAlchemy == 0) {
        fAutoBuild = 2;
        goto LAB_10b8_1712;
      }
    }
    else {
      for (i = 0; i < 4; i = i + 1) {
        uVar22 = 0;
        uVar9 = 100;
        uVar7 = PUBLIC::__aFulmul();
        uVar19 = PUBLIC::__aFldiv(uVar7,extraout_DX_02,uVar9,uVar22);
        plVar3 = &rgCostPaid + i;
        uVar13 = (uint)uVar19 - *(uint *)plVar3;
        iVar14 = ((int)((ulong)uVar19 >> 0x10) - *(int *)((int)&rgCostPaid + i * 4 + 2)) -
                 (uint)((uint)uVar19 < *(uint *)plVar3);
        plVar3 = rgRes + i;
        uVar10 = *(uint *)plVar3;
        *(uint *)plVar3 = *(uint *)plVar3 - uVar13;
        puVar4 = (uint *)((int)(rgRes + i) + 2);
        *puVar4 = (*puVar4 - iVar14) - (uint)(uVar10 < uVar13);
        plVar3 = &rgCostPaid + i;
        uVar10 = *(uint *)plVar3;
        *(uint *)plVar3 = *(uint *)plVar3 + uVar13;
        piVar2 = (int *)((int)&rgCostPaid + i * 4 + 2);
        *piVar2 = *piVar2 + iVar14 + (uint)CARRY2(uVar10,uVar13);
      }
      uVar13 = 0;
      uVar10 = PUBLIC::__aFlshl();
      prod.flags1 = prod.flags1 | uVar10;
      prod._2_2_ = prod._2_2_ & 0xf80f | uVar13;
      lVar21 = pctTooBig;
      if ((fAlchemy == 0) || (fResourceBlocked != 0)) goto LAB_10b8_1712;
    }
    pctTooBig = lVar21;
    sVar12 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + *(int *)(iVar16 + 2) * 0xc0),6);
    if (sVar12 == 0) {
      uVar7 = 100;
    }
    else {
      uVar7 = 0x19;
    }
    lVar20 = PUBLIC::__aFldiv((char)*(undefined2 *)(rgRes + 3),*(undefined2 *)((int)rgRes + 0xe),
                              uVar7,0);
    if (CONCAT22(lMinNeeded._2_2_,(int)lMinNeeded) < lVar20) {
      lVar20 = CONCAT22(lMinNeeded._2_2_,(int)lMinNeeded);
    }
    cCanBuild._2_2_ = (int)((ulong)lVar20 >> 0x10);
    cCanBuild._0_2_ = (uint)lVar20;
    lVar21 = pctTooBig;
    if (0 < lVar20) {
      for (i = 0; i < 3; i = i + 1) {
        plVar3 = rgRes + i;
        uVar10 = *(uint *)plVar3;
        *(uint *)plVar3 = *(uint *)plVar3 + (uint)cCanBuild;
        puVar4 = (uint *)((int)(rgRes + i) + 2);
        *puVar4 = *puVar4 + cCanBuild._2_2_ + (uint)CARRY2(uVar10,(uint)cCanBuild);
      }
      uVar19 = PUBLIC::__aFulmul(uVar7,0,(char)lVar20,cCanBuild._2_2_);
      plVar3 = rgRes + i;
      uVar10 = *(uint *)plVar3;
      *(uint *)plVar3 = *(uint *)plVar3 - (uint)uVar19;
      puVar4 = (uint *)((int)(rgRes + i) + 2);
      *puVar4 = (*puVar4 - (int)((ulong)uVar19 >> 0x10)) - (uint)(uVar10 < (uint)uVar19);
      cAlchemy = cAlchemy + (uint)cCanBuild;
      lVar21 = pctTooBig;
    }
  } while (lVar20 == CONCAT22(lMinNeeded._2_2_,(int)lMinNeeded));
  iVar14 = *(int *)((int)rgRes + 0xe);
  if ((-1 < iVar14) &&
     (((0 < iVar14 || (*(int *)(rgRes + 3) != 0)) && (pprodPartial != (PROD *)0x0)))) {
    pctTooBig = lVar21;
    PUBLIC::_memset(pprodPartial,0,4);
    uVar10 = *(uint *)&pprodPartial->field1_0x2;
    pprodPartial->flags1 = pprodPartial->flags1;
    *(uint *)&pprodPartial->field1_0x2 = uVar10 & 0xfff1 | 2;
    uVar10 = *(uint *)&pprodPartial->field1_0x2;
    pprodPartial->flags1 = pprodPartial->flags1 & 0x3ffU | 0x2c00;
    *(uint *)&pprodPartial->field1_0x2 = uVar10 & 0xfffe;
    uVar22 = *(undefined2 *)&pprodPartial->field1_0x2;
    pprodPartial->flags1 = pprodPartial->flags1 & 0xfc00U | 1;
    *(undefined2 *)&pprodPartial->field1_0x2 = uVar22;
    uVar22 = 0;
    uVar9 = uVar7;
    uVar8 = PUBLIC::__aFulmul();
    PUBLIC::__aFldiv(uVar8,extraout_DX_03,uVar9,uVar22);
    uVar22 = 0;
    uVar9 = PUBLIC::__aFulmul();
    lVar21 = PUBLIC::__aFldiv(uVar9,extraout_DX_04,uVar7,uVar22);
    uVar15 = 0;
    pctTooBig = lVar21;
    uVar13 = PUBLIC::__aFlshl();
    uVar10 = *(uint *)&pprodPartial->field1_0x2;
    pprodPartial->flags1 = pprodPartial->flags1 | uVar13;
    *(uint *)&pprodPartial->field1_0x2 = uVar10 & 0xf80f | uVar15;
    uVar22 = 0;
    uVar9 = 100;
    uVar7 = PUBLIC::__aFulmul();
    uVar19 = PUBLIC::__aFldiv(uVar7,extraout_DX_05,uVar9,uVar22);
    plVar3 = rgRes + 3;
    uVar10 = *(uint *)plVar3;
    *(uint *)plVar3 = *(uint *)plVar3 - (uint)uVar19;
    piVar2 = (int *)((int)rgRes + 0xe);
    *piVar2 = (*piVar2 - (int)((ulong)uVar19 >> 0x10)) - (uint)(uVar10 < (uint)uVar19);
    lVar21 = pctTooBig;
  }
LAB_10b8_1712:
  if (0 < cBuilt) {
    pctTooBig = lVar21;
    uVar10 = PUBLIC::__aFulshr();
    lVar21 = pctTooBig;
    if ((uVar10 & 7) == 1) {
      uVar10 = PUBLIC::__aFulshr();
      if ((uVar10 & 0x7f) != 0xb) {
        uVar10 = PUBLIC::__aFulshr();
        lVar21 = pctTooBig;
        if ((uVar10 & 0x7f) != 3) goto LAB_10b8_17b7;
      }
      cAlchemy = cAlchemy + cBuilt;
      for (i = 0; lVar21 = pctTooBig, i < 3; i = i + 1) {
        plVar3 = rgRes + i;
        uVar10 = *(uint *)plVar3;
        *(uint *)plVar3 = *(uint *)plVar3 + cBuilt;
        puVar4 = (uint *)((int)(rgRes + i) + 2);
        *puVar4 = *puVar4 + (cBuilt >> 0xf) + (uint)CARRY2(uVar10,cBuilt);
      }
    }
  }
LAB_10b8_17b7:
  if (((cAlchemy != 0) && (fCalcOnly == 0)) && (((uint)_DATA::gd.flags1 >> 1 & 1) != 0)) {
    pctTooBig = lVar21;
    MSG::FSendPlrMsg2(*(short *)(iVar16 + 2),0x8c,lppl->id,lppl->id,cAlchemy);
    lVar21 = pctTooBig;
  }
  if (pmdStatus != (short *)0x0) {
    if (fAutoBuild == 2) {
      if (cBuilt < 1) {
        sVar12 = 4;
      }
      else {
        sVar12 = 3;
      }
      *pmdStatus = sVar12;
    }
    else if ((fAutoBuild == 0) || ((prod.flags1 & 0x3ffU) != 0)) {
      if (cBuilt == 0) {
        pctTooBig = lVar21;
        uVar10 = PUBLIC::__aFulshr();
        if (((uint)pctInitial == (uVar10 & 0x7f)) && (pctInitial._2_2_ == 0)) {
          sVar12 = 7;
        }
        else {
          sVar12 = 6;
        }
        *pmdStatus = sVar12;
        lVar21 = pctTooBig;
      }
      else if ((prod.flags1 & 0x3ffU) == 0) {
        *pmdStatus = 0;
      }
      else {
        *pmdStatus = 5;
      }
    }
    else {
      if (cBuilt < 1) {
        sVar12 = 2;
      }
      else {
        sVar12 = 1;
      }
      *pmdStatus = sVar12;
    }
  }
  if ((fCalcOnly == 0) && (fAutoBuild == 0)) {
    lpprod->flags1 = prod.flags1;
    *(uint *)((int)lpprod + 2) = prod._2_2_;
  }
  if (((fAutoBuild != 0) && (pprodPartial != (PROD *)0x0)) && ((pprodPartial->flags1 & 0x3ffU) == 0)
     ) {
    pctTooBig = lVar21;
    uVar10 = PUBLIC::__aFulshr();
    if ((uVar10 & 0x7f) != 0) {
      pprodPartial->flags1 = prod.flags1;
      *(uint *)&pprodPartial->field1_0x2 = prod._2_2_;
      uVar17 = *(undefined2 *)&pprodPartial->field1_0x2;
      pprodPartial->flags1 = pprodPartial->flags1 & 0xfc00U | 1;
      *(undefined2 *)&pprodPartial->field1_0x2 = uVar17;
      uVar15 = 0;
      uVar13 = PUBLIC::__aFlshl();
      uVar10 = *(uint *)&pprodPartial->field1_0x2;
      pprodPartial->flags1 = pprodPartial->flags1 & 0x3ffU | uVar13;
      *(uint *)&pprodPartial->field1_0x2 = uVar10 & 0xfffe | uVar15;
    }
  }
  return cBuilt;
}



// ======================================================================
// Function: CResourcesAtPlanet
// Address: 1048:788e
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10487954) */
/* WARNING: Could not reconcile some variable overlaps */

short __cdecl16far PLANET::CResourcesAtPlanet(PLANET *lppl,short iplr)

{
  short sVar1;
  uint uVar2;
  undefined2 uVar3;
  short sVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  undefined2 uVar9;
  long lVar10;
  undefined4 uVar11;
  long local_26;
  long local_1e;
  short iEnergy;
  short pctVal;
  short iEff;
  long lPopMax;
  short cFact;
  long lPop;
  short cRes;
  
  uVar9 = (undefined2)((ulong)lppl >> 0x10);
  iVar8 = (int)lppl;
  if ((*(int *)(iVar8 + 0x28) == 0) && (*(int *)(iVar8 + 0x2a) == 0)) {
    cRes = 0;
  }
  else {
    sVar1 = RACE::GetRaceStat((PLAYER *)((int)&c_common::rgplr + iplr * 0xc0),0);
    uVar6 = *(uint *)(iVar8 + 0x28);
    iVar5 = *(int *)(iVar8 + 0x2a);
    lPop = CONCAT22(iVar5,uVar6);
    iVar7 = iVar5;
    uVar2 = CalcPlanetMaxPop();
    if ((iVar7 <= iVar5) && ((iVar7 < iVar5 || (uVar2 < uVar6)))) {
      lVar10 = PUBLIC::__aFldiv(uVar6 - uVar2,CONCAT42(2,(iVar5 - iVar7) - (uint)(uVar6 < uVar2)));
      lPop = lVar10 + CONCAT22(iVar7,uVar2);
      iVar5 = iVar7;
      uVar3 = PUBLIC::__aFlshl();
      if (CONCAT22(iVar5,uVar3) < lVar10 + CONCAT22(iVar7,uVar2)) {
        uVar3 = PUBLIC::__aFlshl();
        lPop = CONCAT22(iVar7,uVar3);
      }
    }
    sVar4 = RACE::GetRaceStat((PLAYER *)((int)&c_common::rgplr + iplr * 0xc0),0xe);
    if (sVar4 == 8) {
      iEnergy = (short)*(char *)(iplr * 0xc0 + 0x59bc);
      PctPlanetDesirability((PLANET *)CONCAT42(CONCAT22(iplr,uVar9),iVar8),iplr);
      if (iEnergy < 1) {
        iEnergy = 1;
      }
      local_1e = (long)iEnergy;
      local_26 = (long)sVar1;
      PUBLIC::_sqrt(0x1048,((double)local_1e * (double)lPop) / (double)local_26);
      cRes = PUBLIC::__ftol();
    }
    else {
      iVar5 = PUBLIC::__aFldiv((undefined2)lPop,CONCAT42((long)sVar1,lPop._2_2_));
      cFact = CMaxOperableFactories((PLANET *)CONCAT42(CONCAT22(iplr,uVar9),iVar8),iplr,0);
      uVar6 = PUBLIC::__aFulshr();
      if ((int)(uVar6 & 0xfff) < cFact) {
        uVar6 = PUBLIC::__aFulshr();
        cFact = uVar6 & 0xfff;
      }
      sVar1 = RACE::GetRaceStat((PLAYER *)((int)&c_common::rgplr + iplr * 0xc0),1);
      uVar11 = 10;
      lVar10 = PUBLIC::__aFulmul(cFact,cFact >> 0xf,sVar1);
      iVar8 = PUBLIC::__aFldiv((int)(lVar10 + 9),CONCAT42(uVar11,(int)((ulong)(lVar10 + 9) >> 0x10))
                              );
      cRes = iVar5 + iVar8;
    }
    if (cRes == 0) {
      cRes = 1;
    }
  }
  return cRes;
}



// ======================================================================
// Function: CchGetString
// Address: 1040:221e
// ======================================================================


short __cdecl16far UTILGEN::CchGetString(short ids,char *psz)

{
  char *pcVar1;
  char *pszTT;
  char *pszT;
  
  pcVar1 = psz;
  pszT = STRINGS::PszGetCompressedString(ids);
  while (*pszT != '\0') {
    *psz = *pszT;
    psz = psz + 1;
    pszT = pszT + 1;
  }
  *psz = '\0';
  return (int)psz - (int)pcVar1;
}



// ======================================================================
// Function: ChgPopFromPlanet
// Address: 1038:7082
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10387497) */
/* WARNING: Removing unreachable block (ram,0x103872a9) */
/* WARNING: Removing unreachable block (ram,0x10387136) */
/* WARNING: Could not reconcile some variable overlaps */

uint __cdecl16far UTIL::ChgPopFromPlanet(PLANET *lppl,int fUpdate)

{
  uint *puVar1;
  int *piVar2;
  uint uVar3;
  short sVar4;
  uint uVar5;
  short sVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  undefined2 uVar12;
  long lVar13;
  undefined4 uVar14;
  long lVar15;
  undefined4 uVar16;
  undefined2 uVar17;
  undefined2 uVar18;
  undefined2 uVar19;
  long pctFull;
  long pctRetard;
  long lPopOld;
  long lPopInc;
  long lPopInc100;
  short pctDesire;
  long pctGrow100;
  short DeltaCur;
  long lPopIncDelta;
  short fPopDied;
  long lMaxPop;
  
  uVar12 = (undefined2)((ulong)lppl >> 0x10);
  iVar11 = (int)lppl;
  if ((*(int *)(iVar11 + 2) == -1) ||
     ((*(int *)(iVar11 + 0x28) == 0 && (*(int *)(iVar11 + 0x2a) == 0)))) {
    lPopInc._0_2_ = 0;
  }
  else {
    sVar4 = PLANET::PctPlanetDesirability(lppl,*(short *)(iVar11 + 2));
    uVar3 = *(uint *)(iVar11 + 0x28);
    iVar8 = *(int *)(iVar11 + 0x2a);
    if (sVar4 < 0) {
      uVar19 = 0;
      uVar17 = 10;
      uVar16 = PUBLIC::__aFulmul(uVar3,iVar8,-sVar4,-sVar4 >> 0xf);
      lVar13 = PUBLIC::__aFldiv(uVar16,uVar17,uVar19);
      if (lVar13 < 1) {
        uVar16 = 1;
      }
      else {
        uVar19 = 0;
        uVar17 = 10;
        uVar16 = PUBLIC::__aFulmul(uVar3,iVar8,-sVar4,-sVar4 >> 0xf);
        uVar16 = PUBLIC::__aFldiv(uVar16,uVar17,uVar19);
      }
      lVar13 = PUBLIC::__aFldiv(uVar16,100,0);
      lVar15 = PUBLIC::__aFlrem(uVar16,100,0);
      lPopIncDelta._0_2_ = (int)lVar15;
      if ((lVar13 == 0) && (lVar15 == 0)) {
        lPopIncDelta._0_2_ = 1;
      }
      if ((int)((*(uint *)(iVar11 + 0x14) & 0xff) - (int)lPopIncDelta) < 0) {
        lVar13 = lVar13 + 1;
      }
      lPopInc._2_2_ = (int)((ulong)lVar13 >> 0x10);
      lPopInc._0_2_ = (uint)lVar13;
      lVar13 = CONCAT22(-(lPopInc._2_2_ + (uint)((uint)lPopInc != 0)),-(uint)lPopInc);
    }
    else {
      iVar7 = iVar8;
      uVar5 = PLANET::CalcPlanetMaxPop();
      sVar6 = RACE::PctTrueMaxGrowth(*(short *)(iVar11 + 2));
      pctGrow100._0_2_ = sVar6 * sVar4;
      pctGrow100._2_2_ = (int)(uint)pctGrow100 >> 0xf;
      if ((((uint)_DATA::gd.flags1 >> 1 & 1) != 0) &&
         ((*(uint *)(*(int *)(iVar11 + 2) * 0xc0 + 0x59f6) >> 2 & 1) != 0)) {
        pctGrow100._0_2_ = PUBLIC::__aFlshr();
      }
      uVar16 = CONCAT22(pctGrow100._2_2_,(uint)pctGrow100);
      lVar13 = PUBLIC::__aFldiv(uVar5,iVar7,4,0);
      if (lVar13 < CONCAT22(iVar8,uVar3)) {
        iVar9 = iVar7;
        uVar10 = uVar5;
        uVar16 = PUBLIC::__aFulmul(uVar3,iVar8,1000,0);
        uVar16 = PUBLIC::__aFldiv(uVar16,uVar10,iVar9);
        if ((iVar8 < iVar7) || ((iVar8 <= iVar7 && (uVar3 < uVar5)))) {
          iVar7 = 1000 - (uint)uVar16;
          iVar9 = -(uint)(1000 < (uint)uVar16) - (int)((ulong)uVar16 >> 0x10);
          uVar16 = PUBLIC::__aFulmul(iVar7,iVar9,iVar7,iVar9);
          if ((pctGrow100._2_2_ < 1) && ((pctGrow100._2_2_ < 0 || ((uint)pctGrow100 < 1000)))) {
            uVar19 = 8;
            uVar17 = 0x9544;
            uVar16 = PUBLIC::__aFulmul((uint)pctGrow100,pctGrow100._2_2_,uVar16);
            uVar16 = PUBLIC::__aFldiv(uVar16,uVar17,uVar19);
          }
          else {
            uVar18 = 0;
            uVar19 = 10;
            uVar17 = 0x9544;
            uVar14 = PUBLIC::__aFldiv((uint)pctGrow100,pctGrow100._2_2_,10,0);
            uVar16 = PUBLIC::__aFulmul(uVar14,uVar16);
            uVar16 = PUBLIC::__aFldiv(uVar16,uVar17);
            uVar16 = PUBLIC::__aFulmul(uVar16,uVar19,uVar18);
          }
        }
        else {
          iVar7 = iVar7 + (uint)(0xfff5 < uVar5);
          if ((iVar8 <= iVar7) && ((iVar8 < iVar7 || (uVar3 < uVar5 + 10)))) {
            return 0;
          }
          uVar14 = PUBLIC::__aFldiv(uVar16,10,0);
          iVar7 = -(uint)(99 < (uint)uVar14) - (int)((ulong)uVar14 >> 0x10);
          if ((iVar7 < 0) && ((iVar7 < -1 || (99 - (uint)uVar14 < 0xfed4)))) {
            iVar7 = -1;
          }
          else {
            uVar16 = PUBLIC::__aFldiv(uVar16,10,0);
            iVar7 = -(uint)(99 < (uint)uVar16) - (int)((ulong)uVar16 >> 0x10);
          }
          uVar17 = PUBLIC::__aFlshl();
          uVar16 = CONCAT22(iVar7,uVar17);
        }
      }
      uVar14 = PUBLIC::__aFldiv(uVar16,100,0);
      lVar15 = PUBLIC::__aFulmul(uVar3,iVar8,uVar14);
      if (lVar15 < 10000000) {
        uVar19 = 0;
        uVar17 = 100;
        uVar16 = PUBLIC::__aFulmul(uVar3,iVar8,uVar16);
        lVar15 = PUBLIC::__aFldiv(uVar16,uVar17,uVar19);
      }
      lVar13 = PUBLIC::__aFldiv(lVar15,100,0);
      lVar15 = PUBLIC::__aFlrem(lVar15,100,0);
      lPopIncDelta._0_2_ = (int)lVar15;
      if ((lVar13 == 0) && (lVar15 == 0)) {
        lPopIncDelta._0_2_ = 1;
      }
      iVar8 = (*(uint *)(iVar11 + 0x14) & 0xff) + (int)lPopIncDelta;
      if (iVar8 < 100) {
        if (iVar8 < 0) {
          lVar13 = CONCAT22((int)((ulong)lVar13 >> 0x10) - (uint)((int)lVar13 == 0),(int)lVar13 + -1
                           );
        }
      }
      else {
        lVar13 = lVar13 + 1;
      }
    }
    lPopInc._2_2_ = (int)((ulong)lVar13 >> 0x10);
    lPopInc._0_2_ = (uint)lVar13;
    if (fUpdate != 0) {
      uVar10 = 0;
      uVar5 = PUBLIC::__aFlshl();
      uVar3 = *(uint *)(iVar11 + 0x16);
      *(uint *)(iVar11 + 0x14) = *(uint *)(iVar11 + 0x14) & 0xff00 | uVar5;
      *(uint *)(iVar11 + 0x16) = uVar3 | uVar10;
      puVar1 = (uint *)(iVar11 + 0x28);
      uVar3 = *puVar1;
      *puVar1 = *puVar1 + (uint)lPopInc;
      piVar2 = (int *)(iVar11 + 0x2a);
      *piVar2 = *piVar2 + lPopInc._2_2_ + (uint)CARRY2(uVar3,(uint)lPopInc);
    }
  }
  return (uint)lPopInc;
}



// ======================================================================
// Function: DestroyCurGame
// Address: 1070:44b0
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: DirtyGame
// Address: 1048:a228
// ======================================================================


void __cdecl16far PLANET::DirtyGame(short fDirty)

{
  if ((fDirty != _DATA::game.fDirty) && (_DATA::game.fDirty = fDirty, _DATA::fAi == 0)) {
    MSG::SetMsgTitle(_DATA::hwndMessage);
  }
  return;
}



// ======================================================================
// Function: EstMineralsMined
// Address: 1028:5362
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10285712) */
/* WARNING: Removing unreachable block (ram,0x102854bf) */
/* WARNING: Removing unreachable block (ram,0x102856b7) */
/* WARNING: Removing unreachable block (ram,0x102856ca) */
/* WARNING: Removing unreachable block (ram,0x102854c4) */
/* WARNING: Removing unreachable block (ram,0x102856cf) */
/* WARNING: Removing unreachable block (ram,0x102856ee) */
/* WARNING: Removing unreachable block (ram,0x102856f3) */
/* WARNING: Removing unreachable block (ram,0x10285717) */
/* WARNING: Removing unreachable block (ram,0x1028582c) */
/* WARNING: Removing unreachable block (ram,0x1028563d) */
/* WARNING: Removing unreachable block (ram,0x10285775) */
/* WARNING: Removing unreachable block (ram,0x10285806) */
/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far MINE::EstMineralsMined(PLANET *lppl,long *plQuan,long cMines,short fApply)

{
  uint *puVar1;
  char *pcVar2;
  long *plVar3;
  byte bVar4;
  int iVar5;
  uint uVar6;
  short sVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  uint *puVar12;
  int *piVar13;
  undefined2 uVar14;
  long lVar15;
  long lVar16;
  undefined4 uVar17;
  long lVar18;
  undefined2 uVar19;
  undefined2 uVar20;
  uint uVar21;
  FLEET *lpfl;
  short ifl;
  long rglQuan;
  long lLeft;
  long lConc;
  long lMineEff;
  long lMine;
  short fRemote;
  short fMacintosh;
  long lQuan;
  short i;
  long lQuanAct;
  long lQuanRem;
  
  fRemote = (short)(cMines != -1);
  uVar14 = (undefined2)((ulong)lppl >> 0x10);
  iVar11 = (int)lppl;
  if ((*(int *)(iVar11 + 2) == -1) ||
     (sVar7 = RACE::GetRaceStat((PLAYER *)((int)&c_common::rgplr + *(int *)(iVar11 + 2) * 0xc0),0xe)
     , sVar7 != 8)) {
    fMacintosh = 0;
  }
  else {
    fMacintosh = 1;
  }
  if (cMines == -1) {
    if ((*(int *)(iVar11 + 2) == -1) ||
       ((*(int *)(iVar11 + 0x28) == 0 && (*(int *)(iVar11 + 0x2a) == 0)))) {
      for (i = 0; i < 3; i = i + 1) {
        *(undefined2 *)(plQuan + i) = 0xffff;
        *(undefined2 *)((int)(plQuan + i) + 2) = 0xffff;
      }
      return;
    }
    lMine._0_2_ = PLANET::CMinesOperating(lppl);
    lMine._2_2_ = (short)lMine >> 0xf;
    if (fMacintosh == 0) {
      lMineEff._0_2_ =
           RACE::GetRaceStat((PLAYER *)((int)&c_common::rgplr + *(int *)(iVar11 + 2) * 0xc0),4);
      lMineEff._2_2_ = (short)lMineEff >> 0xf;
    }
    else {
      lMineEff._0_2_ = 10;
      lMineEff._2_2_ = 0;
    }
    cMines = CONCAT22(lMine._2_2_,(short)lMine);
  }
  else {
    lMineEff._0_2_ = 10;
    lMineEff._2_2_ = 0;
  }
  lVar18 = CONCAT22(lLeft._2_2_,(uint)lLeft);
  lVar15 = CONCAT22(lQuan._2_2_,(uint)lQuan);
  i = 0;
  do {
    if (2 < i) {
      if ((fMacintosh != 0) && (fRemote == 0)) {
        for (ifl = 0; ifl < c_common::cFleet; ifl = ifl + 1) {
          piVar13 = (int *)((int)_DATA::rglpfl + ifl * 4);
          iVar9 = *piVar13;
          iVar5 = piVar13[1];
          if ((iVar9 == 0) && (iVar5 == 0)) {
            return;
          }
          if ((((*(int *)(iVar9 + 6) == lppl->id) && (*(int *)(iVar9 + 2) == *(int *)(iVar11 + 2)))
              && ((*(uint *)(iVar9 + 4) >> 10 & 1) == 0)) &&
             ((*(int *)(iVar9 + 0x62) < 2 &&
              (uVar17 = *(undefined4 *)(iVar9 + 100), (*(uint *)((int)uVar17 + 10) & 0xf) == 3)))) {
            iVar10 = iVar5;
            lMine = cMines;
            lQuan = lVar15;
            lLeft = lVar18;
            iVar8 = SHIP2::CMineFromLpfl(iVar9,iVar5);
            cMines = lMine;
            lVar15 = lQuan;
            lVar18 = lLeft;
            if ((-1 < iVar10) && ((0 < iVar10 || (iVar8 != 0)))) {
              EstMineralsMined(lppl,&rglQuan,CONCAT22(iVar10,iVar8),fApply);
              for (i = 0; i < 3; i = i + 1) {
                uVar21 = *(uint *)(&rglQuan + i);
                iVar10 = *(int *)((int)&rglQuan + i * 4 + 2);
                plVar3 = plQuan + i;
                uVar6 = *(uint *)plVar3;
                *(uint *)plVar3 = *(uint *)plVar3 + uVar21;
                puVar1 = (uint *)((int)(plQuan + i) + 2);
                *puVar1 = *puVar1 + iVar10 + (uint)CARRY2(uVar6,uVar21);
              }
              cMines = lMine;
              lVar15 = lQuan;
              lVar18 = lLeft;
              if (fApply != 0) {
                *(uint *)(iVar9 + 4) = *(uint *)(iVar9 + 4) & 0xdfff;
              }
            }
          }
        }
      }
      return;
    }
    lConc._0_2_ = (uint)*(byte *)(iVar11 + 9 + i);
    if ((((uint)lConc < 0x1e) && ((*(uint *)(iVar11 + 4) >> 10 & 1) != 0)) &&
       ((fRemote == 0 || (fMacintosh != 0)))) {
      lConc._0_2_ = 0x1e;
    }
    lConc._2_2_ = 0;
    lMine = cMines;
    lQuan = lVar15;
    lLeft = lVar18;
    lVar15 = PUBLIC::__aFulmul(cMines,(uint)lConc,0);
    lVar18 = lVar15;
    if (fRemote == 0) {
      uVar20 = 0;
      uVar19 = 10;
      lQuanAct = lVar15;
      uVar17 = PUBLIC::__aFulmul(lVar15,(short)lMineEff,lMineEff._2_2_);
      lVar18 = PUBLIC::__aFldiv(uVar17,uVar19,uVar20);
      lVar15 = lQuanAct;
    }
    lQuan = lVar18;
    lQuanAct = lVar15;
    lVar15 = PUBLIC::__aFlrem(lVar18,100,0);
    lQuanRem = lVar15;
    lVar15 = PUBLIC::__aFldiv(lQuan,100,0);
    lVar18 = lLeft;
    if ((lQuanRem != 0) && (((uint)_DATA::gd.flags1 >> 1 & 1) != 0)) {
      lQuan = lVar15;
      sVar7 = UTILGEN::Random(100);
      lVar15 = lQuan;
      lVar18 = CONCAT22(sVar7,(uint)lLeft);
      if (sVar7 < (int)lQuanRem) {
        lVar15 = lQuan + 1;
        lVar18 = CONCAT22(sVar7,(uint)lLeft);
      }
    }
    lQuan._2_2_ = (int)((ulong)lVar15 >> 0x10);
    lQuan._0_2_ = (uint)lVar15;
    *(uint *)(plQuan + i) = (uint)lQuan;
    *(int *)((int)(plQuan + i) + 2) = lQuan._2_2_;
    cMines = lMine;
    if (fApply != 0) {
      puVar12 = (uint *)(iVar11 + 0x1c + i * 4);
      puVar1 = puVar12;
      uVar21 = *puVar1;
      *puVar1 = *puVar1 + (uint)lQuan;
      puVar1 = puVar12 + 1;
      *puVar1 = *puVar1 + lQuan._2_2_ + (uint)CARRY2(uVar21,(uint)lQuan);
      lQuan = lVar15;
      lLeft = lVar18;
      lVar16 = PUBLIC::__aFldiv(lQuanAct,100,0);
      lVar18 = lLeft;
      while( true ) {
        cMines = lMine;
        lVar15 = lQuan;
        lQuanAct = lVar16;
        if ((lVar16 < 1) || (*(byte *)(iVar11 + 9 + i) < 2)) goto LAB_1028_588f;
        rglQuan._0_2_ = (uint)*(byte *)(iVar11 + 6 + i);
        bVar4 = *(byte *)(iVar11 + 9 + i);
        lpfl._2_2_ = (uint)bVar4;
        if ((uint)rglQuan == 0) {
          rglQuan._0_2_ = 0x100;
        }
        rglQuan._2_2_ = 0;
        if (bVar4 < 0x65) {
          if (bVar4 < 5) {
            lpfl._2_2_ = 10;
          }
          else if (bVar4 < 0x19) {
            lpfl._2_2_ = 0x19;
          }
        }
        else {
          lpfl._2_2_ = 100;
        }
        ifl = 0;
        uVar20 = 0;
        uVar19 = 0x100;
        uVar21 = lpfl._2_2_;
        lLeft = lVar18;
        uVar17 = PUBLIC::__aFulmul((uint)rglQuan,0,0x30d4,0);
        uVar17 = PUBLIC::__aFldiv(uVar17,uVar19,uVar20);
        lVar18 = PUBLIC::__aFldiv(uVar17,uVar21,ifl);
        if (lQuanAct < lVar18) break;
        lVar16 = lQuanAct - lVar18;
        pcVar2 = (char *)(iVar11 + 9 + i);
        *pcVar2 = *pcVar2 + -1;
        *(undefined *)(iVar11 + 6 + i) = 0;
      }
      lLeft = lVar18;
      uVar17 = PUBLIC::__aFldiv(0x30d4,0,lpfl._2_2_,0);
      iVar9 = (lLeft._2_2_ - lQuanAct._2_2_) - (uint)((uint)lLeft < (uint)lQuanAct);
      uVar19 = PUBLIC::__aFlshl(uVar17);
      lVar18 = PUBLIC::__aFldiv(uVar19,iVar9,uVar17);
      if (lVar18 < 1) {
        lVar18 = 1;
      }
      if (CONCAT22(rglQuan._2_2_,(uint)rglQuan) <= lVar18) {
        lVar18 = CONCAT22(rglQuan._2_2_ + -1 + (uint)((uint)rglQuan != 0),(uint)rglQuan - 1);
      }
      *(undefined *)(iVar11 + 6 + i) = (char)lVar18;
      cMines = lMine;
      lVar15 = lQuan;
      if (lVar18 == 0) {
        pcVar2 = (char *)(iVar11 + 9 + i);
        *pcVar2 = *pcVar2 + -1;
      }
    }
LAB_1028_588f:
    i = i + 1;
  } while( true );
}



// ======================================================================
// Function: EstimateItemProdSched
// Address: 10d0:4f40
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10d05159) */
/* WARNING: Removing unreachable block (ram,0x10d050ac) */
/* WARNING: Removing unreachable block (ram,0x10d052cc) */
/* WARNING: Variable defined which should be unmapped: lpprod */
/* WARNING: Removing unreachable block (ram,0x10d05184) */
/* WARNING: Removing unreachable block (ram,0x10d051ac) */
/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far
PRODUCE::EstimateItemProdSched
          (PLANET *lppl,PLPROD *lpplprod,short iItem,short *piFirst,short *piLast)

{
  int *piVar1;
  PLANET *pPVar2;
  byte bVar3;
  undefined2 uVar4;
  uint uVar5;
  PROD *pprodPartial;
  short sVar6;
  int iVar7;
  int *piVar8;
  PLANET *pPVar9;
  undefined2 uVar10;
  undefined2 unaff_SS;
  bool bVar11;
  undefined4 uVar12;
  undefined uVar13;
  PROD *lpprod;
  long rgRes;
  uint local_62;
  int local_60;
  short iMac;
  short fAlchemy;
  short iPass;
  short j;
  short i;
  short mdStatus;
  PROD prodPartial;
  short cBuilt;
  long rglQuan;
  PLANET pl;
  long cResearch;
  
  if (((int)lpplprod == 0) && (lpplprod._2_2_ == 0)) {
    lpplprod = (PLPROD *)CONCAT22(((int *)lppl)[0x1b],((int *)lppl)[0x1a]);
  }
  pPVar9 = &pl;
  piVar8 = (int *)lppl;
  for (iVar7 = 0x1c; iVar7 != 0; iVar7 = iVar7 + -1) {
    pPVar2 = pPVar9;
    pPVar9 = (PLANET *)&pPVar9->iPlayer;
    piVar1 = piVar8;
    piVar8 = piVar8 + 1;
    pPVar2->id = *piVar1;
  }
  uVar10 = (undefined2)((ulong)lpplprod >> 0x10);
  iVar7 = (int)lpplprod;
  pl.lpplprod = (PLPROD *)MEMORY::LpplAlloc(4,(uint)*(byte *)(iVar7 + 2),0);
  PUBLIC::__fmemcpy((char)((int)pl.lpplprod + 4),(int)((ulong)pl.lpplprod >> 0x10),iVar7 + 4,
                    (char)((ulong)lpplprod >> 0x10),(uint)*(byte *)(iVar7 + 3) << 2);
  bVar3 = *(byte *)(iVar7 + 3);
  *(byte *)((int)pl.lpplprod + 3) = bVar3;
  iMac = (short)bVar3;
  prodPartial.flags1 = prodPartial.flags1 & 0xfc00;
  *piLast = 0;
  *piFirst = 0;
  iPass = 1;
  do {
    if (99 < iPass) {
      if (*piFirst == 0) {
        *piFirst = 100;
      }
      *piLast = 100;
PRODUCE_LCleanUp:
      if (((int)pl.lpplprod != 0) || (pl.lpplprod._2_2_ != 0)) {
        MEMORY::FreePl((PL *)pl.lpplprod);
      }
      return;
    }
    uVar13 = (undefined)((uint)unaff_SS >> 8);
    MINE::EstMineralsMined((PLANET *)CONCAT13(uVar13,CONCAT12((char)unaff_SS,&pl)),&rglQuan,-1,1);
    for (j = 0; j < 3; j = j + 1) {
      uVar10 = *(undefined2 *)((int)pl.rgwtMin + j * 4 + 2);
      iVar7 = j * 4;
      *(undefined2 *)(&rgRes + j) = *(undefined2 *)(pl.rgwtMin + j);
      *(undefined2 *)((int)&rgRes + iVar7 + 2) = uVar10;
    }
    local_62 = PLANET::CResourcesAtPlanet
                         ((PLANET *)CONCAT13(uVar13,CONCAT12((char)unaff_SS,&pl)),((int *)lppl)[1]);
    local_60 = (int)local_62 >> 0xf;
    uVar5 = PUBLIC::__aFulshr();
    if ((uVar5 & 1) == 0) {
      uVar10 = 0;
      uVar13 = 100;
      iVar7 = (int)*(char *)((int)&DAT_1120_59da + ((int *)lppl)[1] * 0xc0);
      uVar12 = PUBLIC::__aFulmul((char)local_62,(char)local_60,iVar7,iVar7 >> 0xf);
      uVar12 = PUBLIC::__aFldiv(uVar12,uVar13,uVar10);
      cResearch._0_2_ = (uint)uVar12;
      bVar11 = local_62 < (uint)cResearch;
      local_62 = local_62 - (uint)cResearch;
      local_60 = (local_60 - (int)((ulong)uVar12 >> 0x10)) - (uint)bVar11;
    }
    else {
      cResearch._0_2_ = 0;
    }
    fAlchemy = 0;
    for (i = -1; i < iMac; i = i + 1) {
      if (i == -1) {
        lpprod = (PROD *)CONCAT22(unaff_SS,&prodPartial);
      }
      else {
        lpprod = (PROD *)CONCAT22(pl.lpplprod._2_2_,(int)pl.lpplprod + 4 + i * 4);
      }
      if ((lpprod->flags1 & 0x3ffU) != 0) {
        uVar5 = PUBLIC::__aFulshr();
        uVar10 = (undefined2)((ulong)lpprod >> 0x10);
        if (((uVar5 & 0x7f) == 3) && (uVar5 = PUBLIC::__aFulshr(), (uVar5 & 7) == 1)) {
          if (i < iMac + -1) {
            if (i != iItem) {
              fAlchemy = 1;
              goto LAB_10d0_53bf;
            }
            *piLast = -1;
            *piFirst = -1;
            goto PRODUCE_LCleanUp;
          }
          uVar4 = *(undefined2 *)((int)lpprod + 2);
          lpprod->flags1 = lpprod->flags1 & 0xfc00U | 0x3fc;
          *(undefined2 *)((int)lpprod + 2) = uVar4;
        }
        if (i == -1) {
          pprodPartial = (PROD *)0x0;
        }
        else {
          pprodPartial = &prodPartial;
        }
        sVar6 = TURN2::CBuildProdItem
                          ((PLANET *)CONCAT22(unaff_SS,&pl),lpprod,pprodPartial,&rgRes,fAlchemy,
                           &mdStatus,0);
        if (iItem == i) {
          if ((0 < sVar6) && (*piFirst == 0)) {
            *piFirst = iPass;
          }
          if (mdStatus == 2) {
            if (*piFirst != 0) {
              *piLast = iPass + -1;
            }
            goto PRODUCE_LCleanUp;
          }
          if ((mdStatus == 0) || (mdStatus == 1)) {
            *piLast = iPass;
            goto PRODUCE_LCleanUp;
          }
        }
        fAlchemy = 0;
        uVar5 = PUBLIC::__aFulshr();
        if ((uVar5 & 7) == 1) {
          uVar5 = PUBLIC::__aFulshr();
          uVar5 = uVar5 & 0x7f;
          iVar7 = sVar6 >> 0xf;
          if (uVar5 == 0) {
LAB_10d0_52ea:
            uVar5 = PUBLIC::__aFlshl();
            bVar11 = CARRY2(uVar5,pl._20_2_);
            pl._20_2_ = pl._20_2_ & 0xff | uVar5 + pl._20_2_ & 0xff00;
            pl._22_2_ = pl._22_2_ & 0xfff0 | iVar7 + pl._22_2_ + (uint)bVar11 & 0xf;
          }
          else if ((uVar5 == 1) || (uVar5 == 7)) {
            uVar5 = PUBLIC::__aFlshl();
            pl._22_2_ = pl._22_2_ & 0xf | iVar7 + pl._22_2_ + (uint)CARRY2(uVar5,pl._20_2_) & 0xfff0
            ;
          }
          else if (uVar5 == 8) goto LAB_10d0_52ea;
        }
        if (4 < mdStatus) break;
      }
LAB_10d0_53bf:
    }
    if (iItem < 0) {
      *piFirst = local_62;
      if (iItem == -1) {
        piVar1 = piFirst;
        *piVar1 = *piVar1 + (uint)cResearch;
      }
      goto PRODUCE_LCleanUp;
    }
    for (j = 0; j < 3; j = j + 1) {
      uVar10 = *(undefined2 *)((int)&rgRes + j * 4 + 2);
      *(undefined2 *)(pl.rgwtMin + j) = *(undefined2 *)(&rgRes + j);
      *(undefined2 *)((int)pl.rgwtMin + j * 4 + 2) = uVar10;
    }
    UTIL::ChgPopFromPlanet(&pl);
    iPass = iPass + 1;
  } while( true );
}



// ======================================================================
// Function: FCheckPassword
// Address: 1040:58d8
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: FDecompressUserString
// Address: 1040:46e8
// ======================================================================


short __cdecl16far UTILGEN::FDecompressUserString(char *szIn,short cIn,char *szOut,short *pcOut)

{
  short sVar1;
  char cVar2;
  uint uVar3;
  char *pchOut;
  short iNyb;
  char szWork;
  short fHalf;
  
  fHalf = 0;
  pchOut = &szWork;
  while (0 < cIn) {
    if (fHalf == 0) {
      iNyb = (int)*szIn >> 4 & 0xf;
    }
    else {
      iNyb = (int)*szIn & 0xf;
      cIn = cIn + -1;
      szIn = (char *)CONCAT22(szIn._2_2_,(int)szIn + 1);
      if ((iNyb == 0xf) && (cIn == 0)) break;
    }
    sVar1 = iNyb;
    fHalf = (short)(fHalf == 0);
    if (10 < (uint)iNyb) {
      if (fHalf == 0) {
        uVar3 = (int)*szIn & 0xf0;
      }
      else {
        uVar3 = ((int)*szIn & 0xfU) << 4;
        cIn = cIn + -1;
        szIn = (char *)CONCAT22(szIn._2_2_,(int)szIn + 1);
      }
      iNyb = iNyb | uVar3;
      fHalf = (short)(fHalf == 0);
      if (sVar1 == 0xf) {
        if (fHalf == 0) {
          uVar3 = ((int)*szIn & 0xf0U) << 4;
        }
        else {
          uVar3 = ((int)*szIn & 0xfU) << 8;
          cIn = cIn + -1;
          szIn = (char *)CONCAT22(szIn._2_2_,(int)szIn + 1);
        }
        iNyb = iNyb | uVar3;
        fHalf = (short)(fHalf == 0);
      }
    }
    cVar2 = ChFromNybble(iNyb);
    *pchOut = cVar2;
    pchOut = pchOut + 1;
    if (*pcOut < (int)pchOut - (int)&szWork) {
      return 0;
    }
  }
  *pchOut = '\0';
  PUBLIC::__fstrcpy(szOut,&szWork);
  return 1;
}



// ======================================================================
// Function: FFinishPlrMsgEntry
// Address: 1030:9bd6
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

short __cdecl16far MSG::FFinishPlrMsgEntry(short dInc)

{
  int iVar1;
  int iVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  undefined2 uVar6;
  undefined2 uVar7;
  int iVar8;
  short cb;
  MSGPLR *lpmpPrev;
  MSGPLR *lpmpCur;
  short iPlrTo;
  short cbNew;
  short i;
  byte *lpbMsg;
  
  lpmpPrev = (MSGPLR *)&_DATA::vlpmsgplrOut;
  i = _DATA::iMsgSendCur;
  while( true ) {
    iVar4 = i + -1;
    iVar8 = (int)lpmpPrev;
    uVar6 = (undefined2)((ulong)lpmpPrev >> 0x10);
    if (i < 1) break;
    lpmpPrev = (MSGPLR *)CONCAT22(*(undefined2 *)(iVar8 + 2),*(undefined2 *)&lpmpPrev->lpmsgplrNext)
    ;
    i = iVar4;
  }
  iVar1 = *(int *)&lpmpPrev->lpmsgplrNext;
  iVar2 = *(int *)(iVar8 + 2);
  lpmpCur = (MSGPLR *)CONCAT22(iVar2,iVar1);
  if (dInc == 1000) {
    cb = 0;
    dInc = 0;
    i = iVar4;
  }
  else {
    i = iVar4;
    cb = GETWINDOWTEXT();
  }
  if (cb == 0) {
    if ((iVar1 != 0) || (iVar2 != 0)) {
      PLANET::DirtyGame(1);
      uVar7 = *(undefined2 *)(iVar1 + 2);
      *(undefined2 *)&lpmpPrev->lpmsgplrNext = *(undefined2 *)&lpmpCur->lpmsgplrNext;
      *(undefined2 *)(iVar8 + 2) = uVar7;
      MEMORY::FreeLp((void *)CONCAT22(iVar2,iVar1),8);
      _DATA::vcmsgplrOut = _DATA::vcmsgplrOut + -1;
      if (0 < _DATA::iMsgSendCur) {
        _DATA::iMsgSendCur = _DATA::iMsgSendCur + -1;
      }
    }
    if ((dInc == -1) && (0 < _DATA::iMsgSendCur)) {
      _DATA::iMsgSendCur = _DATA::iMsgSendCur + -1;
    }
    else if ((dInc == 1) && (_DATA::iMsgSendCur < _DATA::vcmsgplrOut)) {
      _DATA::iMsgSendCur = _DATA::iMsgSendCur + 1;
    }
    sVar3 = 0;
  }
  else {
    cbNew = cb;
    sVar3 = UTILGEN::FCompressUserString
                      ((char *)CONCAT22(DAT_1120_5208,c_common::lpb2k),
                       (char *)CONCAT22(DAT_1120_5208,c_common::lpb2k + 0x400),&cbNew);
    if (sVar3 == 0) {
      cb = -1 - cb;
      lpbMsg._0_2_ = c_common::lpb2k;
    }
    else {
      cb = cbNew;
      lpbMsg._0_2_ = c_common::lpb2k + 0x400;
    }
    lpbMsg._2_2_ = DAT_1120_5208;
    iVar4 = PUBLIC::_abs(cb);
    cbNew = iVar4 + 0xc;
    uVar7 = c_common::hwndMsgDrop;
    iVar4 = SENDMESSAGE(0x1118,0,0,0,0x407);
    if ((iVar1 == 0) && (iVar2 == 0)) {
      PLANET::DirtyGame(1);
      lpmpCur = (MSGPLR *)MEMORY::LpAlloc(cbNew,8);
      uVar7 = (undefined2)((ulong)lpmpCur >> 0x10);
      *(undefined2 *)&lpmpCur->lpmsgplrNext = 0;
      *(undefined2 *)((int)lpmpCur + 2) = 0;
      _DATA::vcmsgplrOut = _DATA::vcmsgplrOut + 1;
      *(int *)((int)lpmpCur + 8) = _DATA::iMsgCur;
    }
    else {
      if (((cb != *(int *)(iVar1 + 10)) || (*(int *)(iVar1 + 6) != iVar4)) ||
         (iVar5 = PUBLIC::__fmemcmp(iVar1 + 0xc,iVar2,(int)lpbMsg,lpbMsg._2_2_,cb,uVar7), iVar5 != 0
         )) {
        PLANET::DirtyGame(1);
      }
      lpmpCur = (MSGPLR *)MEMORY::LpReAlloc((void *)CONCAT22(iVar2,iVar1),cbNew,8);
    }
    *(int *)&lpmpPrev->lpmsgplrNext = (int)lpmpCur;
    *(undefined2 *)(iVar8 + 2) = lpmpCur._2_2_;
    *(int *)((int)lpmpCur + 4) = _DATA::idPlayer;
    *(int *)((int)lpmpCur + 6) = iVar4;
    *(short *)((int)lpmpCur + 10) = cb;
    uVar6 = PUBLIC::_abs();
    PUBLIC::__fmemmove((int)lpmpCur + 0xc,lpmpCur._2_2_,(int)lpbMsg,lpbMsg._2_2_,uVar6);
    _DATA::iMsgSendCur = _DATA::iMsgSendCur + dInc;
    if (_DATA::iMsgSendCur < 0) {
      _DATA::iMsgSendCur = 0;
    }
    sVar3 = 1;
  }
  return sVar3;
}



// ======================================================================
// Function: FLoadGame
// Address: 1070:0810
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: FLoadLogFile
// Address: 1048:c7a2
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

short __cdecl16far PLANET::FLoadLogFile(char *pszLog)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined2 uVar4;
  short sVar5;
  undefined2 *puVar6;
  undefined2 uVar7;
  bool bVar8;
  byte *pbVar9;
  void *pvVar10;
  undefined2 uVar11;
  short cSkip;
  ushort hrsrc;
  MSGPLR *lpmp;
  short iCur;
  short cbLog;
  short fRet;
  short env;
  short *penvMemSav;
  ushort hres;
  
  _DATA::imemLogCur = 0;
  _DATA::imemLogPrev = -1;
  penvMemSav = _penvMem;
  _penvMem = &env;
  iVar3 = PUBLIC::__setjmp(&env);
  if (iVar3 != 0) {
    _penvMem = penvMemSav;
    if (((int)_DATA::vlpMemStream == 0) && (_DATA::vlpMemStream._2_2_ == 0)) {
      if (_DATA::hf != -1) {
        IO::StreamClose();
        return 0;
      }
      return 1;
    }
    GLOBALUNLOCK(0x1118,hres);
    FREERESOURCE(0x14f8,hres);
    return 0;
  }
  if (((((uint)_DATA::game.wCrap >> 3 & 1) == 0) || (_DATA::idPlayer != 0)) ||
     (((uint)_DATA::gd.flags1 >> 1 & 1) == 0)) {
PLANET_StrOpen:
    IO::StreamOpen(pszLog,0x4020);
LAB_1048_c944:
    IO::ReadRt();
    if ((((int)_DATA::game.lid == DAT_1120_4b9c) && (_DATA::game.lid._2_2_ == DAT_1120_4b9e)) &&
       ((uint)_DATA::game.turn <= DAT_1120_4ba2)) {
      if (DAT_1120_4ba2 == _DATA::game.turn) {
        if (DAT_1120_4ba6 >> 0xd == ((uint)_DATA::game.wCrap >> 9 & 7)) {
          _DATA::wVersFile = DAT_1120_4ba0;
          _DATA::gd.flags2 = _DATA::gd.flags2 & 0xfffbU | (DAT_1120_4ba6 >> 0xc & 1) << 2;
          if (((uint)_DATA::gd.flags1 >> 1 & 1) != 0) {
            *(uint *)(_DATA::idPlayer * 0xc0 + 0x59f6) =
                 *(uint *)(_DATA::idPlayer * 0xc0 + 0x59f6) & 0xfffd |
                 (DAT_1120_4ba6 >> 0xc & 1) << 1;
          }
          IO::ReadRt();
          iVar3 = c_common::rgbCur;
          if (((((uint)_DATA::gd.flags1 >> 1 & 1) != 0) &&
              (((int)_DATA::vrgts != 0 || (_DATA::vrgts._2_2_ != 0)))) &&
             (PUBLIC::__fmemset((int)_DATA::vrgts + _DATA::idPlayer * 0x10,_DATA::vrgts._2_2_,0,0x10
                               ), iVar2 = DAT_1120_4b9c, iVar1 = _DATA::vrgts._2_2_,
             (c_common::hdrCur & 0x3ff) == 0x11)) {
            puVar6 = (undefined2 *)((int)_DATA::vrgts + _DATA::idPlayer * 0x10);
            *puVar6 = DAT_1120_4b9a;
            puVar6[1] = iVar2;
            PUBLIC::__fmemcpy((int)_DATA::vrgts + _DATA::idPlayer * 0x10 + 4,_DATA::vrgts._2_2_,
                              (int)&DAT_1120_4b9e,0x1120,0xb);
          }
          for (iCur = 0; iCur < iVar3; iCur = iCur + (c_common::hdrCur & 0x3ff) + 2) {
            IO::ReadRt();
            PUBLIC::__fmemmove((int)_DATA::lpLog + iCur,_DATA::lpLog._2_2_,(int)&c_common::hdrCur,
                               0x1120,2);
            PUBLIC::__fmemmove((int)_DATA::lpLog + iCur + 2,_DATA::lpLog._2_2_,
                               (int)&c_common::rgbCur,0x1120,c_common::hdrCur & 0x3ff);
          }
          IO::ReadRt();
          lpmp = (MSGPLR *)&_DATA::vlpmsgplrOut;
          while( true ) {
            uVar7 = (undefined2)((ulong)lpmp >> 0x10);
            if ((*(int *)&lpmp->lpmsgplrNext == 0) && (*(int *)((int)lpmp + 2) == 0)) break;
            lpmp = (MSGPLR *)
                   CONCAT22(*(undefined2 *)((int)lpmp + 2),*(undefined2 *)&lpmp->lpmsgplrNext);
          }
          while (c_common::hdrCur >> 10 == 0x28) {
            pvVar10 = MEMORY::LpAlloc(c_common::hdrCur & 0x3ff,8);
            uVar7 = (undefined2)((ulong)lpmp >> 0x10);
            *(int *)&lpmp->lpmsgplrNext = (int)pvVar10;
            *(undefined2 *)((int)lpmp + 2) = (int)((ulong)pvVar10 >> 0x10);
            iVar1 = *(int *)&lpmp->lpmsgplrNext;
            uVar7 = *(undefined2 *)((int)lpmp + 2);
            lpmp = (MSGPLR *)CONCAT22(uVar7,iVar1);
            PUBLIC::__fmemcpy(iVar1,uVar7,(int)&c_common::rgbCur,0x1120,c_common::hdrCur & 0x3ff);
            *(undefined2 *)&lpmp->lpmsgplrNext = 0;
            *(undefined2 *)(iVar1 + 2) = 0;
            _DATA::vcmsgplrOut = _DATA::vcmsgplrOut + 1;
            IO::ReadRt();
          }
          bVar8 = c_common::hdrCur >> 10 == 0;
          if (bVar8) {
            _DATA::imemLogCur = iVar3;
          }
          fRet = (short)bVar8;
          if (((int)_DATA::vlpMemStream == 0) && (_DATA::vlpMemStream._2_2_ == 0)) {
            IO::StreamClose();
          }
          else {
            GLOBALUNLOCK(0x1070,hres);
            FREERESOURCE(0x14f8,hres);
            _DATA::vlpMemStream = (byte *)0x0;
          }
          _penvMem = penvMemSav;
          DirtyGame(0);
          return fRet;
        }
        IO::FileError(0x1d);
      }
      else {
        IO::FileError(0x1e);
      }
    }
    if (((int)_DATA::vlpMemStream == 0) && (_DATA::vlpMemStream._2_2_ == 0)) {
      IO::StreamClose();
    }
    else {
      _DATA::vlpMemStream = (byte *)0x0;
      GLOBALUNLOCK(0x1070,hres);
      FREERESOURCE(0x14f8,hres);
    }
    _penvMem = penvMemSav;
    sVar5 = 1;
  }
  else {
    cSkip = _DATA::game.turn;
    uVar11 = c_common::hInst;
    uVar4 = FINDRESOURCE(0x1118,10000,0,0x2711,0);
    uVar7 = c_common::hInst;
    hres = LOADRESOURCE(0x14f8,uVar4);
    if (hres != 0) {
      pbVar9 = (byte *)LOCKRESOURCE(0x14f8,hres,uVar7,uVar11);
      if (pbVar9 != (byte *)0x0) {
        if ((uint)*pbVar9 <= (uint)_DATA::game.turn) {
          _DATA::vlpMemStream = (byte *)0x0;
          GLOBALUNLOCK(0x14f8,hres);
          FREERESOURCE(0x14f8,hres);
          goto PLANET_StrOpen;
        }
        _DATA::vlpMemStream = (byte *)CONCAT22((int)((ulong)pbVar9 >> 0x10),(int)pbVar9 + 1);
        while (iVar3 = cSkip + -1, cSkip != 0) {
          do {
            _DATA::vlpMemStream =
                 (byte *)CONCAT22(_DATA::vlpMemStream._2_2_,
                                  (int)_DATA::vlpMemStream +
                                  (*(uint *)_DATA::vlpMemStream & 0x3ff) + 2);
            cSkip = iVar3;
          } while (*(uint *)_DATA::vlpMemStream >> 10 != 8);
        }
        goto LAB_1048_c944;
      }
      _DATA::vlpMemStream = (byte *)0x0;
    }
    _penvMem = penvMemSav;
    sVar5 = 0;
  }
  return sVar5;
}



// ======================================================================
// Function: FLookupPart
// Address: 1008:524e
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10085eaf) */
/* WARNING: Removing unreachable block (ram,0x10085fdb) */
/* WARNING: Removing unreachable block (ram,0x10085997) */
/* WARNING: Removing unreachable block (ram,0x10085f02) */

short __cdecl16far PARTS::FLookupPart(PART *ppart)

{
  int iVar1;
  uint uVar2;
  TERRA *pTVar3;
  short sVar4;
  short sVar5;
  HS hs;
  short raMajor;
  
  sVar4 = RACE::GetRaceStat((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),0xe);
  iVar1 = (ppart->hs).grhst;
  uVar2 = (ppart->hs).flags2;
  if (iVar1 == 1) {
    if (0xf < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x4e;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if (((uVar2 & 0xff) == 0) && (sVar4 != 0)) {
        return -1;
      }
      if ((((10 < (uVar2 & 0xff)) && ((uVar2 & 0xff) < 0x10)) || ((uVar2 & 0xff) == 10)) &&
         (sVar4 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),7),
         sVar4 != 0)) {
        return -1;
      }
      if ((((uVar2 & 0xff) == 0xf) || ((uVar2 & 0xff) == 2)) &&
         (sVar4 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),0),
         sVar4 == 0)) {
        return -1;
      }
      if (((uVar2 & 0xff) == 7) &&
         (sVar4 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),7),
         sVar4 == 0)) {
        return -1;
      }
      sVar4 = RESEARCH::FShouldPartBeHidden(ppart);
      if (sVar4 != 0) {
        return -1;
      }
    }
  }
  else if (iVar1 == 2) {
    if (0xf < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x38 + 0x768;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if (((((uVar2 & 0xff) == 7) || ((uVar2 & 0xff) == 8)) || ((uVar2 & 0xff) == 0xc)) &&
         (sVar5 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),10),
         sVar5 != 0)) {
        return -1;
      }
      if (((((uVar2 & 0xff) == 6) || ((uVar2 & 0xff) == 5)) || ((uVar2 & 0xff) == 0xe)) &&
         (sVar4 != 1)) {
        return -1;
      }
    }
  }
  else if (iVar1 == 4) {
    if (9 < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x36 + 0xae8;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (((uVar2 & 0xff) == 4) && (sVar4 != 1)) {
      return -1;
    }
    if (((uVar2 & 0xff) == 3) && (sVar4 != 4)) {
      return -1;
    }
    sVar4 = RESEARCH::FShouldPartBeHidden(ppart);
    if (sVar4 != 0) {
      return -1;
    }
  }
  else if (iVar1 == 8) {
    if (0xb < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x36 + 0x4e0;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (((uVar2 & 0xff) == 7) && (sVar4 != 1)) {
      return -1;
    }
    if (((uVar2 & 0xff) == 6) && (sVar4 != 4)) {
      return -1;
    }
    sVar4 = RESEARCH::FShouldPartBeHidden(ppart);
    if (sVar4 != 0) {
      return -1;
    }
  }
  else if (iVar1 == 0x10) {
    if (0x17 < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x3c + 0x2450;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (((uVar2 & 0xff) == 2) && (sVar4 != 4)) {
      return -1;
    }
    if ((((uVar2 & 0xff) == 0x10) || ((uVar2 & 0xff) == 0xe)) && (sVar4 != 2)) {
      return -1;
    }
    sVar4 = RESEARCH::FShouldPartBeHidden(ppart);
    if (sVar4 != 0) {
      return -1;
    }
  }
  else if (iVar1 == 0x20) {
    if (0xb < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra =
         (int)s_M6108__MATH___floating_point_err_1120_2153 + 0x2d + (uVar2 & 0xff) * 0x3c;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if ((_DATA::idPlayer != -1) && (sVar4 = RESEARCH::FShouldPartBeHidden(ppart), sVar4 != 0)) {
      return -1;
    }
  }
  else if (iVar1 == 0x40) {
    if (0xe < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x3a + 0x1e1a;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if (((9 < (uVar2 & 0xff)) && ((uVar2 & 0xff) < 0xf)) && (sVar4 == 4)) {
        return -1;
      }
      if (((uVar2 & 0xff) == 9) && (sVar4 != 3)) {
        return -1;
      }
      sVar4 = RESEARCH::FShouldPartBeHidden(ppart);
      if (sVar4 != 0) {
        return -1;
      }
    }
  }
  else if (iVar1 == 0x80) {
    if (7 < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x36 + 0x1508;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if ((((((uVar2 & 0xff) == 2) || ((uVar2 & 0xff) == 3)) || ((uVar2 & 0xff) == 4)) ||
          (((uVar2 & 0xff) == 0 || ((uVar2 & 0xff) == 5)))) &&
         (sVar5 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),9),
         sVar5 != 0)) {
        return -1;
      }
      if ((((uVar2 & 0xff) == 0) || ((uVar2 & 0xff) == 5)) &&
         (sVar5 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),2),
         sVar5 == 0)) {
        return -1;
      }
      if (((uVar2 & 0xff) == 7) && (sVar4 != 3)) {
        return -1;
      }
      sVar4 = RESEARCH::FShouldPartBeHidden(ppart);
      if (sVar4 != 0) {
        return -1;
      }
    }
  }
  else if (iVar1 == 0x100) {
    if (9 < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (int)&_DATA::ptStickyRaceDlg + (uVar2 & 0xff) * 0x36;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if (((((uVar2 & 0xff) == 0) || ((uVar2 & 0xff) == 2)) ||
          (((uVar2 & 0xff) == 3 ||
           (((((uVar2 & 0xff) == 4 || ((uVar2 & 0xff) == 5)) || ((uVar2 & 0xff) == 6)) ||
            (((uVar2 & 0xff) == 8 || ((uVar2 & 0xff) == 9)))))))) && (sVar4 != 5)) {
        return -1;
      }
      if ((((uVar2 & 0xff) == 7) && (sVar4 != 5)) && (sVar4 != 4)) {
        return -1;
      }
      if (((uVar2 & 0xff) == 1) && (sVar4 == 2)) {
        return -1;
      }
    }
  }
  else if (iVar1 == 0x200) {
    if (0xf < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x38 + 0x4d8a;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if (((uVar2 & 0xff) < 7) || (0xf < (uVar2 & 0xff))) {
        if ((uVar2 & 0xff) < 7) {
          if ((sVar4 != 7) && (((uVar2 & 0xff) == 1 || (3 < (uVar2 & 0xff))))) {
            return -1;
          }
          if (sVar4 == 0) {
            return -1;
          }
        }
      }
      else if ((((uVar2 & 0xff) != 9) && ((uVar2 & 0xff) != 0xc)) && (sVar4 != 6)) {
        return -1;
      }
    }
  }
  else if (iVar1 == 0x400) {
    if (4 < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x8f + 0x4872;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if ((((uVar2 & 0xff) == 1) || ((uVar2 & 0xff) == 3)) &&
         (sVar5 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),3),
         sVar5 == 0)) {
        return -1;
      }
      if (((uVar2 & 0xff) == 4) && (sVar4 != 8)) {
        return -1;
      }
    }
  }
  else if (iVar1 == 0x800) {
    if (0x10 < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x36 + 0xd04;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      sVar5 = RESEARCH::FShouldPartBeHidden(ppart);
      if (sVar5 != 0) {
        return -1;
      }
      switch(uVar2 & 0xff) {
      case 0:
      case 3:
        if (sVar4 != 1) {
          return -1;
        }
        break;
      case 8:
      case 0xb:
      case 0xf:
        if (sVar4 != 4) {
          return -1;
        }
        break;
      case 0xd:
        if (sVar4 != 0) {
          return -1;
        }
        break;
      case 0xe:
        if (sVar4 != 5) {
          return -1;
        }
        break;
      case 0x10:
        if (sVar4 != 7) {
          return -1;
        }
      }
    }
  }
  else if (iVar1 == 0x1000) {
    if (10 < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x36 + 0x109a;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      sVar5 = RESEARCH::FShouldPartBeHidden(ppart);
      if (sVar5 != 0) {
        return -1;
      }
      if (((uVar2 & 0xff) == 0) && (sVar4 == 8)) {
        return -1;
      }
      if (((uVar2 & 0xff) == 1) && (sVar4 != 8)) {
        return -1;
      }
    }
  }
  else if (iVar1 == 0x2000) {
    if (0x13 < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x36 + 0x19e2;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (((_DATA::idPlayer != -1) && ((uVar2 & 0xff) < 8)) &&
       (sVar4 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),1),
       sVar4 == 0)) {
      return -1;
    }
  }
  else if (iVar1 == 0x4000) {
    if (0x1f < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (uVar2 & 0xff) * 0x8f + 0x29f0;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if ((((uVar2 & 0xff) == 0xe) || ((uVar2 & 0xff) == 0x1f)) && (sVar4 != 0)) {
        return -1;
      }
      if ((((uVar2 & 0xff) == 0x19) || ((uVar2 & 0xff) == 3)) && (sVar4 != 4)) {
        return -1;
      }
      if (((((uVar2 & 0xff) == 0x16) || ((uVar2 & 0xff) == 0x17)) ||
          (((uVar2 & 0xff) == 0x14 || ((uVar2 & 0xff) == 0x18)))) &&
         (sVar5 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),9),
         sVar5 != 0)) {
        return -1;
      }
      if (((((uVar2 & 0xff) == 0x14) || ((uVar2 & 0xff) == 0x16)) || ((uVar2 & 0xff) == 0x18)) &&
         (sVar5 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),2),
         sVar5 == 0)) {
        return -1;
      }
      if ((((uVar2 & 0xff) == 10) || ((uVar2 & 0xff) == 8)) && (sVar4 != 2)) {
        return -1;
      }
      if (((uVar2 & 0xff) == 0xc) && (sVar4 != 1)) {
        return -1;
      }
      if (((uVar2 & 0xff) == 0x12) && (sVar4 != 1)) {
        return -1;
      }
      if ((((uVar2 & 0xff) == 0x1b) || ((uVar2 & 0xff) == 0x1c)) && (sVar4 != 5)) {
        return -1;
      }
      sVar4 = RESEARCH::FShouldPartBeHidden(ppart);
      if (sVar4 != 0) {
        return -1;
      }
    }
  }
  else {
    if (iVar1 != -0x8000) {
      return 0;
    }
    if (0xe < (uVar2 & 0xff)) {
      return 0;
    }
    *(uint *)&ppart->pterra = (int)&_DATA::hwndZipOrderDlg + (uVar2 & 0xff) * 0x36;
    *(undefined2 *)((int)&ppart->pterra + 2) = 0x10e0;
    if (_DATA::idPlayer != -1) {
      if ((((uVar2 & 0xff) < 9) && (pTVar3 = ppart->pterra, *(int *)((int)pTVar3 + 0x34) < 0)) &&
         (sVar5 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),10),
         sVar5 != 0)) {
        return -1;
      }
      if (((uVar2 & 0xff) < 9) && (sVar4 == 8)) {
        return -1;
      }
      if (((8 < (uVar2 & 0xff)) && ((uVar2 & 0xff) < 0xe)) && (sVar4 == 8)) {
        return -1;
      }
      if (((10 < (uVar2 & 0xff)) && ((uVar2 & 0xff) < 0xe)) && (sVar4 == 2)) {
        return -1;
      }
      sVar4 = RESEARCH::FShouldPartBeHidden(ppart);
      if (sVar4 != 0) {
        return -1;
      }
    }
  }
  sVar4 = TechStatus((char *)CONCAT22(*(undefined2 *)((int)&ppart->pterra + 2),
                                      *(int *)&ppart->pterra + 2));
  return sVar4;
}



// ======================================================================
// Function: FOpenFile
// Address: 1070:4ac2
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

short __cdecl16far IO::FOpenFile(ushort dt,short iPlayer,short md)

{
  undefined2 *puVar1;
  RTBOF *pRVar2;
  uint dt_00;
  int iVar3;
  short sVar4;
  char *sz;
  undefined2 *puVar5;
  RTBOF *pRVar6;
  undefined2 uVar7;
  undefined2 unaff_SS;
  short env;
  short *penvMemSav;
  short fSilentSav;
  short fRewind;
  short fCheckMulti;
  short ids;
  RTBOF rtbof;
  
  fSilentSav = _DATA::fFileErrSilent;
  ids = 4;
  _DATA::gd.flags2 = _DATA::gd.flags2 & 0xff7f;
  fCheckMulti = dt & 0x2000;
  fRewind = dt & 0x1000;
  dt_00 = dt & 0xff;
  SetSzWorkFromDt(dt_00,iPlayer);
  penvMemSav = _penvMem;
  _penvMem = &env;
  iVar3 = PUBLIC::__setjmp(&env);
  if (iVar3 != 0) {
    _DATA::fFileErrSilent = fSilentSav;
    FileError(ids);
    StreamClose();
    _penvMem = penvMemSav;
    return 0;
  }
  _DATA::fFileErrSilent = 1;
  StreamOpen((char *)&c_common::szWork,md);
  _DATA::fFileErrSilent = fSilentSav;
  ids = 3;
  uVar7 = 0x1070;
  ReadRt();
  if ((((c_common::hdrCur >> 10 == 8) && (DAT_1120_4ba0 >> 0xc == 2)) &&
      (0x30 < (DAT_1120_4ba0 >> 5 & 0x7f))) && ((DAT_1120_4ba0 >> 5 & 0x7f) < 0x54)) {
    puVar5 = (undefined2 *)&c_common::rgbCur;
    pRVar6 = &rtbof;
    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {
      pRVar2 = pRVar6;
      pRVar6 = (RTBOF *)(pRVar6->rgid + 2);
      puVar1 = puVar5;
      puVar5 = puVar5 + 1;
      *(undefined2 *)pRVar2->rgid = *puVar1;
    }
    if ((rtbof.flags7 << 0xb) >> 0xb == iPlayer) {
      if (((int)_DATA::game.lid == 0) && (_DATA::game.lid._2_2_ == 0)) goto LAB_1070_4ebd;
      if (((int)rtbof.lidGame == (int)_DATA::game.lid) &&
         (rtbof.lidGame._2_2_ == _DATA::game.lid._2_2_)) {
        if (dt_00 == 4) {
          if ((rtbof.flags7 << 0xb) >> 0xb == iPlayer) goto LAB_1070_4ebd;
        }
        else {
          if ((fCheckMulti != 0) && (((uint)rtbof.flags8 >> 10 & 1) != 0)) {
            PUBLIC::__lseek(0x1070,_DATA::hf,0xfffc,0xffff,2);
            ReadRt();
            if ((c_common::hdrCur >> 10 != 0) && ((c_common::hdrCur & 0x3ff) != 2))
            goto IO_LBadFile_2;
            rtbof.turn = c_common::rgbCur;
            _DATA::game.wCrap = _DATA::game.wCrap & 0xf1ffU | ((uint)rtbof.flags8 >> 0xd) << 9;
          }
          uVar7 = 0x1070;
          if ((_DATA::game.turn == 0) && (rtbof.turn != 0)) {
            _DATA::game.turn = rtbof.turn;
            _DATA::game.wCrap = _DATA::game.wCrap & 0xf1ffU | ((uint)rtbof.flags8 >> 0xd) << 9;
LAB_1070_4ebd:
            if (fRewind != 0) {
              PUBLIC::__lseek(uVar7,_DATA::hf,0,0,0);
              ReadRt();
            }
            _penvMem = penvMemSav;
            _DATA::wVersFile = rtbof.wVersion;
            _DATA::gd.flags2 = _DATA::gd.flags2 & 0xfffbU | ((uint)rtbof.flags8 >> 0xc & 1) << 2;
            return 1;
          }
          if (rtbof.turn == _DATA::game.turn) {
            if (((dt_00 == 2) && (((uint)_DATA::gd.flags1 >> 3 & 1) == 0)) &&
               (((uint)rtbof.flags8 >> 9 & 1) != 0)) {
              sVar4 = (int)s_M6102__MATH___floating_point_err_1120_2022 + 2;
              sz = MSG::PszFormatIds(0x15,(short *)0x0);
              uVar7 = 0x1040;
              sVar4 = UTILGEN::AlertSz(sz,sVar4);
              if (sVar4 == 6) goto LAB_1070_4ebd;
            }
            else if (((((uint)rtbof.flags8 >> 8 & 1) == 0) &&
                     (((uint)_DATA::gd.flags1 >> 1 & 1) != 0)) &&
                    (((uint)_DATA::gd.flags1 >> 2 & 1) == 0)) {
              _DATA::gd.flags2 = _DATA::gd.flags2 & 0xff7fU | 0x80;
            }
            else {
              if (((dt_00 != 1) || (((uint)_DATA::game.wCrap >> 3 & 1) != 0)) ||
                 ((uint)rtbof.flags8 >> 0xd == ((uint)_DATA::game.wCrap >> 9 & 7)))
              goto LAB_1070_4ebd;
              FileError(0x1d);
            }
          }
          else {
            FileError(0x1c);
          }
        }
      }
      else {
        FileError(0x1d);
      }
    }
    else {
      FileError(3);
    }
  }
  else if (c_common::hdrCur >> 10 == 8) {
    if ((DAT_1120_4ba0 >> 0xc < 3) &&
       ((DAT_1120_4ba0 >> 0xc != 2 || ((DAT_1120_4ba0 >> 5 & 0x7f) < 0x55)))) {
      sVar4 = 0x4d3;
    }
    else {
      sVar4 = 0x2ca;
    }
    FileError(sVar4);
  }
  else {
    FileError(0xd);
  }
IO_LBadFile_2:
  StreamClose();
  _penvMem = penvMemSav;
  return 0;
}



// ======================================================================
// Function: FReadFleet
// Address: 1070:3a4c
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: FReadPlanet
// Address: 1070:3206
// ======================================================================


short __cdecl16far IO::FReadPlanet(short iPlayer,PLANET *lppl,short fHistory,short fPreInited)

{
  uint uVar1;
  undefined2 uVar2;
  bool bVar3;
  byte bVar4;
  uint uVar5;
  short sVar6;
  uint uVar7;
  uint uVar8;
  undefined2 *puVar9;
  uint *puVar10;
  int p2;
  short pct;
  short pctOpt;
  short idm;
  byte *pb;
  short i;
  byte bMask;
  short fRouting;
  short fFirstYear;
  
  bVar3 = false;
  if (fPreInited == 0) {
    PUBLIC::__fmemset(lppl,0,0x38);
  }
  if ((fHistory == 0) && (iPlayer != -1)) {
    if (fPreInited == 0) {
      bVar3 = true;
      *(uint *)((int)lppl + 4) = *(uint *)((int)lppl + 4) & 0xf7ff | 0x800;
    }
    else if ((*(uint *)((int)lppl + 4) >> 0xb & 1) != 0) {
      if (*(int *)((int)lppl + 0x32) == _DATA::game.turn) {
        bVar3 = true;
      }
      else {
        *(uint *)((int)lppl + 4) = *(uint *)((int)lppl + 4) & 0xf7ff;
      }
    }
  }
  else {
    *(uint *)((int)lppl + 4) = *(uint *)((int)lppl + 4) & 0xf7ff | (DAT_1120_4b9a >> 0xf) << 0xb;
  }
  lppl->id = (c_common::rgbCur << 5) >> 5;
  *(int *)((int)lppl + 2) = c_common::rgbCur >> 0xb;
  if ((*(uint *)((int)lppl + 4) & 0xff) < (DAT_1120_4b9a & 0x7f)) {
    *(uint *)((int)lppl + 4) = *(uint *)((int)lppl + 4) & 0xff00 | DAT_1120_4b9a & 0x7f;
  }
  *(uint *)((int)lppl + 4) = *(uint *)((int)lppl + 4) & 0xfeff | (DAT_1120_4b9a >> 8 & 1) << 8;
  *(uint *)((int)lppl + 4) = *(uint *)((int)lppl + 4) & 0xfdff | (DAT_1120_4b9a >> 9 & 1) << 9;
  *(uint *)((int)lppl + 4) = *(uint *)((int)lppl + 4) & 0xfbff | (DAT_1120_4b9a >> 7 & 1) << 10;
  uVar5 = DAT_1120_4b9a >> 0xe;
  if (((*(uint *)((int)lppl + 4) >> 9 & 1) != 0) && (*(int *)((int)lppl + 2) == -1)) {
    *(uint *)((int)lppl + 4) = *(uint *)((int)lppl + 4) & 0xfdff;
  }
  if (fHistory == 0) {
    *(short *)((int)lppl + 0x32) = _DATA::game.turn;
  }
  pb = (byte *)&DAT_1120_4b9c;
  if (2 < (DAT_1120_4b9a & 0x7f)) {
    bMask = (byte)DAT_1120_4b9c;
    pb = (byte *)((int)&DAT_1120_4b9c + 1);
    for (i = 0; i < 3; i = i + 1) {
      if ((bMask & 3) == 0) {
        *(undefined *)((int)lppl + 6 + i) = 0;
      }
      else {
        if ((bMask & 3) != 1) {
          return 0;
        }
        *(byte *)((int)lppl + 6 + i) = *pb;
        pb = pb + 1;
      }
      bMask = (byte)((int)(uint)bMask >> 2);
    }
    for (i = 0; i < 3; i = i + 1) {
      *(byte *)((int)lppl + 9 + i) = *pb;
      pb = pb + 1;
    }
    for (i = 0; i < 3; i = i + 1) {
      if (100 < *pb) {
        return 0;
      }
      bVar4 = *pb;
      *(byte *)((int)lppl + 0xf + i) = bVar4;
      *(byte *)((int)lppl + 0xc + i) = bVar4;
      pb = pb + 1;
    }
    if ((DAT_1120_4b9a >> 10 & 1) != 0) {
      for (i = 0; i < 3; i = i + 1) {
        if (100 < *pb) {
          return 0;
        }
        *(byte *)((int)lppl + 0xf + i) = *pb;
        pb = pb + 1;
      }
    }
    if (c_common::rgbCur >> 0xb != -1) {
      *(undefined2 *)((int)lppl + 0x12) = *(undefined2 *)pb;
      pb = pb + 2;
    }
    if (3 < (*(uint *)((int)lppl + 4) & 0xff)) {
      if ((DAT_1120_4b9a >> 0xd & 1) != 0) {
        bMask = *pb;
        pb = pb + 1;
        for (i = 0; i < 4; i = i + 1) {
          bVar4 = bMask & 3;
          if ((bMask & 3) == 0) {
            puVar9 = (undefined2 *)((int)lppl + 0x1c + i * 4);
            *puVar9 = 0;
            puVar9[1] = 0;
          }
          else if (bVar4 == 1) {
            puVar10 = (uint *)((int)lppl + 0x1c + i * 4);
            *puVar10 = (uint)*pb;
            puVar10[1] = 0;
            pb = pb + 1;
          }
          else if (bVar4 == 2) {
            puVar9 = (undefined2 *)((int)lppl + 0x1c + i * 4);
            *puVar9 = *(undefined2 *)pb;
            puVar9[1] = 0;
            pb = pb + 2;
          }
          else if (bVar4 == 3) {
            uVar2 = *(undefined2 *)(pb + 2);
            puVar9 = (undefined2 *)((int)lppl + 0x1c + i * 4);
            *puVar9 = *(undefined2 *)pb;
            puVar9[1] = uVar2;
            pb = pb + 4;
          }
          bMask = (byte)((int)(uint)bMask >> 2);
        }
      }
      if (c_common::hdrCur >> 10 != 0xe) {
        if ((DAT_1120_4b9a >> 0xb & 1) == 0) {
          uVar8 = 0;
          uVar7 = PUBLIC::__aFlshl();
          uVar1 = *(uint *)((int)lppl + 0x1a);
          *(uint *)((int)lppl + 0x18) = *(uint *)((int)lppl + 0x18) | uVar7;
          *(uint *)((int)lppl + 0x1a) = uVar1 & 0xffbf | uVar8;
          uVar1 = *(uint *)((int)lppl + 0x1a);
          *(uint *)((int)lppl + 0x18) = *(uint *)((int)lppl + 0x18) & 0xfff | 0xf000;
          *(uint *)((int)lppl + 0x1a) = uVar1 & 0xfffe | 1;
          uVar2 = *(undefined2 *)((int)lppl + 0x1a);
          *(uint *)((int)lppl + 0x18) = *(uint *)((int)lppl + 0x18) & 0xf000;
          *(undefined2 *)((int)lppl + 0x1a) = uVar2;
        }
        else {
          PUBLIC::__fmemmove((int)lppl + 0x14,lppl._2_2_,pb,0x1120,8);
          pb = pb + 8;
        }
        if (*(int *)((int)lppl + 2) != -1) {
          if ((*(uint *)((int)lppl + 4) >> 9 & 1) != 0) {
            uVar2 = *(undefined2 *)(pb + 2);
            *(undefined2 *)((int)lppl + 0x2c) = *(undefined2 *)pb;
            *(undefined2 *)((int)lppl + 0x2e) = uVar2;
            *(uint *)((int)lppl + 0x2e) = *(uint *)((int)lppl + 0x2e) & 0xbfff;
            pb = pb + 4;
          }
          if ((uVar5 & 1) != 0) {
            *(undefined2 *)((int)lppl + 0x30) = *(undefined2 *)pb;
          }
        }
        return 1;
      }
    }
  }
  if ((*(uint *)((int)lppl + 4) >> 9 & 1) != 0) {
    *(uint *)((int)lppl + 0x2c) = *(uint *)((int)lppl + 0x2c) & 0xfff0 | *pb & 0xf;
    pb = pb + 1;
  }
  if (fHistory == 0) {
    if (bVar3) {
      if (*(int *)((int)lppl + 2) == -1) {
        if ((*(uint *)((int)lppl + 4) & 0xff) < 2) {
          MSG::FSendPlrMsg2XGen(0,0xad,lppl->id,lppl->id,0);
        }
        else {
          sVar6 = RACE::GetRaceStat((PLAYER *)((int)&c_common::rgplr + iPlayer * 0xc0),0xe);
          if (sVar6 == 3) {
            sVar6 = PLANET::PctPlanetOptValue(lppl,iPlayer);
            MSG::FSendPlrMsg2XGen(0,0x15d,lppl->id,lppl->id,sVar6);
          }
          else {
            sVar6 = PLANET::PctPlanetDesirability(lppl,iPlayer);
            if (sVar6 < 1) {
              sVar6 = PLANET::PctPlanetOptValue(lppl,iPlayer);
              if (sVar6 < 1) {
                idm = 0xab;
              }
              else {
                RACE::PctTrueMaxGrowth(iPlayer);
                idm = 0xae;
              }
            }
            else {
              RACE::PctTrueMaxGrowth(iPlayer);
              idm = 0xac;
            }
            p2 = lppl->id;
            sVar6 = PUBLIC::_abs();
            MSG::FSendPlrMsg2XGen(0,idm,lppl->id,sVar6,p2);
          }
        }
      }
      else {
        MSG::FSendPlrMsg2XGen(0,0xaa,lppl->id,lppl->id,*(uint *)((int)lppl + 2) | 0x30);
      }
    }
  }
  else {
    *(undefined2 *)((int)lppl + 0x32) = *(undefined2 *)pb;
  }
  return 1;
}



// ======================================================================
// Function: FReadShDef
// Address: 1070:0006
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

short __cdecl16far IO::FReadShDef(RTSHDEF *lprt,SHDEF *lpshdef,short iplrLoad)

{
  SHDEF *pSVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  short *psVar5;
  SHDEF *pSVar6;
  int *piVar7;
  undefined2 uVar8;
  undefined2 unaff_SS;
  HULDEF *pHVar9;
  PART part;
  HUL *lphul;
  short c;
  ulong wt;
  HUL *lphulBase;
  short fOkay;
  short cch;
  short ishdef;
  byte *lpb;
  SHDEF shdef;
  char szTemp;
  
  PUBLIC::_memset(&shdef,0,0x93);
  uVar8 = (undefined2)((ulong)lprt >> 0x10);
  iVar4 = (int)lprt;
  shdef.hul.ihuldef = (int)*(byte *)(iVar4 + 2);
  shdef.wFlags = lprt->wFlags;
  shdef.hul.chs = *(byte *)(iVar4 + 6);
  shdef.hul.ibmp = (int)*(byte *)(iVar4 + 3);
  if ((shdef.wFlags & 0xffU) == 7) {
    shdef.hul.dp = *(short *)(iVar4 + 4);
    shdef.turn = *(short *)(iVar4 + 7);
    shdef.cBuilt = *(int *)(iVar4 + 9);
    shdef._129_2_ = *(undefined2 *)(iVar4 + 0xb);
    shdef.cExist = *(int *)(iVar4 + 0xd);
    shdef._133_2_ = *(undefined2 *)(iVar4 + 0xf);
    lpb = (byte *)CONCAT22(uVar8,iVar4 + 0x11);
    PUBLIC::__fmemmove();
    lpb = (byte *)CONCAT22(lpb._2_2_,(int)lpb + (uint)*(byte *)(iVar4 + 6) * 4);
  }
  else {
    shdef.hul.wtEmpty = *(short *)(iVar4 + 4);
    lpb = (byte *)CONCAT22(uVar8,iVar4 + 6);
  }
  pHVar9 = PARTS::LphuldefFromId(shdef.hul.ihuldef);
  fOkay = *(uint *)((int)pHVar9 + 0x32);
  if ((shdef.hul.ibmp < fOkay) || ((int)(fOkay + 4U) <= shdef.hul.ibmp)) {
    shdef.hul.ibmp = shdef.hul.ibmp & 3U | fOkay;
  }
  cch = (short)*lpb;
  lpb = (byte *)CONCAT22(lpb._2_2_,(int)lpb + 1);
  if (cch == 0) {
    PUBLIC::__fstrcpy(shdef.hul.szClass);
  }
  else {
    fOkay = 0x20;
    if (0x20 < (uint)cch) {
      return 0;
    }
    PUBLIC::__fmemmove();
    UTILGEN::FDecompressUserString
              ((char *)CONCAT22(unaff_SS,&szTemp),cch,(char *)CONCAT22(unaff_SS,shdef.hul.szClass),
               &fOkay);
  }
  ishdef = (uint)shdef.wFlags >> 10 & 0x1f;
  if (0xf < (uint)ishdef) {
    ishdef = ishdef - 0x10;
  }
  if ((((shdef.wFlags & 0xffU) == 7) ||
      ((*(uint *)((int)lpshdef + ishdef * 0x93 + 0x7b) >> 9 & 1) != 0)) ||
     ((*(uint *)((int)lpshdef + ishdef * 0x93 + 0x7b) & 0xff) < 7)) {
    piVar7 = (int *)((int)lpshdef + ishdef * 0x93);
    pSVar6 = &shdef;
    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {
      piVar2 = piVar7;
      piVar7 = piVar7 + 1;
      pSVar1 = pSVar6;
      pSVar6 = (SHDEF *)(pSVar6->hul).rgTech;
      *piVar2 = (pSVar1->hul).ihuldef;
    }
    *(undefined *)piVar7 = *(undefined *)&(pSVar6->hul).ihuldef;
  }
  else if ((shdef.hul.ihuldef != *(int *)((int)lpshdef + ishdef * 0x93)) ||
          (shdef.hul.ibmp != *(int *)((int)lpshdef + ishdef * 0x93 + 0x32))) {
    piVar7 = (int *)((int)lpshdef + ishdef * 0x93);
    pSVar6 = &shdef;
    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {
      piVar2 = piVar7;
      piVar7 = piVar7 + 1;
      pSVar1 = pSVar6;
      pSVar6 = (SHDEF *)(pSVar6->hul).rgTech;
      *piVar2 = (pSVar1->hul).ihuldef;
    }
    *(undefined *)piVar7 = *(undefined *)&(pSVar6->hul).ihuldef;
  }
  if (_DATA::idPlayer != -1) {
    UTIL::UpdateShdefCost((SHDEF *)CONCAT22(lpshdef._2_2_,(int)lpshdef + ishdef * 0x93));
  }
  if ((*(uint *)((int)lpshdef + ishdef * 0x93 + 0x7b) & 0xff) == 7) {
    iVar3 = (int)lpshdef + ishdef * 0x93;
    lphul = (HUL *)CONCAT22(lpshdef._2_2_,iVar3);
    pHVar9 = PARTS::LphuldefFromId(lphul->ihuldef);
    uVar8 = (undefined2)((ulong)pHVar9 >> 0x10);
    iVar4 = (int)pHVar9;
    wt._0_2_ = *(int *)(iVar4 + 0x28);
    for (c = 0; c < (int)(uint)*(byte *)(iVar3 + 0x7a); c = c + 1) {
      if (*(uint *)(iVar3 + c * 4 + 0x3c) >> 8 != 0) {
        psVar5 = (short *)(iVar3 + 0x3a + c * 4);
        part.hs.grhst = *psVar5;
        part.hs.flags2 = psVar5[1];
        fOkay = PARTS::FLookupPart(&part);
        if (_DATA::idPlayer == -1) {
          fOkay = 0;
        }
        if ((((part.hs.grhst & *(uint *)(iVar4 + 0x3a + c * 4)) == 0) ||
            ((1 < fOkay && (-1 < shdef.wFlags)))) ||
           (*(uint *)(iVar4 + c * 4 + 0x3c) >> 8 < (uint)part.hs.flags2 >> 8)) {
          *(uint *)(iVar3 + c * 4 + 0x3c) = *(uint *)(iVar3 + c * 4 + 0x3c) & 0xff;
        }
        wt._0_2_ = (int)wt + *(int *)((int)part.pterra + 0x28) *
                             (*(uint *)(iVar3 + c * 4 + 0x3c) >> 8);
      }
      if (((c == 0) && (*(uint *)(iVar3 + 0x3c) >> 8 == 0)) && (*(int *)(iVar4 + 0x3a) == 1)) {
        *(undefined2 *)(iVar3 + 0x3a) = 1;
        *(uint *)(iVar3 + 0x3c) = *(uint *)(iVar3 + 0x3c) & 0xff00 | 1;
        *(uint *)(iVar3 + 0x3c) = *(uint *)(iVar3 + 0x3c) & 0xff | *(uint *)(iVar4 + 0x3c) & 0xff00;
        part.hs.grhst = *(short *)(iVar3 + 0x3a);
        part.hs.flags2 = *(short *)(iVar3 + 0x3c);
        PARTS::FLookupPart(&part);
        wt._0_2_ = (int)wt + *(int *)((int)part.pterra + 0x28) * (*(uint *)(iVar3 + 0x3c) >> 8);
      }
    }
    *(int *)(iVar3 + 0x28) = (int)wt;
  }
  return 1;
}



// ======================================================================
// Function: FRunLogFile
// Address: 1048:a2d6
// ======================================================================


short __cdecl16far PLANET::FRunLogFile(void)

{
  int iVar1;
  uint uVar2;
  HDR *lprts;
  short iCur;
  short fRet;
  short fLogOld;
  
  iVar1 = _DATA::fLogOff;
  iCur = 0;
  fRet = 1;
  if (_DATA::imemLogCur == 0) {
    fRet = 1;
  }
  else {
    _DATA::fLogOff = 1;
    for (; iCur < _DATA::imemLogCur; iCur = iCur + (lprts->flags1 & 0x3ffU) + 2) {
      lprts = (HDR *)CONCAT22(_DATA::lpLog._2_2_,(int)_DATA::lpLog + iCur);
      uVar2 = FRunLogRecord((uint)lprts->flags1 >> 10,lprts->flags1 & 0x3ff,
                            (byte *)CONCAT22(_DATA::lpLog._2_2_,(int)_DATA::lpLog + iCur + 2));
      fRet = fRet & uVar2;
    }
    _DATA::gd.flags3 = _DATA::gd.flags3 & 0xfbff;
  }
  _DATA::fLogOff = iVar1;
  return fRet;
}



// ======================================================================
// Function: FRunLogRecord
// Address: 1048:a38c
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: FSendPlrMsg2XGen
// Address: 1030:823a
// ======================================================================


short __cdecl16far MSG::FSendPlrMsg2XGen(short fPrepend,short iMsg,short iObj,short p1,short p2)

{
  short sVar1;
  MSGHDR *pmsghdr;
  ushort cSize;
  byte *pb;
  ushort grbit;
  short i;
  short *pi;
  byte rgb;
  short sStack_42;
  byte abStack_40 [62];
  
  if (_DATA::imemMsgCur + 0x14U < 0xffc9) {
    _rgb = iMsg & 0x1ff;
    *(byte *)((int)&c_common::bitfMsgSent + (iMsg >> 3)) =
         *(byte *)((int)&c_common::bitfMsgSent + (iMsg >> 3)) & ~(byte)(1 << ((byte)iMsg & 7)) |
         (byte)(1 << ((byte)iMsg & 7));
    sStack_42 = iObj;
    pb = abStack_40;
    grbit = 1;
    pi = &p1;
    for (i = 0; i < *(char *)(iMsg + 0x5b0e); i = i + 1) {
      if ((*pi & 0xff00U) == 0) {
        *pb = (byte)*pi;
        pb = pb + 1;
      }
      else {
        _rgb = _rgb & 0x1ff | grbit << 9 | _rgb & 0xfe00;
        *(short *)pb = *pi;
        pb = pb + 2;
      }
      pi = pi + 1;
      grbit = grbit << 1;
    }
    if (fPrepend == 0) {
      PUBLIC::__fmemmove((int)_DATA::lpMsg + _DATA::imemMsgCur,_DATA::lpMsg._2_2_,&rgb);
    }
    else {
      PUBLIC::__fmemmove(pb + ((int)_DATA::lpMsg - (int)&rgb),_DATA::lpMsg._2_2_,(int)_DATA::lpMsg,
                         _DATA::lpMsg._2_2_,_DATA::imemMsgCur);
      PUBLIC::__fmemmove((int)_DATA::lpMsg,_DATA::lpMsg._2_2_,&rgb);
    }
    _DATA::imemMsgCur = (int)(pb + (_DATA::imemMsgCur - (int)&rgb));
    _DATA::cMsg = _DATA::cMsg + 1;
    _DATA::iMsgCur = -1;
    _DATA::iMsgCur = IMsgNext(0);
    sVar1 = 1;
  }
  else {
    sVar1 = 0;
  }
  return sVar1;
}



// ======================================================================
// Function: FileError
// Address: 1070:4a10
// ======================================================================


void __cdecl16far IO::FileError(short ids)

{
  char *sz;
  short mbType;
  
  _DATA::idsFileError = ids;
  if ((_DATA::fFileErrSilent == 0) && (((uint)_DATA::gd.flags1 >> 1 & 1) == 0)) {
    mbType = 0x10;
    sz = MSG::PszFormatIds(ids,(short *)0x0);
    UTILGEN::AlertSz(sz,mbType);
  }
  return;
}



// ======================================================================
// Function: FreeLp
// Address: 1060:07a8
// ======================================================================


void __cdecl16far MEMORY::FreeLp(void *lp,short ht)

{
  uint *puVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  undefined2 uVar5;
  HB *pHVar6;
  HB *lphb;
  ushort cbFree;
  
  if (lp != (void *)0x0) {
    pHVar6 = LphbFromLpHt(lp,ht);
    uVar5 = (undefined2)((ulong)pHVar6 >> 0x10);
    iVar3 = (int)pHVar6;
    iVar4 = *(int *)((int)lp + -2) + 2;
    puVar1 = (uint *)((int)lp + -2);
    *puVar1 = *puVar1 | 1;
    pHVar6->cbFree = pHVar6->cbFree + iVar4;
    if (((int)lp - iVar3) + iVar4 + -2 == *(int *)(iVar3 + 6)) {
      piVar2 = (int *)(iVar3 + 6);
      *piVar2 = *piVar2 - iVar4;
      piVar2 = (int *)(iVar3 + 4);
      *piVar2 = *piVar2 + iVar4;
    }
  }
  return;
}



// ======================================================================
// Function: FreePl
// Address: 1060:0918
// ======================================================================


void __cdecl16far MEMORY::FreePl(PL *lppl)

{
  if (lppl != (PL *)0x0) {
    FreeLp(lppl,(uint)lppl->flags1 >> 9 & 7);
  }
  return;
}



// ======================================================================
// Function: GetFileStatus
// Address: 1070:4a60
// ======================================================================


void __cdecl16far IO::GetFileStatus(short dt,short iPlayer)

{
  int iVar1;
  
  SetSzWorkFromDt(dt,iPlayer);
  iVar1 = PUBLIC::__access(0x1070,(int)&c_common::szWork,2);
  _DATA::gd.flags2 = _DATA::gd.flags2 & 0xffdfU | (uint)(iVar1 != 0) << 5;
  return;
}



// ======================================================================
// Function: GetRaceStat
// Address: 10e0:30d2
// ======================================================================


short __cdecl16far RACE::GetRaceStat(PLAYER *pplr,short iStat)

{
  return (int)pplr->rgAttr[iStat];
}



// ======================================================================
// Function: IMsgNext
// Address: 1030:7808
// ======================================================================


short __cdecl16far MSG::IMsgNext(short fFilteredOnly)

{
  short sVar1;
  short idm;
  short i;
  
  i = _DATA::iMsgCur;
  if ((_DATA::fViewFilteredMsg == 0) || (fFilteredOnly != 0)) {
    do {
      i = i + 1;
      if (_DATA::cMsg <= i) {
        if (i < _DATA::cMsg + _DATA::vcmsgplrIn) {
          return i;
        }
        return -1;
      }
      sVar1 = IdmGetMessageN(i);
    } while ((uint)(((uint)*(byte *)((int)&c_common::bitfMsgFiltered + (sVar1 >> 3)) &
                    1 << ((byte)sVar1 & 7)) == 0) == fFilteredOnly);
  }
  else if (_DATA::iMsgCur < _DATA::cMsg + _DATA::vcmsgplrIn + -1) {
    i = _DATA::iMsgCur + 1;
  }
  else {
    i = -1;
  }
  return i;
}



// ======================================================================
// Function: IWarpMAFromLppl
// Address: 1048:7b10
// ======================================================================


short __cdecl16far PLANET::IWarpMAFromLppl(PLANET *lppl,short *pfTwo)

{
  undefined2 uVar1;
  int iVar2;
  int iVar3;
  undefined2 uVar4;
  short iNew;
  HUL *lphul;
  short i;
  short iWarp;
  short fTwo;
  
  iWarp = 0;
  fTwo = 0;
  if (pfTwo != (short *)0x0) {
    *pfTwo = 0;
  }
  uVar4 = (undefined2)((ulong)lppl >> 0x10);
  iVar2 = (int)lppl;
  if ((*(int *)(iVar2 + 2) == -1) || ((*(uint *)(iVar2 + 4) >> 9 & 1) == 0)) {
    iWarp = 0;
  }
  else if ((*(int *)(iVar2 + 2) == _DATA::idPlayer) ||
          ((_DATA::idPlayer == -1 ||
           (iVar3 = *(int *)(iVar2 + 2) * 4,
           (*(uint *)(*(int *)(iVar3 + 0x14c) + (*(uint *)(iVar2 + 0x2c) & 0xf) * 0x93 + 0x7b) &
           0xff) == 7)))) {
    iVar3 = *(int *)(iVar2 + 2) * 4;
    uVar1 = *(undefined2 *)(iVar3 + 0x14e);
    iVar2 = *(int *)(iVar3 + 0x14c) + (*(uint *)(iVar2 + 0x2c) & 0xf) * 0x93;
    for (i = 0; i < (int)(uint)*(byte *)(iVar2 + 0x7a); i = i + 1) {
      if ((((*(int *)(iVar2 + 0x3a + i * 4) == 0x200) && (*(uint *)(iVar2 + i * 4 + 0x3c) >> 8 != 0)
           ) && (6 < (*(uint *)(iVar2 + i * 4 + 0x3c) & 0xff))) &&
         ((*(uint *)(iVar2 + i * 4 + 0x3c) & 0xff) < 0x10)) {
        iVar3 = (*(uint *)(iVar2 + i * 4 + 0x3c) & 0xff) - 2;
        if (iWarp < iVar3) {
          fTwo = 0;
          iWarp = iVar3;
        }
        else if (iVar3 == iWarp) {
          fTwo = 1;
        }
      }
    }
    if (pfTwo != (short *)0x0) {
      *pfTwo = fTwo;
    }
  }
  else {
    iWarp = 0;
  }
  return iWarp;
}



// ======================================================================
// Function: LSaltFromSz
// Address: 1040:59ce
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

undefined2 __cdecl16far UTILGEN::LSaltFromSz(char *psz)

{
  char *pcVar1;
  long lVar2;
  int iVar3;
  long lVar4;
  long lSalt;
  
  lVar4 = 0;
  pcVar1 = psz;
  if (*psz == '\0') {
    lSalt._0_2_ = 0;
  }
  else {
    while (psz = pcVar1, lSalt._0_2_ = (undefined2)lVar4, *psz != '\0') {
      iVar3 = (int)*psz;
      lVar2 = lVar4 + iVar3;
      lVar4 = lVar4 + iVar3;
      pcVar1 = psz + 1;
      if (*pcVar1 != '\0') {
        iVar3 = (int)*pcVar1;
        lVar4 = PUBLIC::__aFulmul(lVar2,iVar3,iVar3 >> 0xf);
        pcVar1 = psz + 2;
      }
    }
    if (lVar4 == 0) {
      lSalt._0_2_ = 1;
    }
  }
  return (undefined2)lSalt;
}



// ======================================================================
// Function: LpAlloc
// Address: 1060:03b2
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void * __stdcall16far MEMORY::LpAlloc(ushort cb,short ht)

{
  int *piVar1;
  uint uVar2;
  byte *pbVar3;
  uint cb_00;
  uint uVar4;
  uint uVar5;
  int iVar6;
  undefined2 uVar7;
  byte *lpb;
  HB *lphb;
  byte *lpbTop;
  byte *lpbPrev;
  ushort cbItem;
  short fFree;
  
  lphb = (HB *)CONCAT22(*(undefined2 *)(ht * 4 + 0xd36),*(undefined2 *)(ht * 4 + 0xd34));
  cb_00 = cb + 3 & 0xfffe;
  do {
    if ((((int)lphb == 0) && (lphb._2_2_ == 0)) || (cb_00 <= (uint)lphb->cbFree)) {
      if (((int)lphb == 0) && (lphb._2_2_ == 0)) {
        lphb = LphbAlloc(cb_00,ht);
      }
      uVar7 = (undefined2)((ulong)lphb >> 0x10);
      iVar6 = (int)lphb;
      uVar4 = iVar6 + *(int *)(iVar6 + 6);
      lpbTop = (byte *)CONCAT22(uVar7,uVar4);
      if (cb_00 <= *(uint *)(iVar6 + 4)) {
        *(uint *)lpbTop = cb_00 - 2;
        piVar1 = (int *)(iVar6 + 6);
        *piVar1 = *piVar1 + cb_00;
        lphb->cbFree = lphb->cbFree - cb_00;
        piVar1 = (int *)(iVar6 + 4);
        *piVar1 = *piVar1 - cb_00;
LAB_1060_0586:
        return (void *)CONCAT22(uVar7,uVar4 + 2);
      }
      lpb = (byte *)CONCAT22(uVar7,iVar6 + 0x10);
      while (pbVar3 = lpb, uVar2 = (uint)lpb, (uint)lpb < uVar4) {
        uVar7 = lpb._2_2_;
        uVar5 = *(uint *)lpb;
        lpb = (byte *)CONCAT22(lpb._2_2_,(uint)lpb + (*(uint *)lpb & 0xfffe) + 2);
        if ((uVar5 & 1) != 0) {
          for (; (((uint)lpb < uVar4 && ((*(uint *)lpb & 1) != 0)) && ((uint)lpb - uVar2 < cb_00));
              lpb = (byte *)CONCAT22(lpb._2_2_,(uint)lpb + (*(uint *)lpb & 0xfffe) + 2)) {
          }
          uVar5 = (uint)lpb - uVar2;
          *(uint *)pbVar3 = uVar5 - 2 | 1;
          if (cb_00 <= uVar5) {
            *(uint *)pbVar3 = *(uint *)pbVar3 & 0xfffe;
            lphb->cbFree = lphb->cbFree - uVar5;
            uVar4 = uVar2;
            goto LAB_1060_0586;
          }
        }
      }
    }
    uVar7 = (undefined2)((ulong)lphb >> 0x10);
    lphb = (HB *)CONCAT22(*(undefined2 *)((int)lphb + 10),*(undefined2 *)((int)lphb + 8));
  } while( true );
}



// ======================================================================
// Function: LpReAlloc
// Address: 1060:0660
// ======================================================================


void * __stdcall16far MEMORY::LpReAlloc(void *lp,ushort cb,short ht)

{
  int *piVar1;
  uint uVar2;
  uint cb_00;
  uint uVar3;
  int iVar4;
  int iVar5;
  HB *lphb_00;
  void *pvVar6;
  ushort cbGrow;
  ushort cbCur;
  HB *lphb;
  void *lpNew;
  
  uVar2 = *(uint *)((int)lp + -2);
  cb_00 = cb + 1 & 0xfffe;
  uVar3 = cb_00 - uVar2;
  pvVar6 = lp;
  if (uVar2 < cb_00) {
    lphb_00 = LphbFromLpHt(lp,ht);
    while( true ) {
      iVar5 = (int)((ulong)lphb_00 >> 0x10);
      iVar4 = (int)lphb_00;
      if (((iVar4 + *(int *)(iVar4 + 6) == (int)lp + uVar2) && (iVar5 == lp._2_2_)) &&
         (uVar3 <= *(uint *)(iVar4 + 4))) {
        piVar1 = (int *)(iVar4 + 4);
        *piVar1 = *piVar1 - uVar3;
        lphb_00->cbFree = lphb_00->cbFree - uVar3;
        piVar1 = (int *)(iVar4 + 6);
        *piVar1 = *piVar1 + uVar3;
        *(uint *)((int)lp + -2) = cb_00;
        return lp;
      }
      if ((ht != 3) && (ht != 10)) break;
      lphb_00 = LphbReAlloc(lphb_00);
      lp = (void *)CONCAT22((int)((ulong)lphb_00 >> 0x10),(int)lphb_00 + 0x12);
    }
    pvVar6 = LpAlloc(cb_00,ht);
    PUBLIC::__fmemcpy(pvVar6,(int)lp,lp._2_2_,uVar2);
    FreeLp(lp,ht);
  }
  return pvVar6;
}



// ======================================================================
// Function: LphbAlloc
// Address: 1060:0000
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

HB * __stdcall16far MEMORY::LphbAlloc(ushort cb,short ht)

{
  undefined2 uVar1;
  int iVar2;
  char *sz;
  int iVar3;
  undefined2 uVar4;
  undefined2 unaff_CS;
  HB *pHVar5;
  short mbType;
  HB *lphb;
  ushort hmem;
  
                    /* Segment:    13
                       Offset:     00062900
                       Length:     0959
                       Min Alloc:  0959
                       Flags:      1d50
                           Code
                           Discardable
                           Moveable
                           Preload
                           Impure (Non-shareable)
                        */
  cb = cb + 0x10;
  if (cb < *(uint *)(ht * 2 + 0xd64)) {
    cb = *(ushort *)(ht * 2 + 0xd64);
  }
  iVar2 = GLOBALALLOC(unaff_CS,cb,0);
  if (iVar2 == 0) {
    mbType = 0x10;
    sz = MSG::PszFormatIds(0x1a,(short *)0x0);
    UTILGEN::AlertSz(sz,mbType);
    PUBLIC::_longjmp();
  }
  pHVar5 = (HB *)GLOBALLOCK();
  uVar4 = (undefined2)((ulong)pHVar5 >> 0x10);
  iVar3 = (int)pHVar5;
  *(int *)(iVar3 + 0xc) = iVar2;
  *(ushort *)(iVar3 + 2) = cb;
  *(int *)(iVar3 + 4) = cb - 0x10;
  pHVar5->cbFree = cb - 0x10;
  *(undefined2 *)(iVar3 + 6) = 0x10;
  *(undefined *)(iVar3 + 0xe) = (char)ht;
  uVar1 = *(undefined2 *)(ht * 4 + 0xd36);
  *(undefined2 *)(iVar3 + 8) = *(undefined2 *)(ht * 4 + 0xd34);
  *(undefined2 *)(iVar3 + 10) = uVar1;
  *(int *)(ht * 4 + 0xd34) = iVar3;
  *(undefined2 *)(ht * 4 + 0xd36) = uVar4;
  return pHVar5;
}



// ======================================================================
// Function: LphbFromLpHt
// Address: 1060:058c
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x106005e0) */
/* WARNING: Removing unreachable block (ram,0x10600608) */
/* WARNING: Could not reconcile some variable overlaps */

HB * __stdcall16far MEMORY::LphbFromLpHt(void *lp,short ht)

{
  HB *lphb;
  
  if ((ht < 0) || (0xb < ht)) {
    lphb = (HB *)0x0;
  }
  else {
    lphb = (HB *)CONCAT22(*(undefined2 *)(ht * 4 + 0xd36),*(undefined2 *)(ht * 4 + 0xd34));
    while( true ) {
      if ((lphb == (HB *)0x0) ||
         ((lphb < lp && (lp < (void *)CONCAT22(lphb._2_2_,(int)lphb + *(int *)((int)lphb + 2))))))
      break;
      lphb = (HB *)CONCAT22(*(undefined2 *)((int)lphb + 10),*(undefined2 *)((int)lphb + 8));
    }
    if (lphb == (HB *)0x0) {
      lphb = (HB *)0x0;
    }
  }
  return lphb;
}



// ======================================================================
// Function: LphbReAlloc
// Address: 1060:0108
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

HB * __stdcall16far MEMORY::LphbReAlloc(HB *lphb)

{
  int *piVar1;
  uint uVar2;
  char *sz;
  int iVar3;
  undefined2 uVar4;
  int iVar5;
  HB *pHVar6;
  short mbType;
  ushort cbGrow;
  ushort cbCur;
  HB *lphbNew;
  HB *lphbT;
  ushort hmem;
  
  if (lphb == (HB *)0x0) {
    return (HB *)0x0;
  }
  hmem = *(ushort *)((int)lphb + 0xc);
  uVar2 = *(uint *)((int)lphb + 2);
  cbGrow = *(ushort *)((uint)*(byte *)((int)lphb + 0xe) * 2 + 0xd64);
  if (uVar2 < 0xffdc) {
    if (-cbGrow - 0x24 < uVar2) {
      cbGrow = -uVar2 - 0x24;
    }
    GLOBALUNLOCK();
    hmem = GLOBALREALLOC(0x14f8,0x22,*(int *)((int)lphb + 2) + cbGrow,0);
    if (hmem != 0) goto LAB_1060_01db;
  }
  mbType = 0x10;
  sz = MSG::PszFormatIds(0x1a,(short *)0x0);
  UTILGEN::AlertSz(sz,mbType);
  PUBLIC::_longjmp();
LAB_1060_01db:
  pHVar6 = (HB *)GLOBALLOCK();
  uVar4 = (undefined2)((ulong)pHVar6 >> 0x10);
  iVar3 = (int)pHVar6;
  *(ushort *)(iVar3 + 0xc) = hmem;
  iVar5 = (uint)*(byte *)(iVar3 + 0xe) * 4;
  if ((*(int *)(iVar5 + 0xd34) == (int)lphb) && (*(int *)(iVar5 + 0xd36) == lphb._2_2_)) {
    iVar5 = (uint)*(byte *)(iVar3 + 0xe) * 4;
    *(int *)(iVar5 + 0xd34) = iVar3;
    *(undefined2 *)(iVar5 + 0xd36) = uVar4;
  }
  else {
    iVar5 = (uint)*(byte *)(iVar3 + 0xe) * 4;
    lphbT = (HB *)CONCAT22(*(undefined2 *)(iVar5 + 0xd36),*(undefined2 *)(iVar5 + 0xd34));
    while( true ) {
      if ((((int)lphbT == 0) && (lphbT._2_2_ == 0)) ||
         ((*(int *)((int)lphbT + 8) == (int)lphb && (*(int *)((int)lphbT + 10) == lphb._2_2_))))
      break;
      lphbT = (HB *)CONCAT22(*(undefined2 *)((int)lphbT + 10),*(undefined2 *)((int)lphbT + 8));
    }
    *(int *)((int)lphbT + 8) = iVar3;
    *(undefined2 *)((int)lphbT + 10) = uVar4;
  }
  piVar1 = (int *)(iVar3 + 2);
  *piVar1 = *piVar1 + cbGrow;
  pHVar6->cbFree = pHVar6->cbFree + cbGrow;
  piVar1 = (int *)(iVar3 + 4);
  *piVar1 = *piVar1 + cbGrow;
  return pHVar6;
}



// ======================================================================
// Function: LphuldefFromId
// Address: 1008:512c
// ======================================================================


HULDEF * __stdcall16far PARTS::LphuldefFromId(short id)

{
  undefined2 unaff_CS;
  HULDEF *pHVar1;
  
  if (id < 0x20) {
    pHVar1 = (HULDEF *)CONCAT22(unaff_CS,id * 0x8f + 0x29f0);
  }
  else {
    pHVar1 = LphuldefSBFromId(id + -0x20);
  }
  return pHVar1;
}



// ======================================================================
// Function: LpplAlloc
// Address: 1060:088c
// ======================================================================


PL * __stdcall16far MEMORY::LpplAlloc(ushort cbItem,ushort cAlloc,short ht)

{
  undefined2 uVar1;
  PL *pPVar2;
  PL *lppl;
  
  pPVar2 = (PL *)LpAlloc(cbItem * cAlloc + 4,ht);
  uVar1 = (undefined2)((ulong)pPVar2 >> 0x10);
  *(undefined *)((int)pPVar2 + 2) = (char)cAlloc;
  *(undefined *)((int)pPVar2 + 3) = 0;
  pPVar2->flags1 = pPVar2->flags1 & 0xfeff;
  pPVar2->flags1 = pPVar2->flags1 & 0xff00U | cbItem & 0xff;
  pPVar2->flags1 = pPVar2->flags1 & 0xf1ffU | (ht & 7U) << 9;
  return pPVar2;
}



// ======================================================================
// Function: LpplFromId
// Address: 1038:021e
// ======================================================================


PLANET * __stdcall16far UTIL::LpplFromId(short idPlanet)

{
  int iVar1;
  int *piVar2;
  short sVar3;
  undefined2 uVar4;
  short iHi;
  short iGuess;
  PLANET *lppl;
  short iLo;
  short idGuess;
  
  if ((idPlanet < 0) || (_DATA::game.cPlanMax <= idPlanet)) {
    piVar2 = (int *)0x0;
    uVar4 = 0;
  }
  else {
    uVar4 = _DATA::lpPlanets._2_2_;
    if (c_common::cPlanet == _DATA::game.cPlanMax) {
      piVar2 = (int *)((int)_DATA::lpPlanets + idPlanet * 0x38);
    }
    else {
      iLo = -1;
      iHi = c_common::cPlanet;
      sVar3 = iLo;
      do {
        iLo = sVar3;
        if (iHi <= iLo + 1) {
          piVar2 = (int *)0x0;
          uVar4 = 0;
          break;
        }
        sVar3 = iLo + iHi >> 1;
        piVar2 = (int *)((int)_DATA::lpPlanets + sVar3 * 0x38);
        iVar1 = *piVar2;
      } while ((iVar1 < idPlanet) || (iHi = sVar3, sVar3 = iLo, idPlanet < iVar1));
    }
  }
  return (PLANET *)CONCAT22(uVar4,piVar2);
}



// ======================================================================
// Function: OutputSz
// Address: 1038:7fe6
// ======================================================================


void __cdecl16far UTIL::OutputSz(short dt,char *sz)

{
  int iVar1;
  char *pcVar2;
  undefined2 uVar3;
  char szTemp;
  char szDate;
  char szFile;
  char szTime;
  
  uVar3 = 0x1120;
  _WSPRINTF();
  pcVar2 = &szFile;
  iVar1 = PUBLIC::__access(0x14f8,pcVar2,0,uVar3);
  if (iVar1 == -1) {
    MAIN::SzVersion();
    pcVar2 = (char *)0x1120;
    _WSPRINTF(0x1018,&szTemp);
    UTILGEN::OutputFileString(&szFile,&szTemp);
  }
  PUBLIC::__strdate(&szDate,pcVar2);
  PUBLIC::__strtime(&szTime);
  _WSPRINTF(0x1118,&szTemp);
  UTILGEN::OutputFileString(&szFile,&szTemp);
  return;
}



// ======================================================================
// Function: PctPlanetDesirability
// Address: 1048:6e1e
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

short __cdecl16far PLANET::PctPlanetDesirability(PLANET *lppl,short iPlr)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  short sVar7;
  undefined2 uVar8;
  undefined2 extraout_DX;
  undefined2 uVar9;
  undefined2 unaff_CS;
  bool bVar10;
  long lVar11;
  undefined4 uVar12;
  long pctMod;
  short iPlanet;
  short pctVar;
  long pctPos;
  short dPenalty;
  short i;
  short iPref;
  long pctNeg;
  short iMax;
  short d;
  short iMin;
  
  pctPos = 0;
  pctNeg._0_2_ = 0;
  pctNeg._2_2_ = 0;
  uVar12 = 10000;
  i = 0;
  while( true ) {
    pctMod._2_2_ = (undefined2)((ulong)uVar12 >> 0x10);
    pctMod._0_2_ = (undefined2)uVar12;
    if (2 < i) break;
    iVar1 = (int)*(char *)((int)lppl + 0xc + i);
    iVar2 = (int)*(char *)(iPlr * 0xc0 + 0x59b2 + i);
    iVar3 = (int)*(char *)(iPlr * 0xc0 + 0x59b5 + i);
    iVar4 = (int)*(char *)(iPlr * 0xc0 + 0x59b8 + i);
    if (iVar4 < 0) {
      pctPos = pctPos + 10000;
    }
    else if ((iVar1 < iVar3) || (iVar4 < iVar1)) {
      if (iVar1 < iVar3) {
        if (iVar3 - iVar1 < 0x10) {
          uVar6 = iVar3 - iVar1;
          iVar1 = (int)uVar6 >> 0xf;
        }
        else {
          uVar6 = 0xf;
          iVar1 = 0;
        }
        bVar10 = CARRY2((uint)pctNeg,uVar6);
        pctNeg._0_2_ = (uint)pctNeg + uVar6;
        pctNeg._2_2_ = pctNeg._2_2_ + iVar1 + (uint)bVar10;
      }
      else {
        if (iVar1 - iVar4 < 0x10) {
          uVar6 = iVar1 - iVar4;
          iVar1 = (int)uVar6 >> 0xf;
        }
        else {
          uVar6 = 0xf;
          iVar1 = 0;
        }
        bVar10 = CARRY2((uint)pctNeg,uVar6);
        pctNeg._0_2_ = (uint)pctNeg + uVar6;
        pctNeg._2_2_ = pctNeg._2_2_ + iVar1 + (uint)bVar10;
      }
    }
    else {
      iVar5 = PUBLIC::_abs();
      if (iVar1 < iVar2) {
        d = iVar2 - iVar3;
        dPenalty = (iVar2 - iVar1) * 2 - d;
      }
      else {
        d = iVar4 - iVar2;
        dPenalty = (iVar1 - iVar2) * 2 - d;
      }
      pctVar = (iVar5 * 100) / d;
      iVar1 = 100 - pctVar;
      lVar11 = PUBLIC::__aFulmul(iVar1,CONCAT42((long)iVar1,iVar1 >> 0xf));
      pctPos = lVar11 + pctPos;
      if (0 < dPenalty) {
        uVar12 = PUBLIC::__aFulmul((undefined2)pctMod,
                                   CONCAT42((long)(d * 2 - dPenalty),pctMod._2_2_));
        uVar12 = PUBLIC::__aFldiv((int)uVar12,CONCAT42((long)(d << 1),(int)((ulong)uVar12 >> 0x10)))
        ;
      }
      unaff_CS = 0x1118;
    }
    i = i + 1;
  }
  if (((uint)pctNeg == 0) && (pctNeg._2_2_ == 0)) {
    PUBLIC::_sqrt(unaff_CS,(double)pctPos / DAT_1120_1d2e);
    uVar9 = extraout_DX;
    uVar8 = PUBLIC::__ftol();
    uVar12 = PUBLIC::__aFulmul(uVar8,uVar9,uVar12);
    sVar7 = PUBLIC::__aFldiv(uVar12);
  }
  else {
    sVar7 = -(uint)pctNeg;
  }
  return sVar7;
}



// ======================================================================
// Function: PctPlanetOptValue
// Address: 1048:6b88
// ======================================================================


short __cdecl16far PLANET::PctPlanetOptValue(PLANET *lppl,short iPlr)

{
  int *piVar1;
  short sVar2;
  int iVar3;
  short iNewVal;
  short rgiValSav;
  short rgCost;
  short pctDesire;
  short rgMin;
  short i;
  short rgMax;
  
  sVar2 = FCanTerraformLppl(lppl,&rgMin,&rgMax,&rgCost,1);
  if (sVar2 == 0) {
    pctDesire = PctPlanetDesirability(lppl,iPlr);
  }
  else {
    for (i = 0; i < 3; i = i + 1) {
      (&rgiValSav)[i] = (int)*(char *)((int)lppl + 0xc + i);
      if ((*(char *)(iPlr * 0xc0 + 0x59b5 + i) != -1) &&
         (*(char *)((int)lppl + 0xc + i) != *(char *)(iPlr * 0xc0 + 0x59b2 + i))) {
        iNewVal = -1;
        if (*(char *)((int)lppl + 0xc + i) < *(char *)(iPlr * 0xc0 + 0x59b2 + i)) {
          iVar3 = (int)*(char *)((int)lppl + 0xc + i);
          piVar1 = &rgMax + i;
          if (*piVar1 != iVar3 && iVar3 <= *piVar1) {
            if ((int)*(char *)(iPlr * 0xc0 + 0x59b2 + i) < (&rgMax)[i]) {
              iNewVal = (short)*(char *)(iPlr * 0xc0 + 0x59b2 + i);
            }
            else {
              iNewVal = (&rgMax)[i];
            }
          }
        }
        else if (((&rgMin)[i] != -1) && ((&rgMin)[i] < (int)*(char *)((int)lppl + 0xc + i))) {
          if ((&rgMin)[i] < (int)*(char *)(iPlr * 0xc0 + 0x59b2 + i)) {
            iNewVal = (short)*(char *)(iPlr * 0xc0 + 0x59b2 + i);
          }
          else {
            iNewVal = (&rgMin)[i];
          }
        }
        if (iNewVal != -1) {
          *(undefined *)((int)lppl + 0xc + i) = (char)iNewVal;
        }
      }
    }
    pctDesire = PctPlanetDesirability(lppl,_DATA::idPlayer);
    for (i = 0; i < 3; i = i + 1) {
      *(undefined *)((int)lppl + 0xc + i) = (char)(&rgiValSav)[i];
    }
  }
  return pctDesire;
}



// ======================================================================
// Function: PctTrueMaxGrowth
// Address: 10e0:65d4
// ======================================================================


short __cdecl16far RACE::PctTrueMaxGrowth(short iplr)

{
  short sVar1;
  
  sVar1 = GetRaceStat((PLAYER *)((int)&c_common::rgplr + iplr * 0xc0),0xe);
  if (sVar1 == 0) {
    sVar1 = (int)*(char *)(iplr * 0xc0 + 0x59bb) << 1;
  }
  else {
    sVar1 = (short)*(char *)(iplr * 0xc0 + 0x59bb);
  }
  return sVar1;
}



// ======================================================================
// Function: PromptSaveGame
// Address: 1070:43ee
// ======================================================================


void __cdecl16far IO::PromptSaveGame(void)

{
  undefined2 uVar1;
  int iVar2;
  undefined2 unaff_CS;
  undefined4 uVar3;
  short fRet;
  
  uVar3 = MAKEPROCINSTANCE(unaff_CS,c_common::hInst,0x432a);
  if (((uint)_DATA::game.wCrap >> 2 & 1) == 0) {
    uVar1 = 0x42c;
  }
  else {
    uVar1 = 0x7e9;
  }
  iVar2 = DIALOGBOX(0x14f8,uVar3,c_common::hwndFrame,uVar1,0);
  FREEPROCINSTANCE(0x14f8,(int)uVar3);
  if (iVar2 != 0) {
    _DATA::gd.flags1 = _DATA::gd.flags1 & 0xffefU | (uint)(iVar2 == -1) << 4;
    PLANET::FWriteLogFile((char *)&c_common::szBase,_DATA::idPlayer);
    PLANET::FWriteHistFile(_DATA::idPlayer);
  }
  return;
}



// ======================================================================
// Function: PszFormatIds
// Address: 1030:924c
// ======================================================================


char * __cdecl16far MSG::PszFormatIds(short ids,short *pParams)

{
  char *pcVar1;
  
  pcVar1 = STRINGS::PszGetCompressedString(ids);
  pcVar1 = PszFormatString(pcVar1,pParams);
  return pcVar1;
}



// ======================================================================
// Function: PszFormatString
// Address: 1030:85cc
// ======================================================================

// Decompilation failed: 
Low-level Error: Bad structure definition

// ======================================================================
// Function: PszGetCompressedString
// Address: 1010:743a
// ======================================================================


/* WARNING: Variable defined which should be unmapped: pch */
/* WARNING: Could not reconcile some variable overlaps */

char * __cdecl16far STRINGS::PszGetCompressedString(short ids)

{
  int iVar1;
  byte *pbVar2;
  undefined2 unaff_CS;
  bool bVar3;
  short fHigh;
  short iOffset;
  char *pszOut;
  byte *pch;
  short iLen;
  short i;
  short iNibble;
  short iBuild;
  byte *pchLen;
  short iChunk;
  
  iNibble = 0;
  if (ids != _DATA::iLastStrGet) {
    pchLen = (byte *)CONCAT22(0x1010,(ids >> 6) * 0x40 + 0x6e32);
    for (i = 0; i < (int)(ids & 0x3fU); i = i + 1) {
      iNibble = iNibble + (uint)*pchLen;
      pchLen = (byte *)CONCAT22(pchLen._2_2_,(int)pchLen + 1);
    }
    pch = (byte *)CONCAT22(unaff_CS,*(int *)((ids >> 6) * 2 + 0x73b8) + (iNibble >> 1));
    bVar3 = (iNibble & 1U) == 0;
    pszOut = (char *)&c_common::szLastStrGet;
    iBuild = 0;
    iLen = (uint)*pchLen;
    while (pbVar2 = pch, iVar1 = iLen + -1, iLen != 0) {
      if (bVar3) {
        i = (int)(uint)*pch >> 4;
      }
      else {
        pch = (byte *)CONCAT22(pch._2_2_,(int)pch + 1);
        i = *pbVar2 & 0xf;
      }
      bVar3 = !bVar3;
      iBuild = iBuild + i;
      iLen = iVar1;
      if (i != 0xf) {
        *pszOut = *(char *)(iBuild + 0x73e6);
        pszOut = pszOut + 1;
        iBuild = 0;
      }
    }
    *pszOut = '\0';
  }
  return (char *)&c_common::szLastStrGet;
}



// ======================================================================
// Function: PszPlayerName
// Address: 1038:11f2
// ======================================================================


char * __cdecl16far
UTIL::PszPlayerName(short iPlayer,short fCapital,short fPlural,short fThe,short grWord,PLAYER *pplr)

{
  int iVar1;
  char szName;
  char *pchEnd;
  
  if (pplr == (PLAYER *)0x0) {
    pplr = (PLAYER *)((int)&c_common::rgplr + iPlayer * 0xc0);
  }
  if (pplr->szName[0] == '\0') {
    iVar1 = iPlayer + 1;
    STRINGS::PszGetCompressedString(0x55e);
    _WSPRINTF(0x1010,&szName);
    if (fPlural == 0) {
      PUBLIC::_strcat(&szName,0x515,iVar1);
    }
    if (grWord == 1) {
      iVar1 = PUBLIC::_strlen(&szName);
      UTILGEN::CchGetString(0x55c,&szName + iVar1);
    }
    else if (grWord == 2) {
      iVar1 = PUBLIC::_strlen(&szName);
      UTILGEN::CchGetString(0x55d,&szName + iVar1);
    }
  }
  else {
    if (fThe == 0) {
      szName = '\0';
    }
    else {
      PUBLIC::_strcpy(&szName,0x50e);
      if (fCapital != 0) {
        szName = 'T';
      }
    }
    if ((fPlural == 0) || (pplr->szNames[0] == '\0')) {
      PUBLIC::_strcat(&szName,pplr->szName);
    }
    else {
      PUBLIC::_strcat(&szName,pplr->szNames);
    }
    iVar1 = PUBLIC::_strlen(&szName);
    pchEnd = &stack0xffc7 + iVar1;
    while ((*pchEnd == ' ' && (&szName <= pchEnd))) {
      *pchEnd = '\0';
      pchEnd = pchEnd + -1;
    }
    if (pchEnd < &szName) {
      UTILGEN::CchGetString(0x559,&szName);
    }
    if ((fPlural != 0) && (pplr->szNames[0] == '\0')) {
      iVar1 = PUBLIC::_strlen(&szName);
      pchEnd = &stack0xffc7 + iVar1;
      if ((*pchEnd != 's') && ((*pchEnd != 'e' || ((&stack0xffc6)[iVar1] != 's')))) {
        PUBLIC::_strcat(&szName,0x513);
      }
    }
    if (grWord == 1) {
      iVar1 = PUBLIC::_strlen(&szName);
      UTILGEN::CchGetString(0x55a,&szName + iVar1);
    }
    else if (grWord == 2) {
      iVar1 = PUBLIC::_strlen(&szName);
      UTILGEN::CchGetString(0x55b,&szName + iVar1);
    }
  }
  PUBLIC::_strcpy((int)&c_common::szWork,&szName);
  return (char *)&c_common::szWork;
}



// ======================================================================
// Function: ReadPlayerMessages
// Address: 1030:994a
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void __cdecl16far MSG::ReadPlayerMessages(void)

{
  int iVar1;
  undefined2 uVar2;
  void *pvVar3;
  ushort u;
  byte *lpb;
  MSGPLR *lpmp;
  short env;
  short i;
  ushort imemMsgT;
  MSGHDR *lpmh;
  short *penvMemSav;
  short fOOM;
  short iMax;
  byte *lpbMax;
  
  lpbMax._2_2_ = _DATA::lpMsg._2_2_;
  imemMsgT = 0;
  fOOM = 0;
  lpb._0_2_ = (int)_DATA::lpMsg + _DATA::imemMsgCur;
  while (c_common::hdrCur >> 10 == 0xc) {
    if (((c_common::hdrCur & 0x3ff) != 0) &&
       (_DATA::imemMsgCur + imemMsgT < -(c_common::hdrCur & 0x3ff) - 0x38)) {
      PUBLIC::__fmemmove((uint)lpb + imemMsgT,lpbMax._2_2_,(int)&c_common::rgbCur,0x1120,
                         c_common::hdrCur & 0x3ff);
      imemMsgT = imemMsgT + (c_common::hdrCur & 0x3ff);
    }
    IO::ReadRt();
  }
  _DATA::imemMsgCur = _DATA::imemMsgCur + imemMsgT;
  lpbMax._0_2_ = (uint)lpb + imemMsgT;
  while ((uint)lpb < (uint)lpbMax) {
    lpmh = (MSGHDR *)CONCAT22(lpbMax._2_2_,(uint)lpb);
    *(byte *)((int)&c_common::bitfMsgSent + ((lpmh->flags1 & 0x1ffU) >> 3)) =
         *(byte *)((int)&c_common::bitfMsgSent + ((lpmh->flags1 & 0x1ffU) >> 3)) &
         ~(byte)(1 << ((byte)lpmh->flags1 & 7)) | (byte)(1 << ((byte)lpmh->flags1 & 7));
    _DATA::cMsg = _DATA::cMsg + 1;
    u = (uint)lpmh->flags1 >> 9;
    lpb._0_2_ = (uint)lpb + 4;
    iMax = (short)*(char *)((lpmh->flags1 & 0x1ffU) + 0x5b0e);
    for (i = 0; i < iMax; i = i + 1) {
      lpb._0_2_ = (uint)lpb + ((u & 1) == 1) + 1;
      u = u >> 1;
    }
  }
  lpmp = (MSGPLR *)&_DATA::vlpmsgplrIn;
  while( true ) {
    uVar2 = (undefined2)((ulong)lpmp >> 0x10);
    if ((*(int *)&lpmp->lpmsgplrNext == 0) && (*(int *)((int)lpmp + 2) == 0)) break;
    lpmp = (MSGPLR *)CONCAT22(*(undefined2 *)((int)lpmp + 2),*(undefined2 *)&lpmp->lpmsgplrNext);
  }
  penvMemSav = _penvMem;
  _penvMem = &env;
  iVar1 = PUBLIC::__setjmp(&env);
  if (iVar1 == 0) goto LAB_1030_9b3a;
  _penvMem = penvMemSav;
  fOOM = 1;
  while( true ) {
    IO::ReadRt();
LAB_1030_9b3a:
    if (c_common::hdrCur >> 10 != 0x28) break;
    if (fOOM == 0) {
      pvVar3 = MEMORY::LpAlloc(c_common::hdrCur & 0x3ff,8);
      uVar2 = (undefined2)((ulong)lpmp >> 0x10);
      *(int *)&lpmp->lpmsgplrNext = (int)pvVar3;
      *(undefined2 *)((int)lpmp + 2) = (int)((ulong)pvVar3 >> 0x10);
      iVar1 = *(int *)&lpmp->lpmsgplrNext;
      uVar2 = *(undefined2 *)((int)lpmp + 2);
      lpmp = (MSGPLR *)CONCAT22(uVar2,iVar1);
      PUBLIC::__fmemcpy(iVar1,uVar2,(int)&c_common::rgbCur,0x1120,c_common::hdrCur & 0x3ff);
      *(undefined2 *)&lpmp->lpmsgplrNext = 0;
      *(undefined2 *)(iVar1 + 2) = 0;
      _DATA::vcmsgplrIn = _DATA::vcmsgplrIn + 1;
    }
  }
  _DATA::iMsgCur = -1;
  _DATA::iMsgCur = IMsgNext(0);
  return;
}



// ======================================================================
// Function: ReadRt
// Address: 1070:5168
// ======================================================================


void __cdecl16far IO::ReadRt(void)

{
  RgFromStream(&c_common::hdrCur,2);
  if ((c_common::hdrCur & 0x3ff) != 0) {
    RgFromStream(&c_common::rgbCur,c_common::hdrCur & 0x3ff);
  }
  if (c_common::hdrCur >> 10 == 8) {
    UTILGEN::SetFileXorStream
              (CONCAT22(DAT_1120_4b9e,DAT_1120_4b9c),DAT_1120_4ba4 >> 5,DAT_1120_4ba2,
               (DAT_1120_4ba4 << 0xb) >> 0xb,DAT_1120_4ba6 >> 0xc & 1);
  }
  else if (c_common::hdrCur >> 10 != 0) {
    UTILGEN::XorFileBuf((char *)&c_common::rgbCur,c_common::hdrCur & 0x3ff);
  }
  return;
}



// ======================================================================
// Function: ReadRtPlr
// Address: 1070:05e2
// ======================================================================


void __cdecl16far IO::ReadRtPlr(PLAYER *pplr,byte *pbIn)

{
  int iVar1;
  short cOut;
  PLAYER *pplrRaw;
  short iOff;
  
  pplrRaw = (PLAYER *)pbIn;
  PUBLIC::_memset(pplr,0,0xc0);
  if ((pplrRaw->wMdPlr & 7U) == 7) {
    PUBLIC::_memmove(pplr,pbIn,0x70);
    PUBLIC::_memmove(pplr->rgmdRelation,pbIn + 0x71,pbIn[0x70]);
    iOff = pbIn[0x70] + 0x71;
  }
  else {
    PUBLIC::_memmove(pplr,pbIn,8);
    iOff = 8;
  }
  if (pbIn[iOff] == 0) {
    PUBLIC::_strcpy();
    iVar1 = PUBLIC::_strlen(pplr->szName);
    iOff = iOff + iVar1 + 2;
  }
  else {
    cOut = 0x20;
    UTILGEN::FDecompressUserString
              ((char *)CONCAT22(0x1120,pbIn + iOff + 1),(uint)pbIn[iOff],
               (char *)CONCAT22(0x1120,pplr->szName),&cOut);
    iOff = iOff + pbIn[iOff] + 1;
  }
  if ((_DATA::wVersFile >> 5 & 0x7f) < 0x37) {
    cOut = (short)UTIL::PszPlayerName(0,*(byte *)(pplr->szName[0] + 0x175f) & 1,1,0,0,pplr);
    PUBLIC::_strcpy();
  }
  else if (pbIn[iOff] == 0) {
    PUBLIC::_strcpy();
  }
  else {
    cOut = 0x20;
    UTILGEN::FDecompressUserString
              ((char *)CONCAT22(0x1120,pbIn + iOff + 1),(uint)pbIn[iOff],
               (char *)CONCAT22(0x1120,pplr->szNames),&cOut);
  }
  pplr->wFlags = pplr->wFlags & 0xfff7;
  return;
}



// ======================================================================
// Function: ResetHb
// Address: 1060:0348
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far MEMORY::ResetHb(short ht)

{
  int iVar1;
  HB *lphb;
  
  lphb = (HB *)CONCAT22(*(undefined2 *)(ht * 4 + 0xd36),*(undefined2 *)(ht * 4 + 0xd34));
  while( true ) {
    if (((int)lphb == 0) && (lphb._2_2_ == 0)) break;
    *(undefined2 *)((int)lphb + 6) = 0x10;
    iVar1 = *(int *)((int)lphb + 2) + -0x10;
    *(int *)((int)lphb + 4) = iVar1;
    lphb->cbFree = iVar1;
    lphb = (HB *)CONCAT22(*(undefined2 *)((int)lphb + 10),*(undefined2 *)((int)lphb + 8));
  }
  return;
}



// ======================================================================
// Function: ResetMessages
// Address: 1030:98d6
// ======================================================================


void __cdecl16far MSG::ResetMessages(void)

{
  _DATA::imemMsgCur = 0;
  _DATA::iMsgCur = -1;
  _DATA::cMsg = 0;
  _DATA::iMsgSendCur = 0;
  PUBLIC::_memset((int)&c_common::bitfMsgSent,0,0x31);
  PUBLIC::_memset((int)&c_common::bitfMsgFiltered,0,0x31);
  _DATA::vlpmsgplrIn._0_2_ = 0;
  _DATA::vlpmsgplrIn._2_2_ = 0;
  _DATA::vlpmsgplrOut._0_2_ = 0;
  _DATA::vlpmsgplrOut._2_2_ = 0;
  _DATA::vcmsgplrIn = 0;
  _DATA::vcmsgplrOut = 0;
  return;
}



// ======================================================================
// Function: RgFromStream
// Address: 1070:53f4
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void __cdecl16far IO::RgFromStream(void *rg,ushort cb)

{
  ushort uVar1;
  undefined2 unaff_CS;
  int iVar2;
  
  if (cb != 0) {
    if (((int)_DATA::vlpMemStream == 0) && (_DATA::vlpMemStream._2_2_ == 0)) {
      iVar2 = _DATA::hf;
      uVar1 = _LREAD(unaff_CS,cb,rg);
      if (uVar1 != cb) {
        FileError(3);
        PUBLIC::_longjmp(_penvMem,0xffff,iVar2);
      }
    }
    else {
      PUBLIC::__fmemcpy(rg,(int)_DATA::vlpMemStream,_DATA::vlpMemStream._2_2_,cb);
      _DATA::vlpMemStream._0_2_ = (int)_DATA::vlpMemStream + cb;
    }
  }
  return;
}



// ======================================================================
// Function: SetFileXorStream
// Address: 1040:1aa6
// ======================================================================


void __cdecl16far
UTILGEN::SetFileXorStream(long lid,short lSalt,short turn,short iPlayer,short fCrippled)

{
  short b;
  short a;
  
  a = lSalt & 0x1f;
  b = lSalt >> 5 & 0x1f;
  if ((lSalt & 0x400U) == 0) {
    b = b + 0x20;
  }
  else {
    a = a + 0x20;
  }
  _BSS::lFileSeed1._0_2_ = *(int *)((int)_DATA::vrptFleet.rgbdx + 6 + a * 2);
  _BSS::lFileSeed1._2_2_ = (int)_BSS::lFileSeed1 >> 0xf;
  _BSS::lFileSeed2._0_2_ = *(int *)((int)_DATA::vrptFleet.rgbdx + 6 + b * 2);
  _BSS::lFileSeed2._2_2_ = (int)_BSS::lFileSeed2 >> 0xf;
  a = (((uint)lid & 3) + 1) * ((turn & 3U) + 1) * ((iPlayer & 3U) + 1) + fCrippled;
  while (0 < a) {
    LGetNextFileXor();
    a = a + -1;
  }
  return;
}



// ======================================================================
// Function: SetSzWorkFromDt
// Address: 1070:8cfe
// ======================================================================


void __cdecl16far IO::SetSzWorkFromDt(ushort dt,short iPlayer)

{
  undefined *puVar1;
  undefined *puVar2;
  int iVar3;
  undefined2 uVar4;
  char *pchDot;
  short c;
  char *pchSlash;
  
  puVar1 = (undefined *)PUBLIC::_strrchr((int)&c_common::szBase,0x2e);
  if ((puVar1 != (undefined *)0x0) &&
     ((puVar2 = (undefined *)PUBLIC::_strrchr((int)&c_common::szBase,0x5c),
      puVar2 == (undefined *)0x0 || (puVar2 < puVar1)))) {
    *puVar1 = 0;
  }
  iVar3 = _WSPRINTF(0x1118,(int)&c_common::szWork,0x1120,0xa0c,0x1120,(int)&c_common::szBase,0x1120)
  ;
  if (dt == 0) {
LAB_1070_8d76:
    PUBLIC::_strcat((int)&c_common::szWork,0xa10);
  }
  else {
    if (dt != 1) {
      if (dt == 2) {
        PUBLIC::_strcat((int)&c_common::szWork,0xa13);
        return;
      }
      if ((dt != 3) && (dt != 4)) goto LAB_1070_8d76;
    }
    if (dt == 1) {
      uVar4 = 0x78;
    }
    else if (dt == 4) {
      uVar4 = 0x68;
    }
    else {
      uVar4 = 0x6d;
    }
    _WSPRINTF(0x14f8,(int)&c_common::szWork + iVar3,0x1120,0xa17,0x1120,uVar4,iPlayer + 1);
  }
  return;
}



// ======================================================================
// Function: StreamClose
// Address: 1070:53cc
// ======================================================================


void __cdecl16far IO::StreamClose(void)

{
  if (_DATA::hf != -1) {
    _LCLOSE();
    _DATA::hf = -1;
  }
  return;
}



// ======================================================================
// Function: StreamOpen
// Address: 1070:52ae
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x1070536a) */
/* WARNING: Removing unreachable block (ram,0x10705391) */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void __cdecl16far IO::StreamOpen(char *szFile,short mdOpen)

{
  ulong uVar1;
  undefined2 unaff_CS;
  undefined2 unaff_SS;
  ulong uVar2;
  ulong uVar3;
  undefined2 uVar4;
  ulong dwTickCur;
  short fNoErr;
  OFSTRUCT of;
  ulong dwTick;
  
  uVar1 = 0;
  while( true ) {
    uVar4 = 0x1120;
    _DATA::hf = OPENFILE(unaff_CS,mdOpen & 0xbfff,&of,unaff_SS,szFile);
    if (_DATA::hf != -1) {
      return;
    }
    if ((((uint)_DATA::gd.flags1 >> 9 & 1) == 0) || (of.nErrCode == 2)) break;
    uVar2 = GETTICKCOUNT(0x14f8,uVar4);
    if (uVar1 == 0) {
      uVar1 = uVar2 + 4000;
    }
    if (uVar1 <= uVar2) break;
    do {
      unaff_CS = 0x14f8;
      uVar3 = GETTICKCOUNT(0x14f8,uVar4);
    } while (uVar3 < uVar2 + 500);
  }
  if ((mdOpen & 0x4000U) == 0) {
    FileError(4);
  }
  PUBLIC::_longjmp(_penvMem,0xffff);
  return;
}



// ======================================================================
// Function: UnpackBattlePlan
// Address: 1070:40ce
// ======================================================================


void __cdecl16far IO::UnpackBattlePlan(byte *lpb,BTLPLAN *lpbtlplan,short iplan)

{
  int iVar1;
  undefined2 unaff_SS;
  short cOut;
  short cch;
  char szName;
  char szTemp;
  
  iVar1 = (int)lpb;
  PUBLIC::__fmemmove();
  lpb = (byte *)CONCAT22(lpb._2_2_,(int)lpb + 4);
  cch = (short)*lpb;
  if (cch == 0) {
    PUBLIC::__fstrcpy((int)lpbtlplan + 4,lpbtlplan._2_2_,iVar1 + 5,lpb._2_2_);
  }
  else {
    cOut = 0x20;
    PUBLIC::__fmemmove();
    UTILGEN::FDecompressUserString
              ((char *)CONCAT22(unaff_SS,&szTemp),cch,(char *)CONCAT22(unaff_SS,&szName),&cOut);
    PUBLIC::__fmemmove();
  }
  lpbtlplan->flags1 = lpbtlplan->flags1 & 0xff0fU | (iplan & 0xfU) << 4;
  return;
}



// ======================================================================
// Function: UpdateBattleRecords
// Address: 1070:41ac
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far IO::UpdateBattleRecords(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  undefined2 uVar5;
  undefined2 uVar6;
  short itok;
  BTLREC26 *lpbr26;
  HB *lphb;
  short cKill;
  BTLREC *lpbr;
  BTLDATA *lpbd;
  
  lphb = (HB *)CONCAT22(DAT_1120_0d62,DAT_1120_0d60);
  if ((DAT_1120_0d60 != 0) || (DAT_1120_0d62 != 0)) {
    lpbd = (BTLDATA *)CONCAT22(DAT_1120_0d62,DAT_1120_0d60 + 0x12);
    while( true ) {
      while (lpbd->id == -1) {
        uVar5 = (undefined2)((ulong)lphb >> 0x10);
        iVar4 = *(int *)((int)lphb + 8);
        iVar2 = *(int *)((int)lphb + 10);
        lphb = (HB *)CONCAT22(iVar2,iVar4);
        if ((iVar4 == 0) && (iVar2 == 0)) {
          return;
        }
        if (*(uint *)(iVar4 + 6) < 0x11) {
          return;
        }
        lpbd = (BTLDATA *)CONCAT22(iVar2,iVar4 + 0x12);
      }
      uVar5 = (undefined2)((ulong)lpbd >> 0x10);
      iVar4 = (int)lpbd;
      if (*(int *)(iVar4 + 6) == 0) break;
      iVar2 = iVar4 + 0xe + (uint)*(byte *)(iVar4 + 3) * 0x1d;
      lpbr = (BTLREC *)CONCAT22(uVar5,iVar2);
      lpbr26 = (BTLREC26 *)CONCAT22(uVar5,iVar2);
      uVar3 = iVar4 + *(int *)(iVar4 + 6);
      lpbd = (BTLDATA *)CONCAT22(uVar5,uVar3);
      while ((uint)lpbr < uVar3) {
        uVar5 = (undefined2)((ulong)lpbr26 >> 0x10);
        bVar1 = *(byte *)((int)lpbr26 + 2);
        uVar6 = (undefined2)((ulong)lpbr >> 0x10);
        *(uint *)((uint)lpbr + 2) = (uint)*(byte *)((int)lpbr26 + 3);
        *(uint *)((uint)lpbr + 4) = *(uint *)((uint)lpbr + 4) & 0xff | (uint)bVar1 << 8;
        iVar4 = (uint)lpbr + 6 + *(int *)((uint)lpbr + 2) * 8;
        lpbr26 = (BTLREC26 *)CONCAT22(uVar6,iVar4);
        lpbr = (BTLREC *)CONCAT22(uVar6,iVar4);
      }
    }
  }
  return;
}



// ======================================================================
// Function: UpdateShdefCost
// Address: 1038:47b0
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far UTIL::UpdateShdefCost(SHDEF *lpshdef)

{
  ulong *puVar1;
  int *piVar2;
  short sVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  short *psVar8;
  undefined2 uVar9;
  undefined2 uVar10;
  bool bVar11;
  PART part;
  ulong rgMin;
  ulong resCost;
  HUL *lphul;
  short fWeakArmor;
  ushort rgCosts;
  uint local_10;
  short c;
  short k;
  ulong wt;
  short dpT;
  
  uVar9 = (undefined2)((ulong)lpshdef >> 0x10);
  iVar6 = (int)lpshdef;
  if ((*(uint *)(iVar6 + 0x7b) & 0xff) == 7) {
    sVar3 = RACE::GetRaceGrbit((PLAYER *)((int)&c_common::rgplr + _DATA::idPlayer * 0xc0),0xd);
    fWeakArmor = (short)(sVar3 != 0);
  }
  else {
    fWeakArmor = 0;
  }
  part.pterra = (TERRA *)PARTS::LphuldefFromId((lpshdef->hul).ihuldef);
  part.hs.grhst = 0;
  lphul = (HUL *)part.pterra;
  SHIP::GetTruePartCost(_DATA::idPlayer,&part,&rgCosts);
  for (c = 0; c < 3; c = c + 1) {
    iVar7 = c * 4;
    *(ushort *)(&rgMin + c) = (&rgCosts)[c];
    *(undefined2 *)((int)&rgMin + iVar7 + 2) = 0;
  }
  resCost._0_2_ = local_10;
  resCost._2_2_ = 0;
  uVar10 = (undefined2)((ulong)lphul >> 0x10);
  wt._0_2_ = *(uint *)((int)lphul + 0x28);
  wt._2_2_ = 0;
  *(undefined2 *)(iVar6 + 0x38) = *(undefined2 *)((int)lphul + 0x38);
  lphul = &lpshdef->hul;
  c = 0;
  while( true ) {
    uVar10 = (undefined2)((ulong)lphul >> 0x10);
    iVar7 = (int)lphul;
    if ((int)(uint)*(byte *)(iVar7 + 0x7a) <= c) break;
    if (*(uint *)(iVar7 + c * 4 + 0x3c) >> 8 != 0) {
      psVar8 = (short *)(iVar7 + 0x3a + c * 4);
      part.hs.grhst = *psVar8;
      part.hs.flags2 = psVar8[1];
      PARTS::FLookupPart(&part);
      SHIP::GetTruePartCost(_DATA::idPlayer,&part,&rgCosts);
      k = 0;
      while( true ) {
        if (2 < k) break;
        uVar4 = (*(uint *)((int)lphul + c * 4 + 0x3c) >> 8) * (&rgCosts)[k];
        iVar7 = k * 4;
        puVar1 = &rgMin + k;
        uVar5 = *(uint *)puVar1;
        *(uint *)puVar1 = *(uint *)puVar1 + uVar4;
        piVar2 = (int *)((int)&rgMin + iVar7 + 2);
        *piVar2 = *piVar2 + (uint)CARRY2(uVar5,uVar4);
        k = k + 1;
      }
      uVar5 = (*(uint *)((int)lphul + c * 4 + 0x3c) >> 8) * local_10;
      bVar11 = CARRY2((uint)resCost,uVar5);
      resCost._0_2_ = (uint)resCost + uVar5;
      resCost._2_2_ = resCost._2_2_ + (uint)bVar11;
      uVar10 = (undefined2)((ulong)part.pterra >> 0x10);
      uVar5 = (*(uint *)((int)lphul + c * 4 + 0x3c) >> 8) * *(int *)((int)part.pterra + 0x28);
      bVar11 = CARRY2((uint)wt,uVar5);
      wt._0_2_ = (uint)wt + uVar5;
      wt._2_2_ = wt._2_2_ + (uint)bVar11;
      iVar7 = *(int *)((int)lphul + 0x3a + c * 4);
      if (iVar7 == 4) {
        if (((*(uint *)((int)lphul + c * 4 + 0x3c) & 0xff) == 3) ||
           ((*(uint *)((int)lphul + c * 4 + 0x3c) & 0xff) == 6)) {
          piVar2 = (int *)((int)lphul + 0x38);
          *piVar2 = *piVar2 + (*(uint *)((int)lphul + c * 4 + 0x3c) >> 8) * 0x41;
        }
      }
      else if (iVar7 == 8) {
        dpT = (*(uint *)((int)lphul + c * 4 + 0x3c) >> 8) * *(int *)((int)part.pterra + 0x34);
        if (fWeakArmor != 0) {
          dpT = dpT >> 1;
        }
        piVar2 = (int *)((int)lphul + 0x38);
        *piVar2 = *piVar2 + dpT;
      }
      else if ((iVar7 == 0x1000) && ((*(uint *)((int)lphul + c * 4 + 0x3c) & 0xff) == 4)) {
        piVar2 = (int *)((int)lphul + 0x38);
        *piVar2 = *piVar2 + (*(uint *)((int)lphul + c * 4 + 0x3c) >> 8) * 0x32;
      }
    }
    c = c + 1;
  }
  for (c = 0; c < 3; c = c + 1) {
    *(undefined2 *)(iVar7 + 0x2c + c * 2) = *(undefined2 *)(&rgMin + c);
  }
  *(uint *)(iVar7 + 0x2a) = (uint)resCost;
  *(uint *)(iVar7 + 0x28) = (uint)wt;
  *(undefined2 *)(iVar6 + 0x87) = 0xffff;
  *(undefined2 *)(iVar6 + 0x89) = 0xffff;
  return;
}



// ======================================================================
// Function: XorFileBuf
// Address: 1040:1cc4
// ======================================================================


void __cdecl16far UTILGEN::XorFileBuf(char *rgb,short cb)

{
  long *plVar1;
  uint *puVar2;
  byte *pbVar3;
  byte bVar4;
  uint uVar5;
  uint in_DX;
  char *pch;
  long lPrev;
  long *pl;
  long *plMac;
  
  for (pl = (long *)rgb; pl < rgb + (cb >> 2) * 4; pl = pl + 1) {
    uVar5 = LGetNextFileXor();
    plVar1 = pl;
    *(uint *)plVar1 = *(uint *)plVar1 ^ uVar5;
    puVar2 = (uint *)((int)pl + 2);
    *puVar2 = *puVar2 ^ in_DX;
  }
  if ((cb & 3U) != 0) {
    pch = (char *)pl;
    bVar4 = LGetNextFileXor();
    cb = cb & 3U;
    while (cb != 0) {
      pbVar3 = (byte *)pch;
      *pbVar3 = *pbVar3 ^ bVar4;
      bVar4 = PUBLIC::__aFlshr();
      pch = pch + 1;
      cb = cb + -1;
    }
  }
  return;
}



// ======================================================================
// Function: __aFahdiff
// Address: 1118:1618
// ======================================================================


undefined4 __pascal16far PUBLIC::__aFahdiff(uint param_1_00,undefined2 param_1,uint param_2)

{
  return CONCAT22(-(uint)(param_1_00 < param_2),param_1_00 - param_2);
}



// ======================================================================
// Function: __aFldiv
// Address: 1118:0be4
// ======================================================================


undefined4 __pascal16far PUBLIC::__aFldiv(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulong uVar1;
  long lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulong)param_2 % (ulong)param_3 << 0x10 | (ulong)param_1) / (ulong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0xf;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0xf;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT22(uVar7,uVar3) / (ulong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulong)param_3 * (uVar1 & 0xffff);
    uVar3 = (uint)((ulong)lVar2 >> 0x10);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY2(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT22(uVar3,iVar4);
}



// ======================================================================
// Function: __aFlshl
// Address: 1118:0d50
// ======================================================================


void __cdecl16far PUBLIC::__aFlshl(void)

{
  uint in_CX;
  uint uVar1;
  
  for (uVar1 = in_CX & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {
  }
  return;
}



// ======================================================================
// Function: __aFulmul
// Address: 1118:0c7e
// ======================================================================


long __pascal16far PUBLIC::__aFulmul(uint param_1,uint param_2,uint param_3,uint param_4)

{
  if ((param_4 | param_2) == 0) {
    return (ulong)param_1 * (ulong)param_3;
  }
  return CONCAT22((int)((ulong)param_1 * (ulong)param_3 >> 0x10) +
                  param_2 * param_3 + param_1 * param_4,(int)((ulong)param_1 * (ulong)param_3));
}



// ======================================================================
// Function: __aFulshr
// Address: 1118:0e32
// ======================================================================


void __cdecl16far PUBLIC::__aFulshr(void)

{
  uint in_CX;
  uint uVar1;
  
  for (uVar1 = in_CX & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {
  }
  return;
}



// ======================================================================
// Function: __access
// Address: 1118:0a16
// ======================================================================


void PUBLIC::__access(void)

{
  code *pcVar1;
  int unaff_BP;
  
  if ((DAT_1118_0010 & 1) == 0) {
    pcVar1 = (code *)swi(0x21);
    (*pcVar1)(unaff_BP + 1);
  }
  else {
    DOS3CALL(0x1118,0x1120);
  }
  __dosret0();
  return;
}



// ======================================================================
// Function: __filelength
// Address: 1118:0470
// ======================================================================


undefined2 __cdecl16far PUBLIC::__filelength(int param_1)

{
  int iVar1;
  long lVar2;
  long lVar3;
  undefined2 uVar4;
  
  if (-1 < param_1) {
    iVar1 = DAT_1120_1722;
    if (DAT_1120_1aa6 != 0) {
      iVar1 = DAT_1120_1726;
    }
    if (param_1 < iVar1) {
      uVar4 = 1;
      lVar2 = __lseek();
      if (lVar2 == -1) {
        return 0xffff;
      }
      lVar3 = __lseek(0x1118,param_1,0,0,2,uVar4);
      if (lVar3 == lVar2) {
        return (int)lVar3;
      }
      __lseek(0x1118,param_1,lVar2,0);
      return (int)lVar3;
    }
  }
  DAT_1120_1710 = 9;
  return 0xffff;
}



// ======================================================================
// Function: __fmemcpy
// Address: 1118:0e9a
// ======================================================================


undefined2 * __cdecl16far PUBLIC::__fmemcpy(undefined4 param_1,undefined4 param_2,int param_3)

{
  undefined2 *puVar1;
  undefined2 *puVar2;
  uint uVar3;
  uint uVar4;
  undefined2 *puVar5;
  undefined2 *puVar6;
  int iVar7;
  int iVar8;
  
  if (param_3 != 0) {
    iVar8 = (int)((ulong)param_2 >> 0x10);
    puVar5 = (undefined2 *)param_2;
    iVar7 = (int)((ulong)param_1 >> 0x10);
    puVar6 = (undefined2 *)param_1;
    while( true ) {
      uVar3 = ~(uint)puVar6;
      uVar3 = ((param_3 - 1U) - uVar3 & -(uint)(param_3 - 1U < uVar3)) + uVar3;
      uVar4 = ~(uint)puVar5;
      uVar3 = (uVar3 - uVar4 & -(uint)(uVar3 < uVar4)) + uVar4 + 1;
      param_3 = param_3 - uVar3;
      for (uVar4 = uVar3 >> 1; uVar4 != 0; uVar4 = uVar4 - 1) {
        puVar2 = puVar6;
        puVar6 = puVar6 + 1;
        puVar1 = puVar5;
        puVar5 = puVar5 + 1;
        *puVar2 = *puVar1;
      }
      for (uVar3 = (uint)((uVar3 & 1) != 0); uVar3 != 0; uVar3 = uVar3 - 1) {
        puVar2 = puVar6;
        puVar6 = (undefined2 *)((int)puVar6 + 1);
        puVar1 = puVar5;
        puVar5 = (undefined2 *)((int)puVar5 + 1);
        *(undefined *)puVar2 = *(undefined *)puVar1;
      }
      if (param_3 == 0) break;
      if (puVar5 == (undefined2 *)0x0) {
        iVar8 = iVar8 + 0x94;
      }
      if (puVar6 == (undefined2 *)0x0) {
        iVar7 = iVar7 + 0x94;
      }
    }
  }
  return (undefined2 *)param_1;
}



// ======================================================================
// Function: __fmemmove
// Address: 1118:105a
// ======================================================================


undefined2 * __cdecl16far PUBLIC::__fmemmove(undefined4 param_1,undefined4 param_2,uint param_3)

{
  undefined *puVar1;
  undefined2 *puVar2;
  undefined *puVar3;
  undefined2 *puVar4;
  undefined *puVar5;
  uint uVar6;
  uint uVar7;
  undefined2 *puVar8;
  undefined *puVar9;
  undefined2 *puVar10;
  undefined *puVar11;
  undefined2 *puVar12;
  int iVar13;
  int iVar14;
  long lVar15;
  
  puVar10 = (undefined2 *)param_1;
  if (param_3 != 0) {
    iVar14 = (int)((ulong)param_2 >> 0x10);
    puVar8 = (undefined2 *)param_2;
    iVar13 = (int)((ulong)param_1 >> 0x10);
    lVar15 = __aFahdiff(puVar10,iVar13,puVar8,iVar14);
    puVar12 = puVar10;
    if ((lVar15 < 0) || ((uint)((uint)lVar15 < param_3) <= (uint)((ulong)lVar15 >> 0x10))) {
      while( true ) {
        uVar6 = ~(uint)puVar12;
        uVar6 = ((param_3 - 1) - uVar6 & -(uint)(param_3 - 1 < uVar6)) + uVar6;
        uVar7 = ~(uint)puVar8;
        uVar6 = (uVar6 - uVar7 & -(uint)(uVar6 < uVar7)) + uVar7 + 1;
        param_3 = param_3 - uVar6;
        for (uVar7 = uVar6 >> 1; uVar7 != 0; uVar7 = uVar7 - 1) {
          puVar4 = puVar12;
          puVar12 = puVar12 + 1;
          puVar2 = puVar8;
          puVar8 = puVar8 + 1;
          *puVar4 = *puVar2;
        }
        for (uVar6 = (uint)((uVar6 & 1) != 0); uVar6 != 0; uVar6 = uVar6 - 1) {
          puVar4 = puVar12;
          puVar12 = (undefined2 *)((int)puVar12 + 1);
          puVar2 = puVar8;
          puVar8 = (undefined2 *)((int)puVar8 + 1);
          *(undefined *)puVar4 = *(undefined *)puVar2;
        }
        if (param_3 == 0) break;
        if (puVar8 == (undefined2 *)0x0) {
          iVar14 = iVar14 + 0x94;
        }
        if (puVar12 == (undefined2 *)0x0) {
          iVar13 = iVar13 + 0x94;
        }
      }
    }
    else {
      uVar6 = param_3 - 1;
      puVar9 = (undefined *)((int)puVar8 + uVar6);
      if (CARRY2((uint)puVar8,uVar6)) {
        iVar14 = iVar14 + 0x94;
      }
      puVar11 = (undefined *)((int)puVar10 + uVar6);
      if (CARRY2((uint)puVar10,uVar6)) {
        iVar13 = iVar13 + 0x94;
      }
      while( true ) {
        puVar5 = puVar9 + ((int)(puVar11 +
                                ((int)(undefined *)(param_3 - 1) - (int)puVar11 &
                                -(uint)((undefined *)(param_3 - 1) < puVar11))) - (int)puVar9 &
                          -(uint)(puVar11 + ((int)(undefined *)(param_3 - 1) - (int)puVar11 &
                                            -(uint)((undefined *)(param_3 - 1) < puVar11)) < puVar9)
                          ) + 1;
        param_3 = param_3 - (int)puVar5;
        for (; puVar5 != (undefined *)0x0; puVar5 = puVar5 + -1) {
          puVar3 = puVar11;
          puVar11 = puVar11 + -1;
          puVar1 = puVar9;
          puVar9 = puVar9 + -1;
          *puVar3 = *puVar1;
        }
        if (param_3 == 0) break;
        if (puVar9 == (undefined *)0xffff) {
          iVar14 = iVar14 + -0x94;
        }
        if (puVar11 == (undefined *)0xffff) {
          iVar13 = iVar13 + -0x94;
        }
      }
    }
  }
  return puVar10;
}



// ======================================================================
// Function: __fmemset
// Address: 1118:1012
// ======================================================================


undefined2 * __cdecl16far PUBLIC::__fmemset(undefined4 param_1,undefined param_2,uint param_3)

{
  undefined2 *puVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined2 *puVar5;
  int iVar6;
  
  if (param_3 != 0) {
    iVar6 = (int)((ulong)param_1 >> 0x10);
    uVar3 = -(int)(undefined2 *)param_1;
    uVar4 = param_3;
    if (uVar3 != 0) {
      uVar4 = (uVar3 - param_3 & -(uint)(uVar3 < param_3)) + param_3;
      uVar3 = param_3 - uVar4;
    }
    puVar5 = (undefined2 *)param_1;
    for (uVar2 = uVar4 >> 1; uVar2 != 0; uVar2 = uVar2 - 1) {
      puVar1 = puVar5;
      puVar5 = puVar5 + 1;
      *puVar1 = CONCAT11(param_2,param_2);
    }
    for (uVar4 = (uint)((uVar4 & 1) != 0); uVar4 != 0; uVar4 = uVar4 - 1) {
      puVar1 = puVar5;
      puVar5 = (undefined2 *)((int)puVar5 + 1);
      *(undefined *)puVar1 = param_2;
    }
    if (uVar3 != 0) {
      for (uVar4 = uVar3 >> 1; uVar4 != 0; uVar4 = uVar4 - 1) {
        puVar1 = puVar5;
        puVar5 = puVar5 + 1;
        *puVar1 = CONCAT11(param_2,param_2);
      }
      for (uVar4 = (uint)((uVar3 & 1) != 0); uVar4 != 0; uVar4 = uVar4 - 1) {
        puVar1 = puVar5;
        puVar5 = (undefined2 *)((int)puVar5 + 1);
        *(undefined *)puVar1 = param_2;
      }
    }
  }
  return (undefined2 *)param_1;
}



// ======================================================================
// Function: __fstrcpy
// Address: 1118:0f82
// ======================================================================


void __cdecl16far PUBLIC::__fstrcpy(undefined2 *param_1,undefined2 *param_2)

{
  undefined2 *puVar1;
  undefined2 *puVar2;
  uint uVar3;
  uint uVar4;
  undefined2 *puVar5;
  undefined2 *puVar6;
  undefined2 uVar7;
  undefined2 uVar8;
  bool bVar9;
  
  uVar8 = (undefined2)((ulong)param_2 >> 0x10);
  puVar5 = (undefined2 *)param_2;
  bVar9 = true;
  uVar3 = 0xffff;
  puVar6 = puVar5;
  do {
    if (uVar3 == 0) break;
    uVar3 = uVar3 - 1;
    puVar1 = puVar6;
    puVar6 = (undefined2 *)((int)puVar6 + 1);
    bVar9 = *(char *)puVar1 == '\0';
  } while (!bVar9);
  uVar3 = ~uVar3;
  uVar7 = (undefined2)((ulong)param_1 >> 0x10);
  puVar6 = (undefined2 *)param_1;
  if (bVar9) {
    if (((ulong)param_1 & 1) != 0) {
      puVar6 = (undefined2 *)((int)puVar6 + 1);
      puVar5 = (undefined2 *)((int)puVar5 + 1);
      *(undefined *)param_1 = *(undefined *)param_2;
      uVar3 = uVar3 - 1;
    }
  }
  else {
    puVar6 = puVar6 + 1;
    puVar5 = puVar5 + 1;
    *param_1 = *param_2;
    uVar3 = uVar3 - 1;
  }
  for (uVar4 = uVar3 >> 1; uVar4 != 0; uVar4 = uVar4 - 1) {
    puVar2 = puVar6;
    puVar6 = puVar6 + 1;
    puVar1 = puVar5;
    puVar5 = puVar5 + 1;
    *puVar2 = *puVar1;
  }
  for (uVar3 = (uint)((uVar3 & 1) != 0); uVar3 != 0; uVar3 = uVar3 - 1) {
    puVar2 = puVar6;
    puVar6 = (undefined2 *)((int)puVar6 + 1);
    puVar1 = puVar5;
    puVar5 = (undefined2 *)((int)puVar5 + 1);
    *(undefined *)puVar2 = *(undefined *)puVar1;
  }
  return;
}



// ======================================================================
// Function: __fstricmp
// Address: 1118:0ef8
// ======================================================================


int __cdecl16far PUBLIC::__fstricmp(undefined4 param_1,undefined4 param_2)

{
  byte *pbVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte *pbVar5;
  byte *pbVar6;
  
  pbVar6 = (byte *)param_2;
  pbVar5 = (byte *)param_1;
  bVar4 = 0xff;
  do {
    do {
      if (bVar4 == 0) goto LAB_1118_0f37;
      pbVar1 = pbVar6;
      pbVar6 = pbVar6 + 1;
      bVar4 = *pbVar1;
      bVar3 = *pbVar5;
      pbVar5 = pbVar5 + 1;
    } while (bVar3 == bVar4);
    bVar2 = bVar4 + 0xbf + (-((byte)(bVar4 + 0xbf) < 0x1a) & 0x20U) + 0x41;
    bVar3 = bVar3 + 0xbf;
    bVar4 = bVar3 + (-(bVar3 < 0x1a) & 0x20U) + 0x41;
  } while (bVar4 == bVar2);
  bVar4 = (bVar4 < bVar2) * -2 + 1;
LAB_1118_0f37:
  return (int)(char)bVar4;
}



// ======================================================================
// Function: __lseek
// Address: 1118:027e
// ======================================================================


void PUBLIC::__lseek(undefined2 param_1_00,uint param_1,uint param_2,uint param_3,uint param_4)

{
  byte *pbVar1;
  code *pcVar2;
  undefined uVar3;
  undefined4 uVar4;
  
  if (((DAT_1120_1722 <= param_1) && (DAT_1120_1aa6 != 0)) && (param_1 < 3)) goto LAB_1118_034f;
  if ((DAT_1120_1894 != 0) && ((param_3 & 0x8000) != 0)) {
    if (param_4 == 0) goto LAB_1118_034f;
    uVar3 = 0;
    if ((DAT_1118_0010 & 1) == 0) {
      pcVar2 = (code *)swi(0x21);
      uVar4 = (*pcVar2)();
    }
    else {
      uVar4 = DOS3CALL(0x1118);
    }
    if ((bool)uVar3) goto LAB_1118_034f;
    if ((param_4 & 2) == 0) {
      if ((int)((int)((ulong)uVar4 >> 0x10) + param_3 + (uint)CARRY2((uint)uVar4,param_2)) < 0)
      goto LAB_1118_034f;
    }
    else {
      if ((DAT_1118_0010 & 1) == 0) {
        pcVar2 = (code *)swi(0x21);
        uVar4 = (*pcVar2)(uVar4);
      }
      else {
        uVar4 = DOS3CALL(0x1118);
      }
      if ((int)((int)((ulong)uVar4 >> 0x10) + param_3 + (uint)CARRY2((uint)uVar4,param_2)) < 0) {
        if ((DAT_1118_0010 & 1) == 0) {
          pcVar2 = (code *)swi(0x21);
          (*pcVar2)();
        }
        else {
          DOS3CALL(0x1118);
        }
        goto LAB_1118_034f;
      }
    }
  }
  uVar3 = 0;
  if ((DAT_1118_0010 & 1) == 0) {
    pcVar2 = (code *)swi(0x21);
    (*pcVar2)();
  }
  else {
    DOS3CALL();
  }
  if (!(bool)uVar3) {
    pbVar1 = (byte *)(param_1 + 0x1728);
    *pbVar1 = *pbVar1 & 0xfd;
  }
LAB_1118_034f:
  __dosretax();
  return;
}



// ======================================================================
// Function: __setjmp
// Address: 1118:09c8
// ======================================================================


undefined2 __cdecl16far PUBLIC::__setjmp(int *param_1)

{
  int unaff_BP;
  int unaff_SI;
  int unaff_DI;
  int in_stack_00000000;
  int in_stack_00000002;
  
  *param_1 = unaff_BP + 1;
  param_1[1] = unaff_DI;
  param_1[2] = unaff_SI;
  param_1[3] = (int)register0x00000010;
  param_1[4] = in_stack_00000000;
  param_1[5] = in_stack_00000002;
  return 0;
}



// ======================================================================
// Function: __strnicmp
// Address: 1118:0634
// ======================================================================


uint __cdecl16far PUBLIC::__strnicmp(byte *param_1,byte *param_2,uint param_3)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  
  if (param_3 != 0) {
    do {
      bVar2 = *param_1;
      bVar1 = *param_2;
      if ((bVar2 == 0) || (bVar1 == 0)) break;
      param_1 = param_1 + 1;
      param_2 = param_2 + 1;
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        bVar2 = bVar2 + 0x20;
      }
      if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
        bVar1 = bVar1 + 0x20;
      }
      bVar3 = bVar2 < bVar1;
      if (bVar2 != bVar1) goto LAB_1118_067a;
      param_3 = param_3 - 1;
    } while (param_3 != 0);
    param_3 = 0;
    bVar3 = bVar2 < bVar1;
    if (bVar2 != bVar1) {
LAB_1118_067a:
      param_3 = 0;
      if (!bVar3) {
        param_3 = 0xfffe;
      }
      param_3 = ~param_3;
    }
  }
  return param_3;
}



// ======================================================================
// Function: __tell
// Address: 1118:0454
// ======================================================================


void __cdecl16far PUBLIC::__tell(void)

{
  __lseek();
  return;
}



// ======================================================================
// Function: _abs
// Address: 1118:079c
// ======================================================================


int __cdecl16far PUBLIC::_abs(uint param_1)

{
  return (param_1 ^ (int)param_1 >> 0xf) - ((int)param_1 >> 0xf);
}



// ======================================================================
// Function: _longjmp
// Address: 1118:09ed
// ======================================================================


int __cdecl16far PUBLIC::_longjmp(int param_1,int param_2)

{
  undefined2 *puVar1;
  undefined2 unaff_SS;
  
  if (param_2 == 0) {
    param_2 = 1;
  }
  puVar1 = (undefined2 *)*(int *)(param_1 + 6);
  *puVar1 = *(undefined2 *)(param_1 + 8);
  puVar1[1] = *(undefined2 *)(param_1 + 10);
  return param_2;
}



// ======================================================================
// Function: _memcpy
// Address: 1118:0742
// ======================================================================


void __cdecl16far PUBLIC::_memcpy(undefined2 *param_1,undefined2 *param_2,uint param_3)

{
  undefined2 *puVar1;
  undefined2 *puVar2;
  uint uVar3;
  
  if (param_3 != 0) {
    if (((uint)param_1 & 1) != 0) {
      puVar2 = param_1;
      param_1 = (undefined2 *)((int)param_1 + 1);
      puVar1 = param_2;
      param_2 = (undefined2 *)((int)param_2 + 1);
      *(undefined *)puVar2 = *(undefined *)puVar1;
      param_3 = param_3 - 1;
    }
    for (uVar3 = param_3 >> 1; uVar3 != 0; uVar3 = uVar3 - 1) {
      puVar2 = param_1;
      param_1 = param_1 + 1;
      puVar1 = param_2;
      param_2 = param_2 + 1;
      *puVar2 = *puVar1;
    }
    for (uVar3 = (uint)((param_3 & 1) != 0); uVar3 != 0; uVar3 = uVar3 - 1) {
      puVar2 = param_1;
      param_1 = (undefined2 *)((int)param_1 + 1);
      puVar1 = param_2;
      param_2 = (undefined2 *)((int)param_2 + 1);
      *(undefined *)puVar2 = *(undefined *)puVar1;
    }
  }
  return;
}



// ======================================================================
// Function: _memmove
// Address: 1118:06d2
// ======================================================================


undefined2 * __cdecl16far PUBLIC::_memmove(undefined2 *param_1,undefined2 *param_2,uint param_3)

{
  undefined2 *puVar1;
  undefined2 *puVar2;
  uint uVar3;
  undefined *puVar4;
  undefined *puVar5;
  undefined2 *puVar6;
  
  if (param_3 != 0) {
    if ((param_2 < param_1) && (param_1 < (undefined2 *)((int)param_2 + param_3))) {
      puVar4 = (undefined *)((int)param_2 + param_3);
      puVar5 = (undefined *)((int)param_1 + param_3);
      while( true ) {
        puVar5 = puVar5 + -1;
        puVar4 = puVar4 + -1;
        if (param_3 == 0) break;
        param_3 = param_3 - 1;
        *puVar5 = *puVar4;
      }
    }
    else {
      puVar6 = param_1;
      if (((uint)param_1 & 1) != 0) {
        puVar6 = (undefined2 *)((int)param_1 + 1);
        puVar1 = param_2;
        param_2 = (undefined2 *)((int)param_2 + 1);
        *(undefined *)param_1 = *(undefined *)puVar1;
        param_3 = param_3 - 1;
      }
      for (uVar3 = param_3 >> 1; uVar3 != 0; uVar3 = uVar3 - 1) {
        puVar2 = puVar6;
        puVar6 = puVar6 + 1;
        puVar1 = param_2;
        param_2 = param_2 + 1;
        *puVar2 = *puVar1;
      }
      for (uVar3 = (uint)((param_3 & 1) != 0); uVar3 != 0; uVar3 = uVar3 - 1) {
        puVar2 = puVar6;
        puVar6 = (undefined2 *)((int)puVar6 + 1);
        puVar1 = param_2;
        param_2 = (undefined2 *)((int)param_2 + 1);
        *(undefined *)puVar2 = *(undefined *)puVar1;
      }
    }
  }
  return param_1;
}



// ======================================================================
// Function: _memset
// Address: 1118:076e
// ======================================================================


undefined2 * __cdecl16far PUBLIC::_memset(undefined2 *param_1,undefined param_2,uint param_3)

{
  undefined2 *puVar1;
  uint uVar2;
  undefined2 *puVar3;
  
  if (param_3 != 0) {
    puVar3 = param_1;
    if (((uint)param_1 & 1) != 0) {
      puVar3 = (undefined2 *)((int)param_1 + 1);
      *(undefined *)param_1 = param_2;
      param_3 = param_3 - 1;
    }
    for (uVar2 = param_3 >> 1; uVar2 != 0; uVar2 = uVar2 - 1) {
      puVar1 = puVar3;
      puVar3 = puVar3 + 1;
      *puVar1 = CONCAT11(param_2,param_2);
    }
    for (uVar2 = (uint)((param_3 & 1) != 0); uVar2 != 0; uVar2 = uVar2 - 1) {
      puVar1 = puVar3;
      puVar3 = (undefined2 *)((int)puVar3 + 1);
      *(undefined *)puVar1 = param_2;
    }
  }
  return param_1;
}



// ======================================================================
// Function: _strcat
// Address: 1118:0352
// ======================================================================


undefined2 * __cdecl16far PUBLIC::_strcat(undefined2 *param_1,char *param_2)

{
  undefined2 *puVar1;
  char *pcVar2;
  undefined2 *puVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  undefined2 *puVar7;
  undefined2 *puVar8;
  undefined2 *puVar9;
  
  iVar4 = -1;
  puVar7 = param_1;
  do {
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    puVar1 = puVar7;
    puVar7 = (undefined2 *)((int)puVar7 + 1);
  } while (*(char *)puVar1 != '\0');
  uVar5 = 0xffff;
  do {
    if (uVar5 == 0) break;
    uVar5 = uVar5 - 1;
    pcVar2 = param_2;
    param_2 = param_2 + 1;
  } while (*pcVar2 != '\0');
  uVar5 = ~uVar5;
  puVar8 = (undefined2 *)(param_2 + -uVar5);
  puVar9 = (undefined2 *)((int)puVar7 + -1);
  if (((uint)puVar8 & 1) != 0) {
    puVar1 = puVar8;
    puVar8 = (undefined2 *)((int)puVar8 + 1);
    *(undefined *)(undefined2 *)((int)puVar7 + -1) = *(undefined *)puVar1;
    uVar5 = uVar5 - 1;
    puVar9 = puVar7;
  }
  for (uVar6 = uVar5 >> 1; uVar6 != 0; uVar6 = uVar6 - 1) {
    puVar3 = puVar9;
    puVar9 = puVar9 + 1;
    puVar1 = puVar8;
    puVar8 = puVar8 + 1;
    *puVar3 = *puVar1;
  }
  for (uVar5 = (uint)((uVar5 & 1) != 0); uVar5 != 0; uVar5 = uVar5 - 1) {
    puVar3 = puVar9;
    puVar9 = (undefined2 *)((int)puVar9 + 1);
    puVar1 = puVar8;
    puVar8 = (undefined2 *)((int)puVar8 + 1);
    *(undefined *)puVar3 = *(undefined *)puVar1;
  }
  return param_1;
}



// ======================================================================
// Function: _strcpy
// Address: 1118:0392
// ======================================================================


void __cdecl16far PUBLIC::_strcpy(undefined2 *param_1,undefined2 *param_2)

{
  undefined2 *puVar1;
  undefined2 *puVar2;
  uint uVar3;
  uint uVar4;
  undefined2 *puVar5;
  
  uVar3 = 0xffff;
  puVar5 = param_2;
  do {
    if (uVar3 == 0) break;
    uVar3 = uVar3 - 1;
    puVar1 = puVar5;
    puVar5 = (undefined2 *)((int)puVar5 + 1);
  } while (*(char *)puVar1 != '\0');
  uVar3 = ~uVar3;
  if (((uint)param_1 & 1) != 0) {
    puVar2 = param_1;
    param_1 = (undefined2 *)((int)param_1 + 1);
    puVar1 = param_2;
    param_2 = (undefined2 *)((int)param_2 + 1);
    *(undefined *)puVar2 = *(undefined *)puVar1;
    uVar3 = uVar3 - 1;
  }
  for (uVar4 = uVar3 >> 1; uVar4 != 0; uVar4 = uVar4 - 1) {
    puVar2 = param_1;
    param_1 = param_1 + 1;
    puVar1 = param_2;
    param_2 = param_2 + 1;
    *puVar2 = *puVar1;
  }
  for (uVar3 = (uint)((uVar3 & 1) != 0); uVar3 != 0; uVar3 = uVar3 - 1) {
    puVar2 = param_1;
    param_1 = (undefined2 *)((int)param_1 + 1);
    puVar1 = param_2;
    param_2 = (undefined2 *)((int)param_2 + 1);
    *(undefined *)puVar2 = *(undefined *)puVar1;
  }
  return;
}



// ======================================================================
// Function: _strlen
// Address: 1118:03f0
// ======================================================================


int __cdecl16far PUBLIC::_strlen(char *param_1)

{
  char *pcVar1;
  uint uVar2;
  
  uVar2 = 0xffff;
  do {
    if (uVar2 == 0) break;
    uVar2 = uVar2 - 1;
    pcVar1 = param_1;
    param_1 = param_1 + 1;
  } while (*pcVar1 != '\0');
  return ~uVar2 - 1;
}



// ======================================================================
// Summary: 79 succeeded, 7 failed
// ======================================================================
